---
title: "[운영체제] 5. 가상 메모리"
date: "2026-01-26"
slug: "os-virtual-memory"
description: "이것이 취업을 위한 컴퓨터 과학이다 + 혼자 공부하는 컴퓨터 구조/운영체제를 읽으면서 배운 내용을 정리합니다."
thumbnail: "./index.png"
pointColor: "#ffffff"
tags: ["운영체제"]
keywords: "운영체제, OS, 가상메모리, 페이징, 페이지테이블, MMU, TLB, 페이지폴트, 페이지교체알고리즘, FIFO, LRU"
---

![](./index.png)

> CPU와 프로세스는 메모리의 실제 주소를 직접 다루지 않는다. 대신 논리 주소와 가상 메모리를 통해 메모리를 관리한다. 이 글에서는 가상 메모리의 개념과 페이징 기법을 다룬다.

## 1️⃣ 물리 주소와 논리 주소

### 주소 체계의 필요성

CPU와 프로세스는 메모리에 무엇이 저장되어 있는지 모두 알고 있지 않다. 그 이유는 다음과 같다:

- CPU 내부의 레지스터 용량이 메모리보다 훨씬 작음
- 프로세스는 실시간으로 메모리에 적재되고 삭제됨
- 메모리 정보가 시시때때로 변경됨

따라서 CPU는 메모리의 실제 주소가 아닌 다른 주소 체계를 사용한다.

#### 1-1 물리 주소 (Physical Address)

`물리 주소`는 메모리 하드웨어 상의 실제 주소를 의미한다.

- 메모리에 실제로 존재하는 주소
- 중복되는 물리 주소의 번지 수는 존재하지 않음

#### 1-2 논리 주소 (Logical Address)

`논리 주소`는 프로세스마다 부여되는 0번지부터 시작하는 주소 체계다.

**📊 논리 주소의 특징**

- 각 프로세스는 독립적인 논리 주소 공간을 가짐
- 모든 프로세스가 0번지부터 시작하는 주소를 가짐
- 중복되는 논리 주소의 번지 수는 얼마든지 존재 가능

```
웹 브라우저: 논리 주소 0번지 ~ 1000번지
메모장:      논리 주소 0번지 ~ 500번지
게임:        논리 주소 0번지 ~ 2000번지
```

### MMU (Memory Management Unit)

논리 주소와 물리 주소 간의 변환을 위해 `MMU`가 존재한다.

#### 1-3 MMU의 역할

`MMU`는 CPU와 메모리 사이에 위치하여 논리 주소를 물리 주소로 변환하는 하드웨어다.

```
CPU (논리 주소) → MMU → 메모리 (물리 주소)
```

> 💡 **주소 변환의 필요성**
>
> CPU는 논리 주소로 통신하고 메모리는 물리 주소로 통신한다. 두 장치가 원활하게 통신하려면 MMU를 통한 주소 변환이 필수적이다.

## 2️⃣ 스와핑 (Swapping)

### 스와핑의 개념

`스와핑`은 메모리에 적재된 프로세스를 보조기억장치로 이동시키는 메모리 관리 방식이다.

#### 2-1 스와핑이 필요한 경우

다음과 같은 프로세스는 메모리에 계속 있을 필요가 없다:

- 입출력 작업으로 대기 상태가 된 프로세스
- 오랫동안 사용되지 않은 프로세스

#### 2-2 스왑 영역 (Swap Space)

`스왑 영역`은 보조기억장치의 일부 영역으로, 메모리에서 쫓겨난 프로세스가 임시로 저장되는 공간이다.

**macOS에서 스왑 영역 확인**

```
활성 상태 보기 → 메모리 탭
사용된 스왑 공간: 0바이트
```

**Linux에서 스왑 영역 확인**

```bash
$ free -h
              total        used        free      shared  buff/cache   available
Mem:           15Gi       8.2Gi       1.5Gi       589Mi       5.8Gi       6.5Gi
Swap:         2.0Gi       256Mi       1.7Gi
```

#### 2-3 스왑 인/아웃

| 용어                 | 설명                                     |
| -------------------- | ---------------------------------------- |
| 스왑 아웃 (Swap Out) | 메모리에서 스왑 영역으로 프로세스를 이동 |
| 스왑 인 (Swap In)    | 스왑 영역에서 메모리로 프로세스를 이동   |

**⚠️ 중요한 특징**

스왑 아웃되었던 프로세스가 다시 스왑 인될 때는 스왑 아웃되기 전의 물리 주소와 **다른 주소**에 적재될 수 있다.

## 3️⃣ 연속 메모리 할당과 외부 단편화

### 연속 메모리 할당

`연속 메모리 할당`은 프로세스에 연속적인 메모리 공간을 할당하는 방식이다.

```
메모리: [프로세스 A][프로세스 B][프로세스 C][빈 공간]
```

#### 3-1 외부 단편화 (External Fragmentation)

`외부 단편화`는 프로세스 바깥에 생기는 사용 불가능한 빈 공간을 의미한다.

**🚨 문제 상황**

```
메모리: [프로세스 A][빈 공간 30MB][프로세스 B][빈 공간 20MB]

새 프로세스 C (50MB) 적재 시도
→ 총 빈 공간: 50MB
→ 연속된 빈 공간이 없어 적재 불가능
```

프로세스의 실행과 종료를 반복하며 메모리 사이에 빈 공간이 생기고, 이러한 빈 공간들은 분명 비어있지만 큰 프로세스를 적재하기 어려워 **메모리 낭비**로 이어진다.

## 4️⃣ 가상 메모리 (Virtual Memory)

`가상 메모리`는 실행하고자 하는 프로그램의 일부만 메모리에 적재해, 실제 메모리보다 더 큰 프로세스를 실행할 수 있도록 만드는 메모리 관리 기법이다.

### 가상 메모리의 특징

- 보조기억장치의 일부를 메모리처럼 사용
- 프로세스의 일부만 메모리에 적재
- 메모리를 실제 크기보다 더 크게 보이게 함

> 💡 **가상 주소 공간 (Virtual Address Space)**
>
> 가상 메모리 기법으로 생성된 논리 주소 공간을 `가상 주소 공간`이라고도 부른다.

### 가상 메모리 관리 기법

대표적인 가상 메모리 관리 기법은 다음과 같다:

- **페이징 (Paging)**: 일정한 크기로 분할
- **세그멘테이션 (Segmentation)**: 가변적인 크기로 분할

이 중 더 범용적으로 사용되는 **페이징**에 대해 자세히 알아본다.

## 5️⃣ 페이징 (Paging)

`페이징`은 프로세스의 논리 주소 공간을 **페이지**라는 일정한 단위로 나누고, 물리 주소 공간을 **프레임**이라는 단위로 나눈 뒤 페이지를 프레임에 할당하는 기법이다.

### 페이징의 구성 요소

| 용어           | 설명                       | 위치        |
| -------------- | -------------------------- | ----------- |
| 페이지 (Page)  | 논리 주소 공간을 나눈 단위 | 논리 메모리 |
| 프레임 (Frame) | 물리 주소 공간을 나눈 단위 | 물리 메모리 |

#### 5-1 페이징의 핵심 특징

**🔑 불연속 할당**

프로세스를 구성하는 페이지는 물리 메모리 내에 **불연속적으로 배치**될 수 있다.

```
논리 주소: [페이지 0][페이지 1][페이지 2][페이지 3]
             ↓       ↓       ↓       ↓
물리 주소: [프레임 5][프레임 2][프레임 7][프레임 1]
```

**✅ 외부 단편화 해결**

페이지라는 일정한 크기로 프로세스를 분할하여 불연속적으로 할당하면, 연속 메모리 할당처럼 프로세스 바깥에 빈 공간이 생기지 않는다.

### 페이징에서의 스와핑

페이징 시스템에서는 프로세스 전체가 아닌 **페이지 단위**로 스왑 인/아웃된다.

| 용어                   | 설명                                   |
| ---------------------- | -------------------------------------- |
| 페이지 아웃 (Page Out) | 페이지를 메모리에서 스왑 영역으로 이동 |
| 페이지 인 (Page In)    | 페이지를 스왑 영역에서 메모리로 이동   |

#### 5-2 메모리보다 큰 프로세스 실행

프로세스의 일부 페이지는 메모리에, 일부는 보조기억장치에 적재될 수 있다.

```
프로세스 A의 페이지:
- 페이지 0, 1, 2: 메모리에 적재 (페이지 인)
- 페이지 3, 4, 5: 보조기억장치에 적재 (페이지 아웃)
```

이는 **프로세스 전체가 메모리에 적재될 필요가 없다**는 것을 의미하며, CPU 입장에서 바라본 논리 메모리의 크기가 실제 메모리보다 클 수 있다.

> 💡 **세그멘테이션 (Segmentation)**
>
> 세그멘테이션은 프로세스를 가변적인 크기의 세그먼트 단위로 분할하는 방식이다:
>
> - 유의미한 논리적 단위로 분할 (코드 영역, 데이터 영역 등)
> - 세그먼트의 크기가 일정하지 않아 외부 단편화 발생 가능
> - 페이징보다 논리적 구조를 반영하기 쉬움

## 6️⃣ 페이지 테이블 (Page Table)

물리 메모리 내에 페이지가 불연속적으로 배치되면, CPU는 다음으로 실행할 페이지의 위치를 찾기 어렵다. 이를 해결하기 위해 `페이지 테이블`을 사용한다.

### 페이지 테이블의 역할

`페이지 테이블`은 프로세스의 페이지와 실제로 적재된 프레임을 짝지어주는 정보다.

```
페이지 번호 → 페이지 테이블 → 프레임 번호
```

#### 6-1 페이지 테이블의 특징

- 페이지 번호와 프레임 번호가 대응됨
- 프로세스마다 독립적인 페이지 테이블을 가짐
- CPU는 페이지 테이블을 참조하여 메모리에 접근

### 페이지 테이블 엔트리 (PTE)

`페이지 테이블 엔트리`는 페이지 테이블을 구성하는 각 행을 의미한다.

#### 6-2 PTE의 구성 요소

**유효 비트 (Valid Bit)**

페이지가 메모리에 적재되어 있는지 여부를 나타낸다.

| 값  | 의미                           |
| --- | ------------------------------ |
| 1   | 페이지가 메모리에 적재됨       |
| 0   | 페이지가 보조기억장치에 적재됨 |

**보호 비트 (Protection Bit)**

페이지 접근 권한을 나타낸다.

```
r (Read): 읽기 가능
w (Write): 쓰기 가능
x (Execute): 실행 가능

예시:
100 → 읽기만 가능
111 → 읽기, 쓰기, 실행 모두 가능
```

**참조 비트 (Reference Bit)**

CPU가 해당 페이지에 접근한 적이 있는지 여부를 나타낸다.

| 값  | 의미                                 |
| --- | ------------------------------------ |
| 1   | CPU가 읽거나 쓴 페이지               |
| 0   | 적재 후 한 번도 접근하지 않은 페이지 |

**수정 비트 (Modified Bit / Dirty Bit)**

해당 페이지에 데이터를 쓴 적이 있는지 여부를 나타낸다.

| 값  | 의미                  | 페이지 삭제 시 동작                |
| --- | --------------------- | ---------------------------------- |
| 1   | 쓰기 작업을 한 페이지 | 보조기억장치에 수정 내역 반영 필요 |
| 0   | 읽기만 한 페이지      | 별도의 쓰기 작업 없이 삭제 가능    |

### 페이지 폴트 (Page Fault)

`페이지 폴트`는 CPU가 메모리에 적재되지 않은 페이지(유효 비트가 0인 페이지)에 접근하려 할 때 발생하는 예외다.

#### 6-3 페이지 폴트 처리 과정

1. 기존 작업 내역을 백업
2. 페이지 폴트 처리 루틴 실행
   - 원하는 페이지를 메모리로 적재
   - 유효 비트를 1로 변경
3. 메모리에 적재된 페이지를 실행

**Windows에서 페이지 폴트 확인**

```
리소스 모니터 → 메모리 탭 → 페이지 폴트/초
```

### 내부 단편화 (Internal Fragmentation)

`내부 단편화`는 페이지 내부에서 발생하는 메모리 낭비를 의미한다.

#### 6-4 내부 단편화 발생 원인

모든 프로세스의 크기가 페이지 크기의 배수가 아니기 때문에 발생한다.

```
페이지 크기: 10KB
프로세스 크기: 107KB

필요한 페이지 수: 11개 (10KB × 10 + 7KB)
마지막 페이지: 7KB만 사용, 3KB 낭비 ← 내부 단편화
```

> 💡 **외부 단편화 vs 내부 단편화**
>
> | 구분        | 설명                        | 발생 위치                 |
> | ----------- | --------------------------- | ------------------------- |
> | 외부 단편화 | 프로세스 바깥의 빈 공간     | 연속 메모리 할당에서 발생 |
> | 내부 단편화 | 페이지 내부의 낭비되는 공간 | 페이징에서 발생           |

## 7️⃣ 페이지 테이블 관리

### PTBR (Page Table Base Register)

`PTBR`은 프로세스의 페이지 테이블이 적재된 메모리 상의 위치를 가리키는 레지스터다.

#### 7-1 PTBR의 특징

- 프로세스마다 다른 값을 가짐
- PCB에 기록됨
- 문맥 교환 시 변경됨

```
프로세스 A 실행: PTBR → 프로세스 A의 페이지 테이블
프로세스 B 실행: PTBR → 프로세스 B의 페이지 테이블
```

### 페이지 테이블 관리의 문제점

모든 프로세스의 페이지 테이블을 메모리에 두는 것은 비효율적이다:

1. **메모리 접근 횟수 증가**: 페이지 테이블 접근 + 실제 프레임 접근 = 2회
2. **메모리 용량 낭비**: 페이지 테이블이 상당한 메모리 공간을 차지

#### 7-2 TLB (Translation Lookaside Buffer)

`TLB`는 페이지 테이블의 캐시 메모리로, 자주 사용하는 페이지 테이블 엔트리를 저장한다.

**🚀 TLB 동작 방식**

```
TLB 히트 (TLB Hit):
논리 주소 → TLB에서 프레임 번호 찾음 → 메모리 1회 접근

TLB 미스 (TLB Miss):
논리 주소 → TLB에 없음 → 페이지 테이블 확인 → 메모리 2회 접근
```

**✅ TLB의 장점**

- 참조 지역성의 원리에 근거하여 동작
- TLB 히트 시 메모리 접근 횟수를 절반으로 감소
- TLB 히트율을 높이면 전체 성능 향상

#### 7-3 계층적 페이징 (Hierarchical Paging)

`계층적 페이징`은 페이지 테이블을 페이징하는 방식으로, `다단계 페이지 테이블`이라고도 한다.

**🎯 계층적 페이징의 목적**

페이지 테이블의 크기가 크므로 모든 페이지 테이블을 메모리에 유지하는 것은 메모리 낭비다. 계층적 페이징을 사용하면 필요한 페이지 테이블만 메모리에 유지할 수 있다.

**📊 2단계 페이징 구조**

```
Outer 페이지 테이블 (메모리에 항상 유지)
    ↓
Inner 페이지 테이블 (필요 시 메모리에 적재)
    ↓
실제 프레임
```

**✅ 계층적 페이징의 장점**

- Outer 페이지 테이블만 메모리에 유지
- Inner 페이지 테이블의 일부는 보조기억장치에 저장 가능
- 메모리 사용량 감소

> 💡 **다단계 페이징**
>
> 페이지 테이블의 계층은 2단계뿐만 아니라 3단계, 4단계, 그 이상으로도 구성될 수 있다. 계층이 깊어질수록 메모리 사용량은 감소하지만, 메모리 접근 횟수는 증가한다.

## 8️⃣ 페이징 주소 체계

페이징 시스템의 논리 주소는 `<페이지 번호, 변위>`의 형태로 구성된다.

### 논리 주소의 구성

| 구성 요소                 | 설명                                        |
| ------------------------- | ------------------------------------------- |
| 페이지 번호 (Page Number) | 접근할 페이지 번호 (페이지 테이블의 인덱스) |
| 변위 (Offset)             | 페이지 시작 번지로부터의 거리               |

#### 8-1 주소 변환 과정

```
논리 주소: <페이지 번호, 변위>
    ↓
페이지 테이블 참조
    ↓
물리 주소: <프레임 번호, 변위>
```

### 주소 변환 예시

다음과 같은 상황을 가정한다:

- 하나의 페이지/프레임: 4개의 주소로 구성
- 페이지 테이블:
  ```
  페이지 0 → 프레임 5
  페이지 1 → 프레임 4
  페이지 2 → 프레임 6
  페이지 3 → 프레임 2
  페이지 4 → 프레임 7
  페이지 5 → 프레임 1
  ```

#### 8-2 주소 변환 계산

CPU가 논리 주소 `<5, 2>`에 접근하는 경우:

1. 페이지 5는 프레임 1에 적재됨
2. 프레임 1은 물리 주소 8번지부터 시작 (1 × 4 = 4번지부터 시작하는 프레임 1)
3. 변위 2를 더하면 10번지
4. **최종 물리 주소: 10번지**

```
논리 주소 <5, 2>
    ↓
페이지 5 → 프레임 1 (물리 주소 8번지~11번지)
    ↓
물리 주소: 8번지 + 2 = 10번지
```

## 9️⃣ 요구 페이징 (Demand Paging)

`요구 페이징`은 메모리에 필요한(요구되는) 페이지만을 적재하는 기법이다.

### 요구 페이징의 동작 방식

1. CPU가 특정 페이지에 접근하는 명령어를 실행
2. **페이지가 메모리에 있는 경우** (유효 비트 = 1):
   - CPU는 페이지가 적재된 프레임에 접근
3. **페이지가 메모리에 없는 경우** (유효 비트 = 0):
   - 페이지 폴트 발생
   - 페이지 폴트 처리 루틴 실행
   - 해당 페이지를 메모리로 적재
   - 유효 비트를 1로 설정
4. 1번 과정 재수행

#### 9-1 순수 요구 페이징 (Pure Demand Paging)

`순수 요구 페이징`은 아무런 페이지도 메모리에 적재하지 않은 채 프로세스를 실행하는 방식이다.

**📊 순수 요구 페이징의 특징**

- 프로세스의 첫 명령어 실행 순간부터 페이지 폴트 발생
- 실행에 필요한 페이지가 어느 정도 적재된 후 페이지 폴트 발생 빈도 감소

### 페이지 교체의 필요성

요구 페이징을 통해 페이지를 메모리에 적재하다 보면 언젠가는 메모리가 가득 찬다. 메모리가 가득 찬 상황에서 추가로 페이지를 적재하려면 **일부 페이지를 스왑 아웃**해야 한다.

## 🔟 페이지 교체 알고리즘

`페이지 교체 알고리즘`은 메모리에서 보조기억장치로 내보낼 페이지를 선택하는 방법이다.

### 페이지 교체 알고리즘의 중요성

좋은 페이지 교체 알고리즘은 **페이지 폴트의 발생 빈도를 줄인다**:

- 좋은 알고리즘: 사용되지 않을 페이지를 내보냄 → 페이지 폴트 적음
- 나쁜 알고리즘: 곧 사용될 페이지를 내보냄 → 페이지 폴트 빈번

**⚠️ 스래싱 (Thrashing)**

지나친 페이지 교체로 인해 프로세스가 실제 실행되는 시간보다 페이징에 더 많은 시간을 소요하여 성능이 저하되는 문제를 `스래싱`이라고 한다.

### FIFO (First-In-First-Out)

`FIFO 페이지 교체 알고리즘`은 메모리에 가장 먼저 적재된 페이지부터 스왑 아웃하는 알고리즘이다.

#### 10-1 FIFO의 특징

**✅ 장점**

- 아이디어와 구현이 간단함

**⚠️ 단점**

- 초기에 적재되어 줄곧 참조되고 있는 페이지를 스왑 아웃할 우려
- 머지않아 페이지 폴트 발생 가능

```
메모리 상태: [페이지 1][페이지 2][페이지 3]
새 페이지 4 적재 시: 페이지 1 교체 (가장 먼저 적재됨)
→ 페이지 1이 자주 사용되는 페이지라면 비효율적
```

### 최적 (Optimal)

`최적 페이지 교체 알고리즘`은 앞으로의 사용 빈도가 가장 낮은 페이지를 교체하는 알고리즘이다.

#### 10-2 최적 알고리즘의 특징

**✅ 장점**

- 가장 낮은 페이지 폴트율 보장
- 이론적으로 최적의 성능

**⚠️ 단점**

- 앞으로 가장 적게 사용할 페이지를 미리 예측하기 어려움
- 실제 구현이 어려움

```
미래의 페이지 참조 순서를 알 수 없으므로
실제로는 구현 불가능
```

### LRU (Least Recently Used)

`LRU 페이지 교체 알고리즘`은 가장 오래 사용하지 않은 페이지를 교체하는 알고리즘이다.

#### 10-3 LRU의 특징

**🎯 핵심 아이디어**

최적 알고리즘이 "앞으로 가장 적게 사용할" 페이지를 교체한다면, LRU는 "과거에 가장 적게 사용한" 페이지를 교체한다.

**✅ 장점**

- 참조 지역성의 원리를 활용
- 최근에 사용된 페이지는 앞으로도 사용될 가능성이 높다는 가정
- 실제로 구현 가능하며 효율적
- 가장 보편적으로 사용됨

**📊 LRU 동작 예시**

```
메모리 상태: [페이지 1 (10초 전)][페이지 2 (5초 전)][페이지 3 (1초 전)]
새 페이지 4 적재 시: 페이지 1 교체 (가장 오래 전에 사용됨)
```

> 💡 **페이지 교체 알고리즘 비교**
>
> | 알고리즘 | 기준           | 장점              | 단점                             |
> | -------- | -------------- | ----------------- | -------------------------------- |
> | FIFO     | 적재 순서      | 구현 간단         | 자주 사용하는 페이지도 교체 가능 |
> | 최적     | 미래 사용 빈도 | 최적의 성능       | 구현 불가능                      |
> | LRU      | 과거 사용 시점 | 실용적이고 효율적 | 구현 복잡도가 상대적으로 높음    |

## 정리

가상 메모리의 핵심 개념을 정리하면 다음과 같다:

**주소 체계**

- **논리 주소**: 프로세스가 사용하는 0번지부터 시작하는 주소
- **물리 주소**: 메모리의 실제 주소
- **MMU**: 논리 주소를 물리 주소로 변환하는 하드웨어

**메모리 관리 기법**

- **스와핑**: 프로세스를 메모리와 보조기억장치 간에 이동
- **페이징**: 일정한 크기의 페이지/프레임 단위로 메모리 관리
- **요구 페이징**: 필요한 페이지만 메모리에 적재

**페이지 테이블**

- 페이지와 프레임을 매핑하는 정보
- PTE에는 유효 비트, 보호 비트, 참조 비트, 수정 비트 포함
- PTBR로 페이지 테이블의 위치 관리
- TLB로 페이지 테이블 접근 속도 향상

**페이지 교체 알고리즘**

- **FIFO**: 먼저 적재된 페이지를 교체
- **최적**: 앞으로 가장 적게 사용할 페이지를 교체 (이론적)
- **LRU**: 가장 오래 사용하지 않은 페이지를 교체 (실용적)
