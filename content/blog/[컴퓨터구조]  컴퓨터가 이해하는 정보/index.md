---
title: "[컴퓨터구조] 2. 컴퓨터가 이해하는 정보"
slug: "computer-architecture-computer-information"
date: "2026-01-17"
description: "이것이 컴퓨터 과학이다 + 혼자 공부하는 컴퓨터 구조/운영체제를 읽으면서 배운 내용을 정리합니다. 컴퓨터가 데이터와 명령어를 어떻게 이해하고 처리하는지 2진법 체계와 명령어 구조를 중심으로 살펴봅니다. "
thumbnail: "./index.png"
pointColor: "#ffffff"
tags: ["컴퓨터구조"]
keywords: "컴퓨터구조, CS, Computer Science, 컴퓨터 과학, CPU, 메모리, 데이터, 이것이 취업을 위한 컴퓨터 과학이다, 혼공컴운, 혼자 공부하는 컴퓨터 구조"
---

![](./index.png)

> '이것이 취업을 위한 컴퓨터 과학이다 with CS 기술 면접' 책을 읽으면서 배운 점을 정리합니다. 2진법 체계와 명령어 구조를 중심으로 살펴봅니다.

## 1비트와 바이트

컴퓨터는 0과 1만을 이해한다. 0과 1을 나타내는 가장 작은 작업 단위를 `비트(bit)`라고 한다.

**비트와 정보 표현**

- k비트는 2^k 만큼의 정보를 표현할 수 있다
- 1byte = 8bit (256가지 표현 가능)
- 1KB = 1,000byte
- 1MB = 1,000KB

```python
# 비트로 표현 가능한 정보의 수
bits = 8
possible_values = 2 ** bits
print(f"{bits}비트로 표현 가능한 값: {possible_values}개")  # 256개
```

## 2️⃣ 2진법으로 소수 표현하기

### 부동 소수점의 한계

```python
print(0.1 + 0.2 == 0.3)  # False
print(0.1 + 0.2)  # 0.30000000000000004
```

대부분의 프로그래밍 언어에서 위 코드의 결과는 `False`이다. 이유는 `부동 소수점(floating point)` 표현 방식의 정밀도에 한계가 있기 때문이다.

### 부동 소수점 표현 방식

부동 소수점은 소수점의 위치가 고정되지 않은(floating) 소수 표현 방식이다.

**🔍 10진수 예시**

10진수 123.123을 m\*10^n 형태로 표현하면:

- n=2, m=1.23123
- n=-1, m=1231.23

이렇게 소수점의 위치를 고정시키지 않고 같은 소수를 다양하게 표현할 수 있는 방식이 부동 소수점 표현 방식이다.

### IEEE 754 표준

2진수 체계에서는 IEEE 754 표준을 사용하여 부동 소수점을 표현한다.

**⚙️ IEEE 754 구조 (32bit 단정밀도)**

| 구성 요소      | 비트 수 | 역할                 |
| -------------- | ------- | -------------------- |
| 부호(Sign)     | 1bit    | 양수(0) 또는 음수(1) |
| 지수(Exponent) | 8bit    | 소수점 위치 결정     |
| 가수(Mantissa) | 23bit   | 실제 숫자 값 저장    |

**⚠️ 정밀도 한계**

10진수 소수를 2진수로 표현할 때 10진수와 2진수의 표현이 딱 맞아떨어지지 않을 수 있다.

```
1/3 = 0.333333...  # 10진수 무한 소수
0.1(10진수) = 0.0001100110011...(2진수)  # 2진수 무한 소수
```

이럴 경우 일부 소수점을 생략하여 저장하므로 오차가 발생한다.

## 3️⃣ 명령어

### 명령어 구조

명령어는 `연산 코드(opcode)`와 `오퍼랜드(operand)`로 구성되어 있다.

| 구성 요소 | 역할                 | 예시                       |
| --------- | -------------------- | -------------------------- |
| 연산 코드 | 명령어가 수행할 동작 | ADD, SUB, LOAD, STORE      |
| 오퍼랜드  | 데이터가 저장된 위치 | 메모리 주소, 레지스터 이름 |

**🎯 연산 코드의 주요 유형**

- **데이터 전송**: LOAD, STORE, MOVE
- **산술 연산**: ADD, SUB, MUL, DIV
- **제어 흐름 변경**: JUMP, CALL, RETURN
- **입출력 제어**: READ, WRITE

### 주소 지정 방식

오퍼랜드 필드에는 데이터가 직접 명시되기보다는 **메모리 주소**나 **레지스터 이름**이 명시된다.

```js
LOAD R1, [1000]  # 메모리 주소 1000의 값을 R1 레지스터로 로드
ADD R1, R2       # R1과 R2의 값을 더해서 R1에 저장
```

CPU가 메모리에서 인출한 명령어를 곧바로 실행하지 못하고 한 번 더 메모리에 접근해야 하는 이유가 바로 이 때문이다.

> **💡 주소 지정 방식의 종류**
>
> - **즉시 주소 지정**: 오퍼랜드에 데이터 직접 명시
> - **직접 주소 지정**: 오퍼랜드에 메모리 주소 명시
> - **간접 주소 지정**: 오퍼랜드에 메모리 주소를 가리키는 주소 명시
> - **레지스터 주소 지정**: 오퍼랜드에 레지스터 이름 명시

## 4️⃣ 명령어 사이클

CPU가 명령어를 처리하는 과정을 `명령어 사이클(instruction cycle)`이라고 한다.

### 명령어 사이클의 단계

**1. 인출 사이클 (Fetch Cycle)**

메모리에서 실행할 명령어를 가져오는 단계이다.

```
1. PC(Program Counter)가 가리키는 메모리 주소에서 명령어 읽기
2. 읽어온 명령어를 IR(Instruction Register)에 저장
3. PC 값을 다음 명령어 주소로 증가
```

**2. 실행 사이클 (Execution Cycle)**

인출한 명령어를 해석하고 실행하는 단계이다.

```js
1. 제어장치가 명령어 해독
2. ALU에서 연산 수행
3. 결과를 레지스터나 메모리에 저장
```

**3. 간접 사이클 (Indirect Cycle)**

오퍼랜드 필드에 주소가 명시된 경우, 명령어 실행을 위해 메모리에 접근하는 단계이다.

```js
1. 오퍼랜드가 가리키는 메모리 주소 접근
2. 실제 데이터 주소 획득
3. 해당 주소의 데이터 인출
```

### 명령어 사이클의 흐름

```js
인출 사이클 → (간접 사이클) → 실행 사이클 → 인출 사이클 → ...
```

간접 사이클은 필요한 경우에만 수행되며, 이 과정이 반복되면서 프로그램이 실행된다.

> **💡 명령어 사이클과 성능**
>
> - 명령어 사이클이 짧을수록 CPU 성능이 향상된다
> - `클럭(Clock)`: 명령어 사이클의 기본 단위 시간
> - `CPI(Cycles Per Instruction)`: 명령어당 필요한 클럭 수
> - CPU 성능 = 클럭 속도 / CPI
