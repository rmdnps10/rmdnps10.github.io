---
title: "[운영체제] 파일 시스템"
date: "2026-01-27"
slug: "os-file-system"
description: "이것이 취업을 위한 컴퓨터 과학이다 + 혼자 공부하는 컴퓨터 구조/운영체제를 읽으면서 배운 내용을 정리합니다."
thumbnail: "./index.png"
pointColor: "#ffffff"
tags: ["운영체제"]
keywords: "운영체제, OS, 커널, 시스템콜, CPU 스케줄링, 가상 메모리, 프로세스, 스레드, 파일 시스템"
---

> 운영체제는 보조기억장치의 수많은 데이터를 어떻게 체계적으로 관리할까? 파일 시스템은 데이터를 파일과 디렉터리로 구조화하여 효율적으로 저장하고 접근할 수 있게 한다. 파일 시스템의 핵심 개념과 구현 방식을 살펴본다.

## 1️⃣ 파일 시스템 개요

`파일 시스템`은 보조기억장치의 데이터를 파일과 디렉터리 형태로 저장하고 관리하는 운영체제의 핵심 구성 요소다. 파일 시스템 덕분에 사용자와 응용 프로그램은 복잡한 저장 장치의 물리적 구조를 신경 쓰지 않고 데이터에 접근할 수 있다.

### 파일 시스템의 역할

- 데이터를 파일 단위로 구조화하여 저장
- 디렉터리를 통한 계층적 파일 관리
- 파일에 대한 접근 권한 및 보안 관리
- 저장 공간의 효율적인 할당과 회수

운영체제마다 서로 다른 파일 시스템을 지원하며, 하나의 컴퓨터에서 여러 파일 시스템을 동시에 사용할 수도 있다.

## 2️⃣ 파일의 구조

### 파일의 구성 요소

파일은 크게 세 가지 요소로 구성된다.

| 구성 요소                      | 설명                                              |
| ------------------------------ | ------------------------------------------------- |
| 파일 이름                      | 파일을 식별하는 이름                              |
| 파일 데이터                    | 실제 저장된 내용                                  |
| 파일 속성 (Attribute/Metadata) | 파일의 형식, 위치, 크기, 생성 시간 등의 부가 정보 |

### 파일 디스크립터

운영체제는 프로세스가 파일을 다룰 때 `파일 디스크립터`라는 정수 값으로 파일을 식별한다. 프로세스가 파일을 열거나 생성하면, 운영체제는 해당 파일에 대한 파일 디스크립터를 할당한다.

> 💡 **파일 디스크립터의 확장된 역할**
>
> 파일 디스크립터는 파일뿐만 아니라 입출력 장치, 파이프(Pipe), 소켓(Socket) 등도 식별한다. 유닉스/리눅스에서는 "모든 것이 파일이다(Everything is a file)"라는 철학에 따라 다양한 자원을 파일 디스크립터로 통합 관리한다.

## 3️⃣ 디렉터리의 구조

### 디렉터리의 개념

`디렉토리` 파일들을 계층적으로 관리하기 위한 구조다. 윈도우에서는 폴더(Folder)라고 부른다. 현대의 운영체제는 트리 구조 디렉터리(Tree-structured Directory)를 사용하여 파일을 체계적으로 조직한다.

#### 🌳 디렉터리 계층 구조

- **루트 디렉터리(Root Directory)**: 최상위 디렉터리로 `/`로 표현
- **서브 디렉터리(Subdirectory)**: 상위 디렉터리에 포함된 하위 디렉터리
- **경로(Path)**: 파일의 위치를 나타내는 문자열 (예: `/home/user/document.txt`)

> 💡 **윈도우의 디렉터리 구조**
>
> 윈도우는 최상위 디렉터리를 `C:\`와 같이 표현하고, 백슬래시(`\`)를 디렉터리 구분자로 사용한다.

### 디렉터리 엔트리

많은 운영체제에서 **디렉터리는 특별한 형태의 파일**로 구현된다. 디렉터리에 속한 파일과 하위 디렉터리의 정보는 `디렉터리 엔트리(Directory Entry)`라는 테이블 형태로 저장된다.

#### 디렉터리 엔트리의 구성

디렉터리 엔트리에는 다음 정보가 포함된다.

- **파일 이름**: 파일 또는 디렉터리의 이름
- **위치 정보**: 파일이 저장된 블록의 주소를 유추할 수 있는 정보
- **파일 속성**: 일부 파일 시스템은 크기, 생성 시간 등의 속성도 포함

#### 특수 디렉터리 엔트리

대부분의 파일 시스템은 두 가지 특수 디렉터리 엔트리를 제공한다.

| 엔트리 | 의미          |
| ------ | ------------- |
| `.`    | 현재 디렉터리 |
| `..`   | 상위 디렉터리 |

## 4️⃣ 파일 할당 방식

운영체제는 파일을 **블록(Block)** 단위로 보조기억장치에 저장한다. 하나의 블록은 일반적으로 4096바이트 크기다. 파일 시스템에 따라 블록을 할당하는 방식이 다르다.

### 연결 할당 (Linked Allocation)

#### 동작 원리

각 블록의 일부에 다음 블록의 주소를 저장하여, 블록들이 연결 리스트 형태로 이어진다.

**특징**

- 디렉터리 엔트리에는 첫 번째 블록 주소와 파일 길이를 저장
- 순차 접근에 유리하지만 임의 접근이 느림
- 외부 단편화가 발생하지 않음

### 색인 할당 (Indexed Allocation)

#### 동작 원리

파일을 구성하는 모든 블록의 주소를 **색인 블록(Index Block)**이라는 특별한 블록에 모아서 관리한다.

**특징**

- 디렉터리 엔트리에는 색인 블록의 주소만 저장
- 임의 접근이 빠름
- 작은 파일의 경우 색인 블록으로 인한 공간 낭비 발생 가능

## 5️⃣ 파일 시스템의 종류

### 운영체제별 파일 시스템

각 운영체제는 고유한 파일 시스템을 지원한다.

| 운영체제 | 파일 시스템                |
| -------- | -------------------------- |
| 윈도우   | NTFS, ReFS                 |
| 리눅스   | EXT2, EXT3, EXT4, XFS, ZFS |
| macOS    | APFS                       |

### 파티셔닝

`파티셔닝`은 하나의 보조기억장치를 여러 논리적 영역(**Partition**)으로 나누는 작업이다. 각 파티션마다 서로 다른 파일 시스템을 적용할 수 있다.

**파티셔닝의 장점**

- 하나의 디스크에 여러 운영체제 설치 가능
- 데이터와 시스템 파일을 분리하여 관리
- 파티션 단위로 독립적인 파일 시스템 구성

### 포매팅

`포매팅`은 저장 장치에 파일 시스템을 설정하는 작업이다. 포매팅 과정에서 다음을 결정한다.

- 사용할 파일 시스템의 종류
- 블록 크기
- 파일 시스템의 메타데이터 구조

## 6️⃣ Inode 기반 파일 시스템

### Inode의 개념

`Inode(Index Node)`는 파일의 메타데이터와 저장 위치 정보를 담고 있는 자료구조다. 리눅스와 macOS의 많은 파일 시스템(EXT 계열, XFS, ZFS 등)은 Inode를 기반으로 구현된다.

#### Inode의 특징

- 파일마다 고유한 Inode 번호를 가짐
- 파일 이름을 제외한 모든 파일 정보를 저장
- 디렉터리 엔트리는 파일 이름과 Inode 번호를 매핑

### EXT4 파일 시스템 구조

#### EXT4의 블록 그룹 구조

EXT4 파일 시스템은 여러 `블록 그룹(Block Group)`로 구성되며, 각 블록 그룹은 다음 요소를 포함한다.

| 구성 요소                      | 설명                                                                |
| ------------------------------ | ------------------------------------------------------------------- |
| 슈퍼 블록 (Super Block)        | 전체 파일 시스템의 메타데이터 (Inode 개수, 블록 개수, 블록 크기 등) |
| 그룹 식별자 (Group Descriptor) | 블록 그룹의 메타데이터                                              |
| 블록 비트맵 (Block Bitmap)     | 데이터 블록의 할당 상태                                             |
| Inode 비트맵 (Inode Bitmap)    | Inode의 할당 상태                                                   |
| Inode 테이블 (Inode Table)     | 파일들의 Inode 정보                                                 |
| 데이터 블록 (Data Blocks)      | 실제 파일 데이터                                                    |

#### ⚠️ Inode 부족 문제

Inode는 파티션 내 특정 영역에 제한적으로 존재한다. **데이터 블록에 공간이 남아 있어도 Inode가 모두 소진되면 새로운 파일을 생성할 수 없다.**

### 하드 링크와 심볼릭 링크

#### 🔗 Hard Link

**Hard Link**는 원본 파일과 동일한 Inode를 가리키는 파일이다.

**특징**

- 원본 파일과 같은 데이터를 공유
- 원본 파일이 삭제되어도 하드 링크를 통해 데이터 접근 가능
- 서로 다른 파일 시스템 간에는 생성 불가능

#### 🔗 Symbolic Link (Soft Link)

**Symbolic Link**는 원본 파일의 경로를 저장하는 특수한 파일이다.

**특징**

- 원본 파일의 경로만 저장하며 데이터를 공유하지 않음
- 원본 파일이 삭제되면 링크가 깨짐 (Dangling Link)
- 서로 다른 파일 시스템 간에도 생성 가능

> 💡 **사용 시나리오**
>
> - **Hard Link**: 중요한 파일의 백업, 여러 이름으로 동일한 파일 참조
> - **Symbolic Link**: 복잡한 경로의 파일에 대한 단축 경로, 버전 관리

## 7️⃣ 마운트

### 마운트의 개념

**Mount**는 한 파일 시스템을 다른 파일 시스템의 디렉터리에 연결하는 작업이다. 마운트를 통해 외부 저장 장치(USB, 외장 하드 등)의 파일 시스템에 접근할 수 있다.

#### 마운트 프로세스

1. 외부 저장 장치를 컴퓨터에 연결
2. 운영체제가 저장 장치의 파일 시스템을 인식
3. 특정 디렉터리(마운트 포인트)에 파일 시스템을 마운트
4. 마운트 포인트를 통해 외부 저장 장치의 파일에 접근
