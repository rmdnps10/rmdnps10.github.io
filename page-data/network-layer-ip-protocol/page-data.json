{"componentChunkName":"component---src-templates-blog-post-js","path":"/network-layer-ip-protocol/","result":{"data":{"site":{"siteMetadata":{"title":"홈","siteUrl":"https://inyoung.dev","author":{"name":"Inyoung Chung"}}},"allMarkdownRemark":{"nodes":[{"fields":{"slug":"/boj-1106-hotel/"},"frontmatter":{"title":"[백준 JAVA] 호텔 1106 머릿속에 박아넣기","date":"2026-02-20","tags":["알고리즘"],"pointColor":"#ffffff"}},{"fields":{"slug":"/http-advanced-features/"},"frontmatter":{"title":"[네트워크] HTTP의 응용 - 쿠키, 캐시, 보안","date":"2026-02-17","tags":["네트워크"],"pointColor":"#ffffff"}},{"fields":{"slug":"/http-fundamentals/"},"frontmatter":{"title":"[네트워크] HTTP의 기초 - DNS와 HTTP Message, Method, Status (스압 주의) ","date":"2026-02-16","tags":["네트워크"],"pointColor":"#ffffff"}},{"fields":{"slug":"/transport-layer-tcp-udp/"},"frontmatter":{"title":"[네트워크] 전송 계층 - TCP와 UDP","date":"2026-02-15","tags":["네트워크"],"pointColor":"#ffffff"}},{"fields":{"slug":"/network-layer-ip-protocol/"},"frontmatter":{"title":"[네트워크] 네트워크 계층과 IP 프로토콜","date":"2026-02-14","tags":["네트워크"],"pointColor":"#ffffff"}},{"fields":{"slug":"/physical-and-data-link-layer/"},"frontmatter":{"title":"[네트워크] 물리 계층과 데이터 링크 계층 - 이더넷과 네트워크 장비","date":"2026-02-13","tags":["네트워크"],"pointColor":"#ffffff"}},{"fields":{"slug":"/network-big-picture/"},"frontmatter":{"title":"[네트워크] 네트워크의 큰 그림","date":"2026-02-12","tags":["네트워크"],"pointColor":"#ffffff"}},{"fields":{"slug":"/troubleshooting-supabase-auth/"},"frontmatter":{"title":"[트러블슈팅] Supabase Auth를 활용한 다양한 환경에서의 세션 유지","date":"2026-02-10","tags":["Web","회고"],"pointColor":"#3ECF8D"}},{"fields":{"slug":"/waterfall-agile/"},"frontmatter":{"title":"[소프트웨어공학] Waterfall과 Agile","date":"2026-02-03","tags":["소프트웨어공학"],"pointColor":"#ffffff"}},{"fields":{"slug":"/os-file-system/"},"frontmatter":{"title":"[운영체제] 파일 시스템","date":"2026-01-27","tags":["운영체제"],"pointColor":"#ffffff"}},{"fields":{"slug":"/os-virtual-memory/"},"frontmatter":{"title":"[운영체제] 5. 가상 메모리","date":"2026-01-26","tags":["운영체제"],"pointColor":"#ffffff"}},{"fields":{"slug":"/os-cpu-scheduling/"},"frontmatter":{"title":"[운영체제] 4. CPU 스케줄링","date":"2026-01-25","tags":["운영체제"],"pointColor":"#ffffff"}},{"fields":{"slug":"/os-synchronization-deadlock/"},"frontmatter":{"title":"[운영체제] 3. 동기화와 교착 상태","date":"2026-01-24","tags":["운영체제"],"pointColor":"#ffffff"}},{"fields":{"slug":"/os-process-thread/"},"frontmatter":{"title":"[운영체제] 2. 프로세스와 스레드","date":"2026-01-23","tags":["운영체제"],"pointColor":"#ffffff"}},{"fields":{"slug":"/os-big-picture/"},"frontmatter":{"title":"[운영체제] 1. 운영체제의 큰 그림","date":"2026-01-21","tags":["운영체제"],"pointColor":"#ffffff"}},{"fields":{"slug":"/computer-architecture-cpu/"},"frontmatter":{"title":"[컴퓨터구조] 3. CPU","date":"2026-01-18","tags":["컴퓨터구조"],"pointColor":"#ffffff"}},{"fields":{"slug":"/computer-architecture-computer-information/"},"frontmatter":{"title":"[컴퓨터구조] 2. 컴퓨터가 이해하는 정보","date":"2026-01-17","tags":["컴퓨터구조"],"pointColor":"#ffffff"}},{"fields":{"slug":"/computer-architecture-big-picture/"},"frontmatter":{"title":"[컴퓨터구조] 1. 컴퓨터구조의 큰 그림","date":"2026-01-15","tags":["컴퓨터구조"],"pointColor":"#ffffff"}},{"fields":{"slug":"/java-coding-test-grammer/"},"frontmatter":{"title":"Java 코딩테스트 문법 최종 정리","date":"2026-01-08","tags":["알고리즘"],"pointColor":"#ed8b00"}},{"fields":{"slug":"/lg-webos-tv-fullstack-appliaction/"},"frontmatter":{"title":"WebOS TV에 들어갈 풀스택 애플리케이션을 만들어보자 (LG전자 산학 프로젝트 후기)","date":"2025-12-22","tags":["회고"],"pointColor":"#ffffff"}},{"fields":{"slug":"/algorithm-maximum-flow/"},"frontmatter":{"title":"알고리즘설계와분석 - 최대 유량 문제 (Maximum Flow)","date":"2025-12-16","tags":["알고리즘"],"pointColor":"#ffffff"}},{"fields":{"slug":"/algorithm-shortest-path/"},"frontmatter":{"title":"알고리즘설계와분석 - 최단경로 (Shortest Path)","date":"2025-12-13","tags":["알고리즘"],"pointColor":"#ffffff"}},{"fields":{"slug":"/algorithm-minimum-spanning-tree/"},"frontmatter":{"title":"알고리즘설계와분석 - MST (최소신장트리)","date":"2025-12-12","tags":["알고리즘"],"pointColor":"#ffffff"}},{"fields":{"slug":"/algorithm-bfs-dfs/"},"frontmatter":{"title":"BFS/DFS와 Topological Sort","date":"2025-12-11","tags":["알고리즘"],"pointColor":"#ffffff"}},{"fields":{"slug":"/algorithm-greedy-algorithm/"},"frontmatter":{"title":"알고리즘설계와분석 - Greedy algorithm (그리디 알고리즘)","date":"2025-12-10","tags":["알고리즘"],"pointColor":"#ffffff"}},{"fields":{"slug":"/algorithm-dynamic-programming/"},"frontmatter":{"title":"알고리즘설계와분석 - Dynamic Programming (동적 계획법)","date":"2025-12-07","tags":["알고리즘"],"pointColor":"#ffffff"}},{"fields":{"slug":"/algorithm-binary-search-tree/"},"frontmatter":{"title":"알고리즘설계와분석 - Binary Search Tree (이진 탐색 트리)","date":"2025-12-05","tags":["알고리즘"],"pointColor":"#ffffff"}},{"fields":{"slug":"/database-system-erd/"},"frontmatter":{"title":"데이터베이스 시스템 개론 📚 - Chapter2. ERD로 데이터베이스 설계하기","date":"2025-10-05","tags":["DB"],"pointColor":"#ffffff"}},{"fields":{"slug":"/make-huggingface-pipeline/"},"frontmatter":{"title":"허깅페이스로 파이프라인을 만들어보자","date":"2025-10-04","tags":["AI"],"pointColor":"#FF9A00"}},{"fields":{"slug":"/rag-core-concept/"},"frontmatter":{"title":"RAG의 핵심 개념과 원리를 실습과 함께 알아봅니다.","date":"2025-10-01","tags":["AI"],"pointColor":"#FF6B6B"}},{"fields":{"slug":"/prompt-engineering-basic/"},"frontmatter":{"title":"프롬프트 엔지니어링의 기초 개념과 기법을 python 코드와 함께 알아보자","date":"2025-09-28","tags":["AI"],"pointColor":"#ffffff"}},{"fields":{"slug":"/how-to-use-flutter-riverpod/"},"frontmatter":{"title":"초심자 입장에서 Flutter Riverpod을 '잘' 사용하는 방법 (장문)","date":"2025-09-20","tags":["Flutter"],"pointColor":"#0468d7"}},{"fields":{"slug":"/database-system-introduction/"},"frontmatter":{"title":"데이터베이스 시스템 개론 📚 – Chapter 1. Introduction of Database Systems","date":"2025-09-16","tags":["DB"],"pointColor":"#ffffff"}},{"fields":{"slug":"/kakaobank-devrel-internship-retrospect/"},"frontmatter":{"title":"서비스 개발부터 DevRel까지: 카카오뱅크 인턴쉽 회고","date":"2025-07-28","tags":["인턴","회고","카카오뱅크","네이버랩스"],"pointColor":"#ffe300"}},{"fields":{"slug":"/my-it-startup-internship-retrospect/"},"frontmatter":{"title":"나의 IT 스타트업 인턴쉽 회고","date":"2025-03-14","tags":["인턴","회고"],"pointColor":"#6FE7FF"}},{"fields":{"slug":"/sogang-likelion-management-retrospect/"},"frontmatter":{"title":"서강대학교 멋쟁이사자처럼 운영진 회고","date":"2025-02-27","tags":["멋쟁이사자처럼","회고"],"pointColor":"#FD7911"}}]},"markdownRemark":{"id":"060ac6d5-55b8-5c55-bb44-a75b767370ab","excerpt":"책을 읽으면서 배운 점을 정리합니다.\n물리 계층과 데이터 링크 계층은 LAN 내부 통신을 담당하지만, 서로 다른 네트워크 간의 통신을 위해서는 네트워크 계층이 필요하다. 이 글에서는 네트워크 계층의 핵심 프로토콜인 IP의 목적과 특징, IP…","html":"<blockquote>\n<p><code class=\"language-text\">혼자 공부하는 네트워크</code> 책을 읽으면서 배운 점을 정리합니다.\n물리 계층과 데이터 링크 계층은 LAN 내부 통신을 담당하지만, 서로 다른 네트워크 간의 통신을 위해서는 네트워크 계층이 필요하다. 이 글에서는 네트워크 계층의 핵심 프로토콜인 IP의 목적과 특징, IP 주소 체계, 그리고 관련 프로토콜들을 다룬다.</p>\n</blockquote>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 1000px; background: transparent;\"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/static/6a82f58db0856ebf5c66f7a19e726122/7c474/index.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 48.800000000000004%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAKCAYAAAC0VX7mAAAACXBIWXMAACE4AAAhOAFFljFgAAABXUlEQVR42o1SyU4CQRTkpzUgi16I+xIXjBpNjDf15AEGMAoI9DQ4A7MwSIIbHjBGv6F83T1BlkE9VF73dHe9VzUVqiXyCMT8NSE/isRQnYJQ0Ecey0GfyxI06BENPKrWPJqTa3H+f8J4HkbyBs21EuydKloHHM31O1hbZTRXS3BTDOZycSrpKCHJEZM9nBp4Zz181N/wZfXR0zr4tPt4vvLQr7yge26DhTVly5+EJKl1yPGa7qB74eCJSDpnJpG1icjB46Urpxb3aguTnoaGfRt4R93ZbEb6J8DCGVRn0spPcR7Jqnt+5fHcGCF1aZA/5lIB3nEdLk3gpnQ42xVZvaO62pOnwk9R2yf3pKQmYSwWBp4OJmysFKXZ4qFNRM4ug7VRpp9RkRLlfrMMk+5ZotG+DnePwSN7jOTtJOGIZBGNKMmLZVVM5nxpfmRUjH7A47/FJijI46EOCrxP+A1aGmXLqvw9WgAAAABJRU5ErkJggg=='); background-size: cover; display: block;\"\n  ></span>\n  <picture>\n          <source\n              srcset=\"/static/6a82f58db0856ebf5c66f7a19e726122/bc904/index.webp 250w,\n/static/6a82f58db0856ebf5c66f7a19e726122/4be29/index.webp 500w,\n/static/6a82f58db0856ebf5c66f7a19e726122/03f31/index.webp 1000w,\n/static/6a82f58db0856ebf5c66f7a19e726122/84f56/index.webp 1329w\"\n              sizes=\"(max-width: 1000px) 100vw, 1000px\"\n              type=\"image/webp\"\n            />\n          <source\n            srcset=\"/static/6a82f58db0856ebf5c66f7a19e726122/43fa5/index.png 250w,\n/static/6a82f58db0856ebf5c66f7a19e726122/c6e3d/index.png 500w,\n/static/6a82f58db0856ebf5c66f7a19e726122/da8b6/index.png 1000w,\n/static/6a82f58db0856ebf5c66f7a19e726122/7c474/index.png 1329w\"\n            sizes=\"(max-width: 1000px) 100vw, 1000px\"\n            type=\"image/png\"\n          />\n          <img\n            class=\"gatsby-resp-image-image\"\n            src=\"/static/6a82f58db0856ebf5c66f7a19e726122/da8b6/index.png\"\n            alt=\"index\"\n            title=\"\"\n            loading=\"lazy\"\n            decoding=\"async\"\n            style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n          />\n        </picture>\n  </a>\n    </span></p>\n<h2 id=\"1️-ip의-목적과-특징\">1️⃣ IP의 목적과 특징</h2>\n<p><code class=\"language-text\">IP(Internet Protocol)</code>는 네트워크 계층의 가장 핵심적인 프로토콜로, 네트워크 간 통신을 가능하게 한다.</p>\n<h3 id=\"ip의-두-가지-주요-목적\">IP의 두 가지 주요 목적</h3>\n<h4 id=\"1-1-주소-지정addressing\">1-1 주소 지정(Addressing)</h4>\n<p><code class=\"language-text\">주소 지정</code>은 네트워크 간 통신 과정에서 호스트를 특정하는 것을 의미한다. IP 패킷 헤더에는 송신지 IP 주소와 수신지 IP 주소 필드가 있어 패킷의 출발지와 목적지를 명시한다.</p>\n<p>하나의 IP 주소는 총 <strong>4바이트(32비트)</strong> 로 구성되며, 점(.)으로 구분된 0~255 범위의 10진수 4개로 표기된다. 각각의 10진수를 <code class=\"language-text\">옥텟(Octet)</code>이라고 한다.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">예시: 192.168.0.1\n- 192, 168, 0, 1 각각이 하나의 옥텟\n- 각 옥텟은 8비트로 표현 가능</code></pre></div>\n<blockquote>\n<p><strong>💡 IPv4 vs IPv6</strong></p>\n<p>현재 사용되는 IP는 IPv4와 IPv6 두 가지 버전이 있다.</p>\n<ul>\n<li><strong>IPv4</strong>: 32비트, 약 43억 개의 주소 할당 가능 (2³² 개)</li>\n<li><strong>IPv6</strong>: 128비트, 사실상 무한에 가까운 주소 할당 가능 (2¹²⁸ 개)</li>\n</ul>\n<p>IPv4 주소 고갈 문제를 해결하기 위해 IPv6가 등장했으며, IPv6는 콜론(:)으로 구분된 8개 그룹의 16진수로 표기된다. (예: <code class=\"language-text\">2001:0230:abcd:ffff:0000:0000:ffff:1111</code>)</p>\n</blockquote>\n<h4 id=\"1-2-단편화fragmentation\">1-2 단편화(Fragmentation)</h4>\n<p><code class=\"language-text\">단편화</code>는 데이터를 여러 IP 패킷으로 쪼개어 보내는 것을 의미한다. 이는 <code class=\"language-text\">MTU(Maximum Transmission Unit)</code>와 관련이 있다.</p>\n<p><strong>MTU</strong>는 최대 전송 단위로, 전송하고자 하는 IP 패킷의 크기가 MTU보다 클 경우 패킷을 MTU 이하의 여러 패킷으로 쪼개서 전송한다. 일반적인 MTU 크기는 <strong>1500바이트</strong>이다.</p>\n<p>IP 패킷 헤더에서 단편화와 관련된 필드는 다음과 같다:</p>\n<table>\n<thead>\n<tr>\n<th>필드</th>\n<th>설명</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>식별자(Identifier)</td>\n<td>특정 패킷이 어떤 데이터에서 쪼개진 패킷인지 식별</td>\n</tr>\n<tr>\n<td>플래그(Flag)</td>\n<td>DF(Don't Fragment), MF(More Fragment) 비트 포함</td>\n</tr>\n<tr>\n<td>단편화 오프셋(Fragment Offset)</td>\n<td>패킷이 초기 데이터에서 얼마나 떨어져 있는지 명시</td>\n</tr>\n</tbody>\n</table>\n<blockquote>\n<p>💡 경로 MTU 발견(Path MTU Discovery)</p>\n<p>오늘날 네트워크 환경에서는 IP 단편화가 잘 발생하지 않는다. 단편화는 다음과 같은 문제를 야기하기 때문이다:</p>\n<ul>\n<li>불필요한 트래픽 증가와 대역폭 낭비</li>\n<li>재조립 과정에서 발생하는 성능 저하</li>\n</ul>\n<p><strong>경로 MTU 발견</strong>은 송수신 경로에서 처리 가능한 최대 MTU 크기를 구하여 단편화 없이 통신하는 기술이다. 현대 네트워크는 대부분 이를 지원한다.</p>\n</blockquote>\n<h3 id=\"ip의-통신-특징\">IP의 통신 특징</h3>\n<h4 id=\"1-3-신뢰할-수-없는-통신unreliable-communication\">1-3 신뢰할 수 없는 통신(Unreliable Communication)</h4>\n<p>IP는 <strong>신뢰할 수 없는 프로토콜</strong>이다. 이는 패킷이 수신지까지 제대로 전송되었다고 보장하지 않는다는 의미다. 패킷이 유실되거나 순서대로 전송되지 않더라도 이에 대한 조치를 취하지 않는다.</p>\n<p>이러한 전송 방식을 <code class=\"language-text\">최선형 전달(Best-effort Delivery)</code>이라고도 부른다.</p>\n<h4 id=\"1-4-비연결형-통신connectionless-communication\">1-4 비연결형 통신(Connectionless Communication)</h4>\n<p>IP는 <strong>비연결형 프로토콜</strong>이다. 패킷을 주고받기 전에 사전 연결 과정을 거치지 않으며, 상대 호스트의 수신 가능 여부를 고려하지 않고 수신지를 향해 패킷을 전송한다.</p>\n<blockquote>\n<p>💡 왜 신뢰할 수 없고 비연결형일까?</p>\n<p>IP가 신뢰성과 연결을 보장하지 않는 이유는 <strong>성능</strong> 때문이다. 신뢰성 높은 송수신을 위해서는 오류 제어와 연결 관리가 필요하며, 이는 더 많은 시간과 대역폭, 부하를 요구한다. IP는 빠른 전송을 우선시하며, 필요한 경우 상위 계층의 프로토콜(예: TCP)에서 신뢰성을 보장한다.</p>\n</blockquote>\n<h2 id=\"2️-ip-주소의-구조\">2️⃣ IP 주소의 구조</h2>\n<h3 id=\"ip-주소의-구성-요소\">IP 주소의 구성 요소</h3>\n<p>하나의 IP 주소는 <strong>네트워크 주소</strong>와 <strong>호스트 주소</strong>로 이루어져 있다.</p>\n<ul>\n<li><strong>네트워크 주소(Network ID)</strong>: 호스트가 속한 네트워크를 특정</li>\n<li><strong>호스트 주소(Host ID)</strong>: 네트워크에 속한 호스트를 특정</li>\n</ul>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">예시: 172.16.12.45\n\n[네트워크 주소].[호스트 주소]\n   172.16   .   12.45</code></pre></div>\n<p>중요한 점은 네트워크 주소와 호스트 주소의 크기가 <strong>유동적</strong>일 수 있다는 것이다.</p>\n<h3 id=\"클래스풀-주소-체계classful-addressing\">클래스풀 주소 체계(Classful Addressing)</h3>\n<p><code class=\"language-text\">클래스풀 주소 체계</code>는 네트워크 크기에 따라 IP 주소를 A, B, C, D, E 클래스로 분류하는 방식이다. 실질적으로 사용되는 클래스는 A, B, C이다.</p>\n<h4 id=\"2-1-a-b-c-클래스\">2-1 A, B, C 클래스</h4>\n<table>\n<thead>\n<tr>\n<th>클래스</th>\n<th>네트워크 주소</th>\n<th>호스트 주소</th>\n<th>IP 주소 범위</th>\n<th>시작 비트</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>A 클래스</td>\n<td>1옥텟 (8비트)</td>\n<td>3옥텟 (24비트)</td>\n<td>0.0.0.0 ~ 127.255.255.255</td>\n<td>0</td>\n</tr>\n<tr>\n<td>B 클래스</td>\n<td>2옥텟 (16비트)</td>\n<td>2옥텟 (16비트)</td>\n<td>128.0.0.0 ~ 191.255.255.255</td>\n<td>10</td>\n</tr>\n<tr>\n<td>C 클래스</td>\n<td>3옥텟 (24비트)</td>\n<td>1옥텟 (8비트)</td>\n<td>192.0.0.0 ~ 223.255.255.255</td>\n<td>110</td>\n</tr>\n</tbody>\n</table>\n<p>첫 옥텟의 주소만 보고도 어떤 클래스에 속하는지 알 수 있다.</p>\n<blockquote>\n<p>💡 네트워크 주소와 브로드캐스트 주소</p>\n<p>호스트 주소를 모두 사용할 수 있는 것은 아니다:</p>\n<ul>\n<li><strong>호스트 주소가 모두 0</strong>: 네트워크 자체를 지칭 (예: <code class=\"language-text\">172.16.0.0</code>)</li>\n<li><strong>호스트 주소가 모두 1</strong>: 브로드캐스트 주소 (예: <code class=\"language-text\">172.16.255.255</code>)</li>\n</ul>\n<p>또한 특수 목적으로 예약된 IP 주소도 있다:</p>\n<ul>\n<li><code class=\"language-text\">0.0.0.0 ~ 0.255.255.255</code>: 'This host on this network' 지칭</li>\n<li><code class=\"language-text\">127.0.0.0 ~ 127.255.255.255</code>: 루프백 주소 (자기 자신, <code class=\"language-text\">localhost</code>)</li>\n<li><code class=\"language-text\">10.0.0.0/8</code>, <code class=\"language-text\">172.16.0.0/12</code>, <code class=\"language-text\">192.168.0.0/16</code>: 사설 네트워크 주소</li>\n</ul>\n</blockquote>\n<h3 id=\"클래스리스-주소-체계와-서브넷-마스크\">클래스리스 주소 체계와 서브넷 마스크</h3>\n<p><code class=\"language-text\">클래스풀 주소 체계</code>는 클래스별 네트워크 크기가 고정되어 있어 IP 주소 낭비가 발생할 수 있다. 예를 들어 300명의 직원에게 IP 주소를 할당하려면 C 클래스(254개)로는 부족하고 B 클래스(6만 개 이상)를 사용해야 하는데, 이는 상당한 낭비다.</p>\n<h4 id=\"2-2-서브넷-마스크subnet-mask\">2-2 서브넷 마스크(Subnet Mask)</h4>\n<p><code class=\"language-text\">클래스리스 주소 체계</code>에서는 <code class=\"language-text\">서브넷 마스크</code>를 이용해 네트워크와 호스트를 구분한다.</p>\n<p><strong>서브넷 마스크</strong>는 IP 주소에서 네트워크 주소를 1로, 호스트 주소를 0으로 표기한 비트열이다.</p>\n<p>A, B, C 클래스의 기본 서브넷 마스크:</p>\n<ul>\n<li>A 클래스: <code class=\"language-text\">255.0.0.0</code> (11111111.00000000.00000000.00000000)</li>\n<li>B 클래스: <code class=\"language-text\">255.255.0.0</code> (11111111.11111111.00000000.00000000)</li>\n<li>C 클래스: <code class=\"language-text\">255.255.255.0</code> (11111111.11111111.11111111.00000000)</li>\n</ul>\n<h4 id=\"2-3-네트워크-주소-계산\">2-3 네트워크 주소 계산</h4>\n<p>서브넷 마스크와 IP 주소 간 <strong>비트 AND 연산</strong>을 수행하면 네트워크 주소를 알 수 있다.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">예시: 192.168.200.102 / 255.255.255.0\n\nIP 주소:      11000000.10101000.11001000.01100110\n서브넷 마스크: 11111111.11111111.11111111.00000000\n-------------------------------------------\n비트 AND:     11000000.10101000.11001000.00000000\n              = 192.168.200.0 (네트워크 주소)</code></pre></div>\n<blockquote>\n<p>💡 CIDR 표기법</p>\n<p>서브넷 마스크는 <code class=\"language-text\">IP 주소/서브넷 마스크상의 1의 개수</code> 형식으로 표기할 수 있다.</p>\n<p>예시: <code class=\"language-text\">192.168.20.3/30</code></p>\n<ul>\n<li><code class=\"language-text\">/30</code>은 서브넷 마스크에 1이 30개 있다는 의미</li>\n<li><code class=\"language-text\">11111111.11111111.11111111.11111100</code></li>\n<li>= <code class=\"language-text\">255.255.255.252</code></li>\n</ul>\n</blockquote>\n<h2 id=\"3️-공인-ip-주소와-사설-ip-주소\">3️⃣ 공인 IP 주소와 사설 IP 주소</h2>\n<h3 id=\"두-가지-종류의-ip-주소\">두 가지 종류의 IP 주소</h3>\n<p>호스트의 IP 주소를 확인하는 방법은 두 가지가 있다:</p>\n<ol>\n<li>시스템 명령어 (<code class=\"language-text\">ipconfig</code>, <code class=\"language-text\">ifconfig</code>)</li>\n<li>온라인 검색 (구글, 네이버 등)</li>\n</ol>\n<p>이 두 방식으로 확인한 IP 주소가 다를 수 있는데, 이는 <strong>공인 IP 주소</strong>와 <strong>사설 IP 주소</strong>가 함께 사용되기 때문이다.</p>\n<h4 id=\"3-1-공인-ip-주소public-ip-address\">3-1 공인 IP 주소(Public IP Address)</h4>\n<p><code class=\"language-text\">공인 IP 주소</code>는 <strong>전 세계에서 고유한</strong> IP 주소다. 인터넷을 비롯한 네트워크 간 통신에서 사용되며, ISP나 공인 IP 주소 할당 기관을 통해 할당받는다.</p>\n<p>온라인 검색으로 확인한 IP 주소가 바로 공인 IP 주소다.</p>\n<h4 id=\"3-2-사설-ip-주소private-ip-address\">3-2 사설 IP 주소(Private IP Address)</h4>\n<p><code class=\"language-text\">사설 IP 주소</code>는 <strong>사설 네트워크에서 사용하기 위한</strong> IP 주소다. 사설 네트워크는 외부 네트워크에 공개되지 않은 네트워크를 의미한다.</p>\n<p>사설 IP 주소로 예약된 범위:</p>\n<ul>\n<li><code class=\"language-text\">10.0.0.0/8</code> (10.0.0.0 ~ 10.255.255.255)</li>\n<li><code class=\"language-text\">172.16.0.0/12</code> (172.16.0.0 ~ 172.31.255.255)</li>\n<li><code class=\"language-text\">192.168.0.0/16</code> (192.168.0.0 ~ 192.168.255.255)</li>\n</ul>\n<p>사설 IP 주소는 해당 사설 네트워크 내에서만 유효하므로 <strong>다른 네트워크의 사설 IP 주소와 중복될 수 있다</strong>.</p>\n<h2 id=\"4️-ip-주소의-할당\">4️⃣ IP 주소의 할당</h2>\n<h3 id=\"정적-할당static-assignment\">정적 할당(Static Assignment)</h3>\n<p><code class=\"language-text\">정적 할당</code>은 수작업으로 IP 주소를 부여하는 방식이다. 운영체제의 네트워크 설정에서 직접 IP 주소를 입력한다.</p>\n<h4 id=\"4-1-정적-할당-시-필요한-정보\">4-1 정적 할당 시 필요한 정보</h4>\n<ul>\n<li><strong>IP 주소</strong>: 호스트에 할당할 IP 주소</li>\n<li><strong>서브넷 마스크</strong>: 네트워크 주소와 호스트 주소 구분</li>\n<li><strong>게이트웨이(Gateway)</strong>: 네트워크 외부로 나가기 위한 첫 경로 (일반적으로 라우터 주소)</li>\n<li><strong>DNS 주소</strong>: 도메인 네임을 IP 주소로 변환하기 위해 질의하는 서버 주소</li>\n</ul>\n<blockquote>\n<p>💡 기본 게이트웨이(Default Gateway)</p>\n<p><code class=\"language-text\">기본 게이트웨이</code>는 호스트가 속한 네트워크 외부로 나가기 위한 첫 기본 경로를 의미한다. 일반적으로 네트워크 외부와 연결된 라우터(공유기)의 주소를 가리킨다.</p>\n</blockquote>\n<blockquote>\n<p>💡 DNS 주소</p>\n<p>모든 호스트의 IP 주소를 기억하기 어렵기 때문에 <code class=\"language-text\">도메인 네임(Domain Name)</code>을 사용한다. DNS 주소는 도메인 네임을 IP 주소로 변환해주는 네임 서버의 주소다.</p>\n<p>공개된 DNS 서버: <code class=\"language-text\">8.8.8.8</code> (Google), <code class=\"language-text\">1.1.1.1</code> (Cloudflare)</p>\n</blockquote>\n<h3 id=\"동적-할당-dhcp\">동적 할당: DHCP</h3>\n<p><code class=\"language-text\">동적 할당</code>은 프로토콜을 통해 자동으로 IP 주소를 부여하는 방식이다.</p>\n<h4 id=\"4-2-dhcpdynamic-host-configuration-protocol\">4-2 DHCP(Dynamic Host Configuration Protocol)</h4>\n<p><code class=\"language-text\">DHCP</code>는 호스트에 IP 주소를 자동으로 할당하는 프로토콜이다. 일반적으로 라우터(공유기)가 DHCP 서버 역할을 수행한다.</p>\n<p><strong>DHCP 동적 할당의 특징:</strong></p>\n<ul>\n<li>동적 IP 주소에는 <strong>사용 가능한 기간(임대 기간)</strong> 이 정해져 있다</li>\n<li>할당받을 때마다 <strong>다른 주소를 받을 수 있다</strong></li>\n<li>사용되지 않는 IP 주소는 회수되어 재사용된다</li>\n<li>임대 기간이 끝나기 전에 <code class=\"language-text\">임대 갱신(Lease Renewal)</code>을 통해 연장 가능</li>\n</ul>\n<h4 id=\"4-3-dhcp-동작-과정\">4-3 DHCP 동작 과정</h4>\n<ol>\n<li><strong>DHCP Discover</strong>: 클라이언트가 DHCP 서버를 찾기 위해 브로드캐스트</li>\n<li><strong>DHCP Offer</strong>: DHCP 서버가 사용 가능한 IP 주소 제안</li>\n<li><strong>DHCP Request</strong>: 클라이언트가 제안받은 IP 주소 사용 요청</li>\n<li><strong>DHCP Ack</strong>: DHCP 서버가 IP 주소 할당 확인</li>\n</ol>\n<h2 id=\"5️-ip-전송-특징의-보완-icmp\">5️⃣ IP 전송 특징의 보완: ICMP</h2>\n<p>IP는 신뢰할 수 없는 비연결형 프로토콜이라는 특징을 보완하는 방법은 두 가지다:</p>\n<ol>\n<li>상위 계층의 신뢰성 있는 프로토콜 사용 (예: TCP)</li>\n<li>네트워크 계층의 ICMP 프로토콜 사용</li>\n</ol>\n<h3 id=\"icmpinternet-control-message-protocol\">ICMP(Internet Control Message Protocol)</h3>\n<p><code class=\"language-text\">ICMP</code>는 IP 패킷 전송 과정에 대한 <strong>피드백 메시지</strong>를 제공하는 프로토콜이다. ICMP 메시지를 통해 패킷이 어떻게 전송되었는지 확인할 수 있다.</p>\n<h4 id=\"5-1-icmp-메시지-유형\">5-1 ICMP 메시지 유형</h4>\n<p><strong>오류 보고 메시지:</strong></p>\n<ul>\n<li><code class=\"language-text\">Destination network unreachable</code>: 네트워크 도달 불가</li>\n<li><code class=\"language-text\">Destination host unreachable</code>: 호스트 도달 불가</li>\n<li><code class=\"language-text\">Destination port unreachable</code>: 포트 도달 불가</li>\n<li><code class=\"language-text\">Fragmentation required, and DF flag set</code>: 단편화 필요하지만 DF 플래그로 불가</li>\n<li><code class=\"language-text\">TTL expired in transit</code>: TTL 만료</li>\n</ul>\n<p><strong>네트워크 정보 제공 메시지:</strong></p>\n<ul>\n<li><code class=\"language-text\">Echo request</code>: 에코 요청</li>\n<li><code class=\"language-text\">Echo reply</code>: 에코 응답</li>\n</ul>\n<h4 id=\"5-2-ttltime-to-live\">5-2 TTL(Time To Live)</h4>\n<p>IP 헤더의 <code class=\"language-text\">TTL</code> 필드는 패킷의 수명을 의미한다. 패킷이 라우터를 거칠 때마다 TTL이 1씩 감소하며, TTL이 0이 되면 패킷은 폐기되고 <code class=\"language-text\">Time Exceeded</code> ICMP 메시지가 전송된다.</p>\n<p>패킷이 호스트 또는 라우터에 한 번 전달되는 것을 <code class=\"language-text\">홉(Hop)</code>이라고 하며, TTL은 홉마다 1씩 감소한다.</p>\n<blockquote>\n<p>💡 TTL의 존재 이유</p>\n<p>TTL은 무의미한 패킷이 네트워크상에 지속적으로 남아있는 것을 방지하기 위해 존재한다.</p>\n</blockquote>\n<h4 id=\"5-3-icmp-기반-명령어\">5-3 ICMP 기반 명령어</h4>\n<p><strong>ping</strong>: 네트워크 상태를 점검하기 위해 패킷을 송신하는 명령어</p>\n<div class=\"gatsby-highlight\" data-language=\"bash\"><pre class=\"language-bash\"><code class=\"language-bash\">$ <span class=\"token function\">ping</span> <span class=\"token parameter variable\">-c</span> <span class=\"token number\">5</span> www.google.com\nPING www.google.com <span class=\"token punctuation\">(</span><span class=\"token number\">142.250</span>.206.196<span class=\"token punctuation\">)</span> <span class=\"token number\">56</span><span class=\"token punctuation\">(</span><span class=\"token number\">84</span><span class=\"token punctuation\">)</span> bytes of data.\n<span class=\"token number\">64</span> bytes from <span class=\"token number\">142.250</span>.206.196: <span class=\"token assign-left variable\">icmp_seq</span><span class=\"token operator\">=</span><span class=\"token number\">1</span> <span class=\"token assign-left variable\">ttl</span><span class=\"token operator\">=</span><span class=\"token number\">103</span> <span class=\"token assign-left variable\">time</span><span class=\"token operator\">=</span><span class=\"token number\">34.0</span> ms\n<span class=\"token number\">64</span> bytes from <span class=\"token number\">142.250</span>.206.196: <span class=\"token assign-left variable\">icmp_seq</span><span class=\"token operator\">=</span><span class=\"token number\">2</span> <span class=\"token assign-left variable\">ttl</span><span class=\"token operator\">=</span><span class=\"token number\">103</span> <span class=\"token assign-left variable\">time</span><span class=\"token operator\">=</span><span class=\"token number\">34.1</span> ms\n<span class=\"token punctuation\">..</span>.</code></pre></div>\n<p><strong>traceroute (Windows: tracert)</strong>: 네트워크상의 경로를 확인하는 명령어</p>\n<div class=\"gatsby-highlight\" data-language=\"bash\"><pre class=\"language-bash\"><code class=\"language-bash\">$ <span class=\"token function\">traceroute</span> google.com\n<span class=\"token function\">traceroute</span> to google.com <span class=\"token punctuation\">(</span><span class=\"token number\">142.250</span>.66.110<span class=\"token punctuation\">)</span>, <span class=\"token number\">64</span> hops max\n<span class=\"token number\">1</span>  <span class=\"token number\">192.168</span>.219.1 <span class=\"token punctuation\">(</span><span class=\"token number\">192.168</span>.219.1<span class=\"token punctuation\">)</span>  <span class=\"token number\">7.140</span> ms\n<span class=\"token number\">2</span>  <span class=\"token number\">14.5</span>.161.1 <span class=\"token punctuation\">(</span><span class=\"token number\">14.5</span>.161.1<span class=\"token punctuation\">)</span>  <span class=\"token number\">5.781</span> ms\n<span class=\"token punctuation\">..</span>.</code></pre></div>\n<h2 id=\"6️-ip-주소와-mac-주소의-대응-arp\">6️⃣ IP 주소와 MAC 주소의 대응: ARP</h2>\n<h3 id=\"arp가-필요한-이유\">ARP가 필요한 이유</h3>\n<p>통신 과정에서 IP 주소와 MAC 주소를 함께 사용하지만, <strong>상대 호스트의 IP 주소는 알고 MAC 주소는 모르는 상황</strong>이 발생할 수 있다.</p>\n<p><code class=\"language-text\">ARP(Address Resolution Protocol)</code>는 동일 네트워크 내에서 IP 주소를 통해 MAC 주소를 알아내는 프로토콜이다.</p>\n<h3 id=\"arp-동작-과정\">ARP 동작 과정</h3>\n<h4 id=\"6-1-arp-요청arp-request\">6-1 ARP 요청(ARP Request)</h4>\n<p>호스트 A가 호스트 B의 MAC 주소를 알고 싶을 때, <strong>브로드캐스트 메시지</strong>로 ARP 요청을 보낸다.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">\"IP 주소 192.168.0.10을 가진 호스트의 MAC 주소가 무엇인가요?\"\n→ 네트워크 내 모든 호스트에게 전송</code></pre></div>\n<h4 id=\"6-2-arp-응답arp-reply\">6-2 ARP 응답(ARP Reply)</h4>\n<p>네트워크 내 모든 호스트가 ARP 요청을 수신하지만, 해당 IP 주소를 가진 호스트만 <strong>유니캐스트 메시지</strong>로 ARP 응답을 보낸다.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">\"제 MAC 주소는 AA:BB:CC:DD:EE:FF입니다.\"\n→ ARP 요청을 보낸 호스트에게만 전송</code></pre></div>\n<h4 id=\"6-3-arp-테이블arp-table\">6-3 ARP 테이블(ARP Table)</h4>\n<p><code class=\"language-text\">ARP 테이블</code>은 <code class=\"language-text\">&lt;IP 주소, MAC 주소></code> 쌍을 저장하는 캐시다. 매번 ARP 요청을 보내지 않도록 학습한 주소 정보를 저장한다.</p>\n<p>ARP 테이블은 명령어로 확인할 수 있다:</p>\n<div class=\"gatsby-highlight\" data-language=\"bash\"><pre class=\"language-bash\"><code class=\"language-bash\"><span class=\"token comment\"># Windows, macOS, Linux</span>\n$ arp <span class=\"token parameter variable\">-a</span>\n\n<span class=\"token comment\"># 출력 예시</span>\nInternet Address      Physical Address      Type\n<span class=\"token number\">192.168</span>.0.1          aa-bb-cc-dd-ee-ff     dynamic\n<span class=\"token number\">192.168</span>.0.10         <span class=\"token number\">11</span>-22-33-44-55-66     dynamic</code></pre></div>\n<p>ARP 테이블 항목은 일정 시간이 지나면 자동으로 삭제되며, 임의로 삭제할 수도 있다.</p>\n<h2 id=\"7️-라우팅의-이해\">7️⃣ 라우팅의 이해</h2>\n<h3 id=\"라우터와-라우팅\">라우터와 라우팅</h3>\n<p><code class=\"language-text\">라우터(Router)</code>는 서로 다른 네트워크에 속한 호스트 간 통신을 위해 IP 패킷을 전달하는 네트워크 장비다. 라우터는 <strong>IP 주소를 기반으로</strong> 패킷의 최적 경로를 결정한다.</p>\n<p><code class=\"language-text\">라우팅(Routing)</code>은 라우터가 IP 패킷을 전달할 최적의 경로를 결정하고 해당 경로로 패킷을 내보내는 과정이다.</p>\n<p>일반적으로 사용하는 <strong>공유기도 라우팅을 수행</strong>하므로 라우터의 일종이다.</p>\n<h3 id=\"라우팅-동작-원리\">라우팅 동작 원리</h3>\n<ol>\n<li>라우터가 IP 패킷을 수신한다</li>\n<li>패킷의 수신지 IP 주소를 확인한다</li>\n<li>라우팅 테이블을 참조하여 최적 경로를 결정한다</li>\n<li>해당 경로로 패킷을 전달한다</li>\n</ol>\n<p>이러한 과정을 거쳐 패킷은 여러 라우터를 거쳐 최종 목적지에 도달한다.</p>","fields":{"slug":"/network-layer-ip-protocol/"},"frontmatter":{"title":"[네트워크] 네트워크 계층과 IP 프로토콜","date":"2026-02-14","description":"네트워크 계층의 핵심 프로토콜인 IP의 동작 원리와 주소 체계, 관련 프로토콜을 정리합니다.","pointColor":"#ffffff","tags":["네트워크"],"keywords":"IP, 네트워크 계층, IP 주소, 서브넷 마스크, DHCP, ARP, ICMP, 라우팅, 클래스풀, 클래스리스","thumbnail":{"publicURL":"/static/6a82f58db0856ebf5c66f7a19e726122/index.png","childImageSharp":{"gatsbyImageData":{"layout":"fixed","placeholder":{"fallback":"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAKCAYAAAC0VX7mAAAACXBIWXMAACE4AAAhOAFFljFgAAABXUlEQVR42o1SyU4CQRTkpzUgi16I+xIXjBpNjDf15AEGMAoI9DQ4A7MwSIIbHjBGv6F83T1BlkE9VF73dHe9VzUVqiXyCMT8NSE/isRQnYJQ0Ecey0GfyxI06BENPKrWPJqTa3H+f8J4HkbyBs21EuydKloHHM31O1hbZTRXS3BTDOZycSrpKCHJEZM9nBp4Zz181N/wZfXR0zr4tPt4vvLQr7yge26DhTVly5+EJKl1yPGa7qB74eCJSDpnJpG1icjB46Urpxb3aguTnoaGfRt4R93ZbEb6J8DCGVRn0spPcR7Jqnt+5fHcGCF1aZA/5lIB3nEdLk3gpnQ42xVZvaO62pOnwk9R2yf3pKQmYSwWBp4OJmysFKXZ4qFNRM4ug7VRpp9RkRLlfrMMk+5ZotG+DnePwSN7jOTtJOGIZBGNKMmLZVVM5nxpfmRUjH7A47/FJijI46EOCrxP+A1aGmXLqvw9WgAAAABJRU5ErkJggg=="},"backgroundColor":"transparent","images":{"fallback":{"src":"/static/6a82f58db0856ebf5c66f7a19e726122/a1758/index.png","srcSet":"/static/6a82f58db0856ebf5c66f7a19e726122/a1758/index.png 1200w","sizes":"1200px"},"sources":[{"srcSet":"/static/6a82f58db0856ebf5c66f7a19e726122/afc39/index.webp 1200w","type":"image/webp","sizes":"1200px"}]},"width":1200,"height":585},"fixed":{"src":"/static/6a82f58db0856ebf5c66f7a19e726122/f3583/index.png"}}}}},"previous":{"fields":{"slug":"/physical-and-data-link-layer/"},"frontmatter":{"title":"[네트워크] 물리 계층과 데이터 링크 계층 - 이더넷과 네트워크 장비"}},"next":{"fields":{"slug":"/transport-layer-tcp-udp/"},"frontmatter":{"title":"[네트워크] 전송 계층 - TCP와 UDP"}}},"pageContext":{"id":"060ac6d5-55b8-5c55-bb44-a75b767370ab","previousPostId":"b30b7de3-f407-5d31-a639-077bfcfbd73a","nextPostId":"e2dcd532-3c81-5f24-8d01-6fa07b647c07"}},"staticQueryHashes":["736397157"],"slicesMap":{}}