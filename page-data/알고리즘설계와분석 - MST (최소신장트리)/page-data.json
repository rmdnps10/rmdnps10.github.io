{"componentChunkName":"component---src-templates-blog-post-js","path":"/알고리즘설계와분석 - MST (최소신장트리)/","result":{"data":{"site":{"siteMetadata":{"title":"메인","siteUrl":"https://rmdnps10.github.io","author":{"name":"Inyoung Chung"}}},"markdownRemark":{"id":"379638ca-6010-5943-a05f-cd0b03b9e41e","excerpt":"학부 수업 \"알고리즘설계와분석\"에서 배운 MST(Minimum Spanning Tree)의 핵심 개념과 알고리즘, 증명을 정리한다. 1️⃣ MST의 기본 개념 1-1 MST의 정의 는 가중치 그래프에서 모든 정점을 연결하면서 전체 가중치 합이 최소가 되는 트리이다. 🎯 MST…","html":"<blockquote>\n<p>학부 수업 \"알고리즘설계와분석\"에서 배운 MST(Minimum Spanning Tree)의 핵심 개념과 알고리즘, 증명을 정리한다.</p>\n</blockquote>\n<h2 id=\"1️-mst의-기본-개념\">1️⃣ MST의 기본 개념</h2>\n<h4 id=\"1-1-mst의-정의\">1-1 MST의 정의</h4>\n<p><code class=\"language-text\">Minimum Spanning Tree(MST)</code>는 가중치 그래프에서 모든 정점을 연결하면서 전체 가중치 합이 최소가 되는 트리이다.</p>\n<p>🎯 <strong>MST의 조건</strong></p>\n<ul>\n<li><strong>Spanning</strong>: 모든 정점을 포함한다</li>\n<li><strong>Tree</strong>: Cycle이 없다</li>\n<li><strong>Minimum</strong>: 간선 가중치의 합이 최소이다</li>\n</ul>\n<p>MST는 정확히 <code class=\"language-text\">|V| - 1</code>개의 간선을 가진다.</p>\n<h2 id=\"2️-mst의-핵심-성질\">2️⃣ MST의 핵심 성질</h2>\n<h4 id=\"2-1-cycle-property\">2-1 Cycle Property</h4>\n<p>MST는 cycle을 가지지 않는다. Cycle이 있다면 그 cycle 중 가장 무거운 간선을 제거하여 더 가벼운 트리를 만들 수 있으므로 MST가 아니다.</p>\n<h4 id=\"2-2-cut-property\">2-2 Cut Property</h4>\n<p><strong>Cut Property</strong>는 MST 알고리즘의 정당성을 증명하는 가장 중요한 이론이다.</p>\n<p>그래프를 두 집합 <code class=\"language-text\">S</code>와 <code class=\"language-text\">V-S</code>로 나누어 Cut을 만들 때, 이 Cut을 가로지르는 간선 중 <strong>가장 가벼운(light) 간선은 반드시 MST에 포함된다</strong>.</p>\n<blockquote>\n<p>💡 <strong>Cut Property 증명</strong></p>\n<ol>\n<li>MST는 반드시 <code class=\"language-text\">S</code>와 <code class=\"language-text\">V-S</code>를 잇는 간선을 하나 포함해야 한다.</li>\n<li>그 간선이 가장 가벼운 간선이 아니라면, 더 가벼운 간선으로 교체하여 더 낮은 가중치의 spanning tree를 만들 수 있다.</li>\n<li>이는 기존 MST 가정과 모순이므로, Cut을 건너는 최소 가중치 간선은 **Safe Edge(안전한 간선)**이다.</li>\n</ol>\n</blockquote>\n<h4 id=\"2-3-mst의-유일성\">2-3 MST의 유일성</h4>\n<ul>\n<li>가중치가 중복될 경우 여러 MST가 존재할 수 있다</li>\n<li><strong>모든 간선 가중치가 서로 다르면 MST는 유일하다</strong></li>\n</ul>\n<h2 id=\"3️-kruskal-알고리즘\">3️⃣ Kruskal 알고리즘</h2>\n<h4 id=\"3-1-핵심-아이디어\">3-1 핵심 아이디어</h4>\n<p><code class=\"language-text\">Kruskal 알고리즘</code>은 <strong>간선 중심</strong>의 접근 방식으로 MST를 구성한다.</p>\n<ul>\n<li>모든 간선을 가중치 오름차순으로 정렬한다</li>\n<li>순서대로 간선을 검사하며 cycle을 만들지 않으면 채택한다</li>\n<li>Cycle 생성 여부는 <code class=\"language-text\">Union-Find(Disjoint Set)</code> 구조로 판단한다</li>\n</ul>\n<h4 id=\"3-2-알고리즘-동작-과정\">3-2 알고리즘 동작 과정</h4>\n<p>🔥 <strong>알고리즘 절차</strong></p>\n<ol>\n<li>모든 정점을 독립된 집합으로 초기화 (<code class=\"language-text\">Make-Set</code>)</li>\n<li>간선을 가중치 기준으로 정렬</li>\n<li>각 간선 <code class=\"language-text\">(u, v)</code>에 대해:\n<ul>\n<li><code class=\"language-text\">Find(u) ≠ Find(v)</code>이면 서로 다른 컴포넌트</li>\n<li>이 간선은 <code class=\"language-text\">Safe Edge</code>이므로 MST에 추가하고 <code class=\"language-text\">Union(u, v)</code> 수행</li>\n<li><code class=\"language-text\">Find(u) = Find(v)</code>이면 같은 컴포넌트이므로 cycle 발생, 간선 버림</li>\n</ul>\n</li>\n<li>간선이 총 <code class=\"language-text\">V-1</code>개가 될 때까지 반복</li>\n</ol>\n<div class=\"gatsby-highlight\" data-language=\"python\"><pre class=\"language-python\"><code class=\"language-python\"><span class=\"token keyword\">def</span> <span class=\"token function\">kruskal</span><span class=\"token punctuation\">(</span>graph<span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span>\n    <span class=\"token comment\"># graph.edges = [(weight, u, v), ...]</span>\n    edges <span class=\"token operator\">=</span> <span class=\"token builtin\">sorted</span><span class=\"token punctuation\">(</span>graph<span class=\"token punctuation\">.</span>edges<span class=\"token punctuation\">)</span>  <span class=\"token comment\"># 가중치 기준 정렬</span>\n    parent <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span>v<span class=\"token punctuation\">:</span> v <span class=\"token keyword\">for</span> v <span class=\"token keyword\">in</span> graph<span class=\"token punctuation\">.</span>vertices<span class=\"token punctuation\">}</span>  <span class=\"token comment\"># Union-Find 초기화</span>\n    mst <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span>\n\n    <span class=\"token keyword\">for</span> weight<span class=\"token punctuation\">,</span> u<span class=\"token punctuation\">,</span> v <span class=\"token keyword\">in</span> edges<span class=\"token punctuation\">:</span>\n        <span class=\"token keyword\">if</span> find<span class=\"token punctuation\">(</span>u<span class=\"token punctuation\">,</span> parent<span class=\"token punctuation\">)</span> <span class=\"token operator\">!=</span> find<span class=\"token punctuation\">(</span>v<span class=\"token punctuation\">,</span> parent<span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span>  <span class=\"token comment\"># 다른 컴포넌트면</span>\n            mst<span class=\"token punctuation\">.</span>append<span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span>u<span class=\"token punctuation\">,</span> v<span class=\"token punctuation\">,</span> weight<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>  <span class=\"token comment\"># MST에 추가</span>\n            union<span class=\"token punctuation\">(</span>u<span class=\"token punctuation\">,</span> v<span class=\"token punctuation\">,</span> parent<span class=\"token punctuation\">)</span>  <span class=\"token comment\"># 두 컴포넌트 합치기</span>\n\n        <span class=\"token keyword\">if</span> <span class=\"token builtin\">len</span><span class=\"token punctuation\">(</span>mst<span class=\"token punctuation\">)</span> <span class=\"token operator\">==</span> <span class=\"token builtin\">len</span><span class=\"token punctuation\">(</span>graph<span class=\"token punctuation\">.</span>vertices<span class=\"token punctuation\">)</span> <span class=\"token operator\">-</span> <span class=\"token number\">1</span><span class=\"token punctuation\">:</span>  <span class=\"token comment\"># V-1개 간선 확보</span>\n            <span class=\"token keyword\">break</span>\n\n    <span class=\"token keyword\">return</span> mst</code></pre></div>\n<h4 id=\"3-3-시간-복잡도\">3-3 시간 복잡도</h4>\n<ul>\n<li>간선 정렬: <code class=\"language-text\">O(E log E) = O(E log V)</code></li>\n<li>Find/Union 연산: 거의 상수 시간 (Inverse Ackermann 함수 <code class=\"language-text\">α(V)</code>)</li>\n<li><strong>전체: O(E log V)</strong></li>\n</ul>\n<p><code class=\"language-text\">Sparse graph</code>(간선이 적은 그래프)에서 특히 효율적이다.</p>\n<h2 id=\"4️-prim-알고리즘\">4️⃣ Prim 알고리즘</h2>\n<h4 id=\"4-1-핵심-아이디어\">4-1 핵심 아이디어</h4>\n<p><code class=\"language-text\">Prim 알고리즘</code>은 <strong>정점 중심</strong>의 접근 방식으로, <code class=\"language-text\">Dijkstra 알고리즘</code>과 유사하게 동작한다.</p>\n<ul>\n<li>시작 정점 하나에서 출발한다</li>\n<li>현재 트리에 연결되는 가장 가벼운 간선을 계속 추가한다</li>\n<li>매 단계에서 Cut <code class=\"language-text\">(S, V-S)</code>를 만들고 light edge를 선택하는 구조이다</li>\n</ul>\n<h4 id=\"4-2-알고리즘-동작-과정\">4-2 알고리즘 동작 과정</h4>\n<p>🔥 <strong>초기화</strong></p>\n<ul>\n<li><code class=\"language-text\">key[v] = ∞</code> (모든 정점)</li>\n<li><code class=\"language-text\">parent[v] = NULL</code></li>\n<li>시작 정점 <code class=\"language-text\">r</code>의 <code class=\"language-text\">key[r] = 0</code></li>\n<li>모든 정점을 Min-Heap에 삽입</li>\n</ul>\n<p>🔥 <strong>반복 과정</strong></p>\n<ol>\n<li>Min-Heap에서 <code class=\"language-text\">key</code>가 가장 작은 정점 <code class=\"language-text\">u</code>를 Extract</li>\n<li><code class=\"language-text\">u</code>를 방문 처리 (<code class=\"language-text\">visited[u] = true</code>)</li>\n<li><code class=\"language-text\">u</code>의 모든 인접 정점 <code class=\"language-text\">v</code>에 대해:\n<ul>\n<li><code class=\"language-text\">visited[v] = false</code>이고 <code class=\"language-text\">weight(u,v) &lt; key[v]</code>이면</li>\n<li><code class=\"language-text\">key[v]</code>를 <code class=\"language-text\">weight(u,v)</code>로 갱신 (Decrease-Key)</li>\n<li><code class=\"language-text\">parent[v] = u</code>로 업데이트</li>\n</ul>\n</li>\n<li>모든 정점이 Heap에서 빠질 때까지 반복</li>\n</ol>\n<div class=\"gatsby-highlight\" data-language=\"python\"><pre class=\"language-python\"><code class=\"language-python\"><span class=\"token keyword\">def</span> <span class=\"token function\">prim</span><span class=\"token punctuation\">(</span>graph<span class=\"token punctuation\">,</span> start<span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span>\n    <span class=\"token keyword\">import</span> heapq\n\n    key <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span>v<span class=\"token punctuation\">:</span> <span class=\"token builtin\">float</span><span class=\"token punctuation\">(</span><span class=\"token string\">'inf'</span><span class=\"token punctuation\">)</span> <span class=\"token keyword\">for</span> v <span class=\"token keyword\">in</span> graph<span class=\"token punctuation\">.</span>vertices<span class=\"token punctuation\">}</span>\n    parent <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span>v<span class=\"token punctuation\">:</span> <span class=\"token boolean\">None</span> <span class=\"token keyword\">for</span> v <span class=\"token keyword\">in</span> graph<span class=\"token punctuation\">.</span>vertices<span class=\"token punctuation\">}</span>\n    visited <span class=\"token operator\">=</span> <span class=\"token builtin\">set</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n    key<span class=\"token punctuation\">[</span>start<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> <span class=\"token number\">0</span>\n\n    heap <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span><span class=\"token punctuation\">(</span><span class=\"token number\">0</span><span class=\"token punctuation\">,</span> start<span class=\"token punctuation\">)</span><span class=\"token punctuation\">]</span>  <span class=\"token comment\"># (key 값, 정점)</span>\n\n    <span class=\"token keyword\">while</span> heap<span class=\"token punctuation\">:</span>\n        curr_key<span class=\"token punctuation\">,</span> u <span class=\"token operator\">=</span> heapq<span class=\"token punctuation\">.</span>heappop<span class=\"token punctuation\">(</span>heap<span class=\"token punctuation\">)</span>\n\n        <span class=\"token keyword\">if</span> u <span class=\"token keyword\">in</span> visited<span class=\"token punctuation\">:</span>  <span class=\"token comment\"># 이미 처리된 정점</span>\n            <span class=\"token keyword\">continue</span>\n\n        visited<span class=\"token punctuation\">.</span>add<span class=\"token punctuation\">(</span>u<span class=\"token punctuation\">)</span>  <span class=\"token comment\"># MST에 포함 확정</span>\n\n        <span class=\"token keyword\">for</span> v<span class=\"token punctuation\">,</span> weight <span class=\"token keyword\">in</span> graph<span class=\"token punctuation\">.</span>adj<span class=\"token punctuation\">[</span>u<span class=\"token punctuation\">]</span><span class=\"token punctuation\">:</span>\n            <span class=\"token keyword\">if</span> v <span class=\"token keyword\">not</span> <span class=\"token keyword\">in</span> visited <span class=\"token keyword\">and</span> weight <span class=\"token operator\">&lt;</span> key<span class=\"token punctuation\">[</span>v<span class=\"token punctuation\">]</span><span class=\"token punctuation\">:</span>\n                key<span class=\"token punctuation\">[</span>v<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> weight\n                parent<span class=\"token punctuation\">[</span>v<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> u\n                heapq<span class=\"token punctuation\">.</span>heappush<span class=\"token punctuation\">(</span>heap<span class=\"token punctuation\">,</span> <span class=\"token punctuation\">(</span>weight<span class=\"token punctuation\">,</span> v<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n\n    <span class=\"token keyword\">return</span> parent</code></pre></div>\n<p>🎯 <strong>핵심 포인트</strong></p>\n<p><code class=\"language-text\">visited[v]</code>가 <code class=\"language-text\">true</code>가 되는 순간 <code class=\"language-text\">parent[v]</code>는 MST에서 확정된다. visited 되기 전에는 더 짧은 간선이 발견될 때마다 parent가 계속 바뀔 수 있다.</p>\n<h4 id=\"4-3-시간-복잡도\">4-3 시간 복잡도</h4>\n<ul>\n<li>Extract-Min: <code class=\"language-text\">V</code>번 → <code class=\"language-text\">O(V log V)</code></li>\n<li>Decrease-Key: <code class=\"language-text\">E</code>번 가능 → <code class=\"language-text\">O(E log V)</code></li>\n<li><strong>전체: O(E log V)</strong></li>\n</ul>\n<p>Kruskal과 동일한 등급의 효율을 가지며, <code class=\"language-text\">Dense graph</code>(간선이 많은 그래프)에서 강하다.</p>\n<blockquote>\n<p>💡 <strong>Prim 알고리즘이 MST를 만드는 이유</strong></p>\n<p>Prim은 매번 Cut <code class=\"language-text\">(S, V-S)</code>를 respect하며 light edge를 선택한다.</p>\n<p>어떤 Cut <code class=\"language-text\">(S, V-S)</code>에 대해 crossing edges 중 가장 가벼운 edge는 <code class=\"language-text\">Cut Property</code>에 의해 MST에 항상 포함되므로, Prim도 Kruskal처럼 항상 <strong>Safe Edge</strong>를 선택한다.</p>\n</blockquote>\n<h2 id=\"5️-kruskal-vs-prim\">5️⃣ Kruskal vs Prim</h2>\n<p>두 알고리즘 모두 <code class=\"language-text\">Cut Property</code> 기반으로 <code class=\"language-text\">Safe Edge</code>를 선택하여 MST를 구성한다.</p>\n<table>\n<thead>\n<tr>\n<th>알고리즘</th>\n<th>철학</th>\n<th>자료구조</th>\n<th>시간복잡도</th>\n<th>적합한 그래프</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><strong>Kruskal</strong></td>\n<td>간선 중심</td>\n<td>정렬 + Union-Find</td>\n<td>O(E log V)</td>\n<td>Sparse graph</td>\n</tr>\n<tr>\n<td><strong>Prim</strong></td>\n<td>정점 중심</td>\n<td>Min-Heap</td>\n<td>O(E log V)</td>\n<td>Dense graph</td>\n</tr>\n</tbody>\n</table>\n<h2 id=\"6️-mst-알고리즘-심화\">6️⃣ MST 알고리즘 심화</h2>\n<h4 id=\"6-1-reverse-delete-알고리즘\">6-1 Reverse-Delete 알고리즘</h4>\n<p><code class=\"language-text\">Reverse-Delete 알고리즘</code>은 Kruskal의 반대 방향 버전으로, <strong>MST를 정확히 반환한다</strong>.</p>\n<p>🔥 <strong>알고리즘 절차</strong></p>\n<ol>\n<li>간선을 가중치 내림차순으로 정렬 (가장 큰 가중치 먼저)</li>\n<li><code class=\"language-text\">T = E</code> (모든 간선을 일단 선택)</li>\n<li>정렬된 순서대로 각 간선 <code class=\"language-text\">e</code>에 대해:\n<ul>\n<li><code class=\"language-text\">T - {e}</code>가 그래프를 여전히 connected 상태로 유지하면</li>\n<li><code class=\"language-text\">T = T - {e}</code> (간선 제거)</li>\n</ul>\n</li>\n<li><code class=\"language-text\">T</code> 반환</li>\n</ol>\n<p>🔥 <strong>정당성 증명</strong></p>\n<p><strong>Step 1: 반환하는 T는 Tree이다</strong></p>\n<ul>\n<li>삭제하면 연결성이 깨지는 간선은 남긴다</li>\n<li>삭제해도 연결성이 유지되는 간선은 제거한다</li>\n<li>따라서 cycle은 모두 제거되고 연결성은 유지되므로, 결과는 <strong>Spanning Tree</strong>이다</li>\n</ul>\n<p><strong>Step 2: T는 MST이다 (Cut Property 사용)</strong></p>\n<ul>\n<li>Reverse-Delete는 가장 무거운 간선부터 제거한다</li>\n<li>간선 <code class=\"language-text\">e</code>가 남아 있다는 것은 <code class=\"language-text\">e</code>를 제거하면 그래프가 disconnected 된다는 의미</li>\n<li>즉, <code class=\"language-text\">e</code>는 어떤 Cut <code class=\"language-text\">(S, V-S)</code>를 잇는 유일한 light edge이다\n<ul>\n<li><code class=\"language-text\">e</code>보다 무거운 간선들은 이미 제거됨</li>\n<li><code class=\"language-text\">e</code>를 제거하면 연결이 끊긴다 = <code class=\"language-text\">e</code>보다 가벼운 간선 중 이 cut을 잇는 간선이 없음</li>\n</ul>\n</li>\n<li><code class=\"language-text\">Cut Property</code>에 의해 <code class=\"language-text\">e</code>는 Safe Edge이므로 MST에 포함되어야 한다</li>\n</ul>\n<h4 id=\"6-2-임의-순서-알고리즘의-문제점\">6-2 임의 순서 알고리즘의 문제점</h4>\n<p>다음 알고리즘은 <strong>MST를 항상 반환하지 않는다</strong>.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">1. T = ∅\n2. 간선들을 아무 순서로나 본다\n3. 각 간선 e에 대해:\n       if T ∪ {e}가 cycle을 만들지 않으면\n               T = T ∪ {e}\n4. return T</code></pre></div>\n<p>얼핏 보면 Kruskal과 유사하지만, <strong>간선을 가중치 순으로 정렬하지 않는다</strong>는 점이 결정적 차이다.</p>\n<p>🔥 <strong>반례</strong></p>\n<p>3개 정점 <code class=\"language-text\">x, y, z</code>와 간선:</p>\n<ul>\n<li><code class=\"language-text\">w(x,y) = 1</code></li>\n<li><code class=\"language-text\">w(y,z) = 1</code></li>\n<li><code class=\"language-text\">w(x,z) = 2</code></li>\n</ul>\n<p><strong>MST</strong>: <code class=\"language-text\">{(x,y), (y,z)}</code>, 총 가중치 = 2</p>\n<p><strong>임의 순서 알고리즘</strong>:</p>\n<ul>\n<li>만약 첫 간선이 <code class=\"language-text\">(x,z) = 2</code>이면 T에 포함됨</li>\n<li>이후 <code class=\"language-text\">(x,y)</code> 또는 <code class=\"language-text\">(y,z)</code> 중 하나만 추가</li>\n<li>결과: <code class=\"language-text\">{(x,z), (x,y)}</code> 또는 <code class=\"language-text\">{(x,z), (y,z)}</code>, 총 가중치 = 3</li>\n</ul>\n<p>따라서 이 알고리즘은 간선을 가중치 순으로 보장하지 않아 heavy edge를 먼저 넣는 경우가 발생하므로 <strong>MST를 항상 반환하지 않는다</strong>.</p>\n<h2 id=\"7️-mst-유일성-증명\">7️⃣ MST 유일성 증명</h2>\n<h4 id=\"7-1-unique-mst-조건\">7-1 Unique MST 조건</h4>\n<p><strong>정리</strong>: 모든 Cut마다 유일한 light edge가 존재하면 MST는 유일하다.</p>\n<p>🔥 <strong>증명 (모순법)</strong></p>\n<p><strong>가정</strong>: 모든 Cut마다 light edge가 unique하다.</p>\n<p><strong>반대로 가정</strong>: MST가 두 개 <code class=\"language-text\">T, T'</code>라고 가정한다.</p>\n<ol>\n<li><code class=\"language-text\">T ≠ T'</code>이므로 <code class=\"language-text\">T</code>에는 있는데 <code class=\"language-text\">T'</code>에는 없는 간선 <code class=\"language-text\">e</code>가 있다</li>\n<li><code class=\"language-text\">T</code>에서 <code class=\"language-text\">e</code>를 제거하면 <code class=\"language-text\">(S, V-S)</code>라는 Cut이 생긴다</li>\n<li><code class=\"language-text\">e</code>는 이 Cut을 가로지르는 <strong>unique light edge</strong>이다</li>\n<li><code class=\"language-text\">T'</code>에서도 <code class=\"language-text\">S-(V-S)</code>를 연결해야 하므로, crossing edge <code class=\"language-text\">e'</code>가 있어야 한다\n<ul>\n<li>하지만 <code class=\"language-text\">e'</code>는 <code class=\"language-text\">e</code>보다 반드시 무겁다 (unique light edge 조건)</li>\n</ul>\n</li>\n<li><code class=\"language-text\">T'</code>에서 <code class=\"language-text\">e'</code>를 제거하고 <code class=\"language-text\">e</code>를 넣으면 <code class=\"language-text\">T'</code>보다 더 가벼운 spanning tree가 생긴다</li>\n<li>이는 <code class=\"language-text\">T'</code>가 MST라는 가정과 모순이다</li>\n</ol>\n<p>따라서 MST는 유일하다.</p>\n<p>🎯 <strong>결론</strong></p>\n<p>모든 edge weight가 distinct이면, 각 Cut의 최소 간선이 자동으로 유일하므로 <strong>MST는 항상 유일하다</strong>.</p>\n<h4 id=\"7-2-second-best-mst\">7-2 Second Best MST</h4>\n<p><strong>MST는 unique할 수 있으나, Second Best MST는 unique할 필요가 없다.</strong></p>","fields":{"slug":"/알고리즘설계와분석 - MST (최소신장트리)/"},"frontmatter":{"title":"알고리즘설계와분석 - MST (최소신장트리)","date":"2025-12-12","description":"최소 비용으로 모든 정점을 연결하는 MST의 개념과 Kruskal, Prim 알고리즘을 정리한다.","pointColor":"#ffffff","thumbnail":{"publicURL":"/static/1e789c20ce719b6de0c7836d300a7fdc/index.png","childImageSharp":{"gatsbyImageData":{"layout":"fixed","placeholder":{"fallback":"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAKCAIAAAA7N+mxAAAACXBIWXMAAAsTAAALEwEAmpwYAAABcUlEQVR42mVR2XKDMAzk/z+uOTlLy5FpJylgAz6wwTZdQ9o+VDNgW9JKq1VABnnNP9PiEb8/orf7a93c2yGJ46qsyrK8hmGWZWmalkWR5/ntdiuKAh4hxLquQU/J+XxKkiQKr4fDSxSGVVWeTmd4kHe5XKIoStPseDyEUVjXdRInVV0D6ZwLlmXhXCilhqGHDdtBKcWFjSPnnJCOEAInFxz+ruvmeV43C1DAGIMk/K21etYWLmtRdOdmjBNCIuR+DHc5TWgUoOQ4jj7sHPrjjsJaa3SWUnR0+Gg44xNoWo+CGZxNL6WaA7yQjRLoAzBgYLEhpXOr57LYe9uTQSwGvBalDR0EZcrTxoc8AJRWhFLmWQj/VD7s/GgWqXwyTde3dBTadD1nUj/BGA8yAKBRGaNyDuIQCSogCudXSzZ1/8ZGIUSDXfRdrV1nPOHELPA8o8ti3cq40FoxxhBCD7+q9cfwxqIg2I75b1zIcVvk76q+AUeZOe27B3sLAAAAAElFTkSuQmCC"},"backgroundColor":"transparent","images":{"fallback":{"src":"/static/1e789c20ce719b6de0c7836d300a7fdc/510b7/index.png","srcSet":"/static/1e789c20ce719b6de0c7836d300a7fdc/510b7/index.png 873w","sizes":"873px"},"sources":[{"srcSet":"/static/1e789c20ce719b6de0c7836d300a7fdc/1ec67/index.webp 873w","type":"image/webp","sizes":"873px"}]},"width":1200,"height":620},"fixed":{"src":"/static/1e789c20ce719b6de0c7836d300a7fdc/ec308/index.png"}}}}},"previous":{"fields":{"slug":"/알고리즘설계와분석 - Greedy algorithm (그리디 알고리즘)/"},"frontmatter":{"title":"알고리즘설계와분석 - Greedy algorithm (그리디 알고리즘)"}},"next":{"fields":{"slug":"/알고리즘설계와분석 - 최단경로/"},"frontmatter":{"title":"알고리즘설계와분석 - 최단경로 (Shortest Path)"}}},"pageContext":{"id":"379638ca-6010-5943-a05f-cd0b03b9e41e","previousPostId":"9f0a213a-1795-5f0a-bba8-6a25051310eb","nextPostId":"862d5cce-cb2f-5732-8349-674ab52ba6ce"}},"staticQueryHashes":["736397157"],"slicesMap":{}}