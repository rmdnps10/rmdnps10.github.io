{"componentChunkName":"component---src-templates-blog-post-js","path":"/transport-layer-tcp-udp/","result":{"data":{"site":{"siteMetadata":{"title":"홈","siteUrl":"https://inyoung.dev","author":{"name":"Inyoung Chung"}}},"allMarkdownRemark":{"nodes":[{"fields":{"slug":"/boj-1106-hotel/"},"frontmatter":{"title":"[백준 JAVA] 호텔 1106 머릿속에 박아넣기","date":"2026-02-20","tags":["알고리즘"],"pointColor":"#ffffff"}},{"fields":{"slug":"/http-advanced-features/"},"frontmatter":{"title":"[네트워크] HTTP의 응용 - 쿠키, 캐시, 보안","date":"2026-02-17","tags":["네트워크"],"pointColor":"#ffffff"}},{"fields":{"slug":"/http-fundamentals/"},"frontmatter":{"title":"[네트워크] HTTP의 기초 - DNS와 HTTP Message, Method, Status (스압 주의) ","date":"2026-02-16","tags":["네트워크"],"pointColor":"#ffffff"}},{"fields":{"slug":"/transport-layer-tcp-udp/"},"frontmatter":{"title":"[네트워크] 전송 계층 - TCP와 UDP","date":"2026-02-15","tags":["네트워크"],"pointColor":"#ffffff"}},{"fields":{"slug":"/network-layer-ip-protocol/"},"frontmatter":{"title":"[네트워크] 네트워크 계층과 IP 프로토콜","date":"2026-02-14","tags":["네트워크"],"pointColor":"#ffffff"}},{"fields":{"slug":"/physical-and-data-link-layer/"},"frontmatter":{"title":"[네트워크] 물리 계층과 데이터 링크 계층 - 이더넷과 네트워크 장비","date":"2026-02-13","tags":["네트워크"],"pointColor":"#ffffff"}},{"fields":{"slug":"/network-big-picture/"},"frontmatter":{"title":"[네트워크] 네트워크의 큰 그림","date":"2026-02-12","tags":["네트워크"],"pointColor":"#ffffff"}},{"fields":{"slug":"/troubleshooting-supabase-auth/"},"frontmatter":{"title":"[트러블슈팅] Supabase Auth를 활용한 다양한 환경에서의 세션 유지","date":"2026-02-10","tags":["Web","회고"],"pointColor":"#3ECF8D"}},{"fields":{"slug":"/waterfall-agile/"},"frontmatter":{"title":"[소프트웨어공학] Waterfall과 Agile","date":"2026-02-03","tags":["소프트웨어공학"],"pointColor":"#ffffff"}},{"fields":{"slug":"/os-file-system/"},"frontmatter":{"title":"[운영체제] 파일 시스템","date":"2026-01-27","tags":["운영체제"],"pointColor":"#ffffff"}},{"fields":{"slug":"/os-virtual-memory/"},"frontmatter":{"title":"[운영체제] 5. 가상 메모리","date":"2026-01-26","tags":["운영체제"],"pointColor":"#ffffff"}},{"fields":{"slug":"/os-cpu-scheduling/"},"frontmatter":{"title":"[운영체제] 4. CPU 스케줄링","date":"2026-01-25","tags":["운영체제"],"pointColor":"#ffffff"}},{"fields":{"slug":"/os-synchronization-deadlock/"},"frontmatter":{"title":"[운영체제] 3. 동기화와 교착 상태","date":"2026-01-24","tags":["운영체제"],"pointColor":"#ffffff"}},{"fields":{"slug":"/os-process-thread/"},"frontmatter":{"title":"[운영체제] 2. 프로세스와 스레드","date":"2026-01-23","tags":["운영체제"],"pointColor":"#ffffff"}},{"fields":{"slug":"/os-big-picture/"},"frontmatter":{"title":"[운영체제] 1. 운영체제의 큰 그림","date":"2026-01-21","tags":["운영체제"],"pointColor":"#ffffff"}},{"fields":{"slug":"/computer-architecture-cpu/"},"frontmatter":{"title":"[컴퓨터구조] 3. CPU","date":"2026-01-18","tags":["컴퓨터구조"],"pointColor":"#ffffff"}},{"fields":{"slug":"/computer-architecture-computer-information/"},"frontmatter":{"title":"[컴퓨터구조] 2. 컴퓨터가 이해하는 정보","date":"2026-01-17","tags":["컴퓨터구조"],"pointColor":"#ffffff"}},{"fields":{"slug":"/computer-architecture-big-picture/"},"frontmatter":{"title":"[컴퓨터구조] 1. 컴퓨터구조의 큰 그림","date":"2026-01-15","tags":["컴퓨터구조"],"pointColor":"#ffffff"}},{"fields":{"slug":"/java-coding-test-grammer/"},"frontmatter":{"title":"Java 코딩테스트 문법 최종 정리","date":"2026-01-08","tags":["알고리즘"],"pointColor":"#ed8b00"}},{"fields":{"slug":"/lg-webos-tv-fullstack-appliaction/"},"frontmatter":{"title":"WebOS TV에 들어갈 풀스택 애플리케이션을 만들어보자 (LG전자 산학 프로젝트 후기)","date":"2025-12-22","tags":["회고"],"pointColor":"#ffffff"}},{"fields":{"slug":"/algorithm-maximum-flow/"},"frontmatter":{"title":"알고리즘설계와분석 - 최대 유량 문제 (Maximum Flow)","date":"2025-12-16","tags":["알고리즘"],"pointColor":"#ffffff"}},{"fields":{"slug":"/algorithm-shortest-path/"},"frontmatter":{"title":"알고리즘설계와분석 - 최단경로 (Shortest Path)","date":"2025-12-13","tags":["알고리즘"],"pointColor":"#ffffff"}},{"fields":{"slug":"/algorithm-minimum-spanning-tree/"},"frontmatter":{"title":"알고리즘설계와분석 - MST (최소신장트리)","date":"2025-12-12","tags":["알고리즘"],"pointColor":"#ffffff"}},{"fields":{"slug":"/algorithm-bfs-dfs/"},"frontmatter":{"title":"BFS/DFS와 Topological Sort","date":"2025-12-11","tags":["알고리즘"],"pointColor":"#ffffff"}},{"fields":{"slug":"/algorithm-greedy-algorithm/"},"frontmatter":{"title":"알고리즘설계와분석 - Greedy algorithm (그리디 알고리즘)","date":"2025-12-10","tags":["알고리즘"],"pointColor":"#ffffff"}},{"fields":{"slug":"/algorithm-dynamic-programming/"},"frontmatter":{"title":"알고리즘설계와분석 - Dynamic Programming (동적 계획법)","date":"2025-12-07","tags":["알고리즘"],"pointColor":"#ffffff"}},{"fields":{"slug":"/algorithm-binary-search-tree/"},"frontmatter":{"title":"알고리즘설계와분석 - Binary Search Tree (이진 탐색 트리)","date":"2025-12-05","tags":["알고리즘"],"pointColor":"#ffffff"}},{"fields":{"slug":"/database-system-erd/"},"frontmatter":{"title":"데이터베이스 시스템 개론 📚 - Chapter2. ERD로 데이터베이스 설계하기","date":"2025-10-05","tags":["DB"],"pointColor":"#ffffff"}},{"fields":{"slug":"/make-huggingface-pipeline/"},"frontmatter":{"title":"허깅페이스로 파이프라인을 만들어보자","date":"2025-10-04","tags":["AI"],"pointColor":"#FF9A00"}},{"fields":{"slug":"/rag-core-concept/"},"frontmatter":{"title":"RAG의 핵심 개념과 원리를 실습과 함께 알아봅니다.","date":"2025-10-01","tags":["AI"],"pointColor":"#FF6B6B"}},{"fields":{"slug":"/prompt-engineering-basic/"},"frontmatter":{"title":"프롬프트 엔지니어링 기초 - AI와 효과적으로 소통하는 방법","date":"2025-09-28","tags":["AI"],"pointColor":"#ffffff"}},{"fields":{"slug":"/how-to-use-flutter-riverpod/"},"frontmatter":{"title":"초심자 입장에서 Flutter Riverpod을 '잘' 사용하는 방법 (장문)","date":"2025-09-20","tags":["Flutter"],"pointColor":"#0468d7"}},{"fields":{"slug":"/database-system-introduction/"},"frontmatter":{"title":"데이터베이스 시스템 개론 📚 – Chapter 1. Introduction of Database Systems","date":"2025-09-16","tags":["DB"],"pointColor":"#ffffff"}},{"fields":{"slug":"/kakaobank-devrel-internship-retrospect/"},"frontmatter":{"title":"서비스 개발부터 DevRel까지: 카카오뱅크 인턴쉽 회고","date":"2025-07-28","tags":["인턴","회고","카카오뱅크","네이버랩스"],"pointColor":"#ffe300"}},{"fields":{"slug":"/my-it-startup-internship-retrospect/"},"frontmatter":{"title":"나의 IT 스타트업 인턴쉽 회고","date":"2025-03-14","tags":["인턴","회고"],"pointColor":"#6FE7FF"}},{"fields":{"slug":"/sogang-likelion-management-retrospect/"},"frontmatter":{"title":"서강대학교 멋쟁이사자처럼 운영진 회고","date":"2025-02-27","tags":["멋쟁이사자처럼","회고"],"pointColor":"#FD7911"}}]},"markdownRemark":{"id":"e2dcd532-3c81-5f24-8d01-6fa07b647c07","excerpt":"책을 읽으면서 배운 점을 정리합니다. 네트워크 계층에서 IP가 핵심이었다면, 전송 계층에서는 TCP와 UDP…","html":"<blockquote>\n<p><code class=\"language-text\">혼자 공부하는 네트워크</code> 책을 읽으면서 배운 점을 정리합니다.</p>\n<p>네트워크 계층에서 IP가 핵심이었다면, 전송 계층에서는 TCP와 UDP가 핵심이다. 이 두 프로토콜은 각각 <code class=\"language-text\">신뢰성</code>과 <code class=\"language-text\">속도</code>라는 서로 다른 목적을 가지고 있으며, 패킷의 최종 목적지인 프로세스까지 데이터를 전달하는 역할을 한다. 이 글에서는 <code class=\"language-text\">TCP</code>와 <code class=\"language-text\">UDP</code>의 동작 원리와 차이점, 그리고 <code class=\"language-text\">TCP</code>의 연결 관리와 제어 메커니즘을 다룬다.</p>\n</blockquote>\n<p><figure class=\"gatsby-resp-image-figure\" style=\"background: transparent;\">\n    <span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 1000px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/static/05bcda411ff011ba9334113ad4b0817b/7c474/index.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 48.800000000000004%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAKCAYAAAC0VX7mAAAACXBIWXMAACE4AAAhOAFFljFgAAABVUlEQVR42o2S20sCQRTG/astWysI6qGLSje6QA+9FBI99JDuKgWuujOauTeT0kgSIgP/hq8zZ3EJm40eDnPmnJ1vzvfbSbVWKtDGanUuftSTzlCkdEWZtSCWTIhMGc5iOc6lYXKu+v8XXLbQ2biHm7cRHAr0zx7gFRoI9h24ORu9kxa6W7VE0dS8TTXJ8/kjJnKMr/YY02CCd/MF0/ATbzd9fNgjDIs+T66zPydYgSBb4ZHEiA4PLjwMr3ye8vU6xOCS9sWA+oKtx1x1gmyB7MoscaLbnXQJzkKJ8hKza6ZvI560Fxkz+k7xNKzfgpKEups1dNbv8HTaQkjsvEKdrYcHDtprVeLpwN9rMkuPWLr5OnrHEgH19YLbNf4Z/m6DBd0dOz7QJlYu9dVPUXUvV+dVXaBWvWUaXbJliy3Ono7KZ0i4bkQ2VQgjwXLy465owf/1sL8BxztlBeXl47IAAAAASUVORK5CYII='); background-size: cover; display: block;\"\n  ></span>\n  <picture>\n          <source\n              srcset=\"/static/05bcda411ff011ba9334113ad4b0817b/bc904/index.webp 250w,\n/static/05bcda411ff011ba9334113ad4b0817b/4be29/index.webp 500w,\n/static/05bcda411ff011ba9334113ad4b0817b/03f31/index.webp 1000w,\n/static/05bcda411ff011ba9334113ad4b0817b/84f56/index.webp 1329w\"\n              sizes=\"(max-width: 1000px) 100vw, 1000px\"\n              type=\"image/webp\"\n            />\n          <source\n            srcset=\"/static/05bcda411ff011ba9334113ad4b0817b/43fa5/index.png 250w,\n/static/05bcda411ff011ba9334113ad4b0817b/c6e3d/index.png 500w,\n/static/05bcda411ff011ba9334113ad4b0817b/da8b6/index.png 1000w,\n/static/05bcda411ff011ba9334113ad4b0817b/7c474/index.png 1329w\"\n            sizes=\"(max-width: 1000px) 100vw, 1000px\"\n            type=\"image/png\"\n          />\n          <img\n            class=\"gatsby-resp-image-image\"\n            src=\"/static/05bcda411ff011ba9334113ad4b0817b/da8b6/index.png\"\n            alt=\"4. 전송 계층 TCP와 UDP\"\n            title=\"\"\n            loading=\"lazy\"\n            decoding=\"async\"\n            style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n          />\n        </picture>\n  </a>\n    </span>\n    <figcaption class=\"gatsby-resp-image-figcaption\">4. 전송 계층 TCP와 UDP</figcaption>\n  </figure></p>\n<h2 id=\"1️-전송-계층의-역할\">1️⃣ 전송 계층의 역할</h2>\n<h3 id=\"포트를-통한-프로세스-식별\">포트를 통한 프로세스 식별</h3>\n<h4 id=\"1-1-포트-번호의-필요성\">1-1 포트 번호의 필요성</h4>\n<p><code class=\"language-text\">IP 주소</code>와 <code class=\"language-text\">MAC 주소</code>는 패킷을 송수신하는 호스트를 특정할 수 있다. 그러나 패킷의 최종 송수신 대상은 호스트가 아니라 <strong>호스트가 실행하는 프로세스</strong>이다. 하나의 호스트는 웹 브라우저, 게임, 채팅 프로그램 등 다양한 프로세스를 동시에 실행할 수 있으며, 네트워크를 통해 주고받는 패킷은 최종적으로 이러한 프로세스에 전달되어야 한다.</p>\n<p>네트워크 패킷을 주고받는 프로세스에는 <code class=\"language-text\">포트(Port)</code> 번호가 할당된다. <strong>IP 주소와 포트 번호의 조합</strong>을 통해 특정 호스트가 실행하는 특정 프로세스를 식별할 수 있다.</p>\n<p><figure class=\"gatsby-resp-image-figure\" style=\"background: transparent;\">\n    <span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 1000px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/static/dd2c5d6ef9dba2154040b1c56e229be3/da8b6/network-host-id.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 25.6%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAFCAIAAADKYVtkAAAACXBIWXMAAAsTAAALEwEAmpwYAAAA7klEQVR42jWPyYqDYBCEff/X8OBJb15cQHCJ4pYouIS4IYI4riFoIC5TM5KGH7qa+r+uJvZ937bt+Xy+Xq+qqniel2VZVVVFUeI4XpZlHMd5nuE5jiPPc03TTNOEE5LAa9s2DMNhGJqmqesaDsMwfr41TZPv+/h//BdY9/sdDbYSSZJ4nue67vV6jaKoKAosfDweQRCAeLvdAMIqXdcBdRzncrlAWpaVZRnR970kSSRJMgwDjRSiKFIUhQm4aZqCxXEcWF3XwQAcy7KYw/kXGx1N0zjyzAYHQIIg4OB1XTEpy/L9fn8+nzO2bdvnCb9ecASwxdTuIwAAAABJRU5ErkJggg=='); background-size: cover; display: block;\"\n  ></span>\n  <picture>\n          <source\n              srcset=\"/static/dd2c5d6ef9dba2154040b1c56e229be3/bc904/network-host-id.webp 250w,\n/static/dd2c5d6ef9dba2154040b1c56e229be3/4be29/network-host-id.webp 500w,\n/static/dd2c5d6ef9dba2154040b1c56e229be3/03f31/network-host-id.webp 1000w\"\n              sizes=\"(max-width: 1000px) 100vw, 1000px\"\n              type=\"image/webp\"\n            />\n          <source\n            srcset=\"/static/dd2c5d6ef9dba2154040b1c56e229be3/43fa5/network-host-id.png 250w,\n/static/dd2c5d6ef9dba2154040b1c56e229be3/c6e3d/network-host-id.png 500w,\n/static/dd2c5d6ef9dba2154040b1c56e229be3/da8b6/network-host-id.png 1000w\"\n            sizes=\"(max-width: 1000px) 100vw, 1000px\"\n            type=\"image/png\"\n          />\n          <img\n            class=\"gatsby-resp-image-image\"\n            src=\"/static/dd2c5d6ef9dba2154040b1c56e229be3/da8b6/network-host-id.png\"\n            alt=\"IP 주소(network id)와 포트 번호(host id)\"\n            title=\"\"\n            loading=\"lazy\"\n            decoding=\"async\"\n            style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n          />\n        </picture>\n  </a>\n    </span>\n    <figcaption class=\"gatsby-resp-image-figcaption\">IP 주소(network id)와 포트 번호(host id)</figcaption>\n  </figure></p>\n<h4 id=\"1-2-포트-번호의-구조\">1-2 포트 번호의 구조</h4>\n<p>TCP와 UDP 헤더는 모두 <code class=\"language-text\">송신지 포트 번호</code>와 <code class=\"language-text\">수신지 포트 번호</code> 필드를 포함한다. 포트 번호는 <strong>16비트</strong>로 표현되어 총 65536개(0~65535번)를 사용할 수 있으며, 번호 범위에 따라 3가지 종류로 구분된다.</p>\n<table>\n<thead>\n<tr>\n<th>포트 종류</th>\n<th>포트 번호 범위</th>\n<th>설명</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>잘 알려진 포트 (Well-known Port)</td>\n<td>0~1023</td>\n<td>범용적으로 사용되는 프로토콜을 위한 포트</td>\n</tr>\n<tr>\n<td>등록된 포트 (Registered Port)</td>\n<td>1024~49151</td>\n<td>특정 애플리케이션 프로토콜을 위한 포트</td>\n</tr>\n<tr>\n<td>동적 포트 (Dynamic Port)</td>\n<td>49152~65535</td>\n<td>임시 포트, 클라이언트가 주로 사용</td>\n</tr>\n</tbody>\n</table>\n<h5>잘 알려진 포트 예시</h5>\n<table>\n<thead>\n<tr>\n<th>포트 번호</th>\n<th>프로토콜</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>20, 21</td>\n<td>FTP</td>\n</tr>\n<tr>\n<td>22</td>\n<td>SSH</td>\n</tr>\n<tr>\n<td>23</td>\n<td>TELNET</td>\n</tr>\n<tr>\n<td>53</td>\n<td>DNS</td>\n</tr>\n<tr>\n<td>67, 68</td>\n<td>DHCP</td>\n</tr>\n<tr>\n<td>80</td>\n<td>HTTP</td>\n</tr>\n<tr>\n<td>443</td>\n<td>HTTPS</td>\n</tr>\n</tbody>\n</table>\n<h5>등록된 포트 예시</h5>\n<table>\n<thead>\n<tr>\n<th>포트 번호</th>\n<th>서비스</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>1194</td>\n<td>OpenVPN</td>\n</tr>\n<tr>\n<td>1433</td>\n<td>Microsoft SQL Server</td>\n</tr>\n<tr>\n<td>3306</td>\n<td>MySQL</td>\n</tr>\n<tr>\n<td>6379</td>\n<td>Redis</td>\n</tr>\n<tr>\n<td>8080</td>\n<td>HTTP 대체</td>\n</tr>\n</tbody>\n</table>\n<h4 id=\"1-3-포트의-실사용-사례\">1-3 포트의 실사용 사례</h4>\n<p>서버로 동작하는 프로그램은 주로 <strong>잘 알려진 포트</strong>나 <strong>등록된 포트</strong>를 사용한다. MySQL 데이터베이스 서버는 3306번 포트를, 웹 서버는 80번(HTTP) 또는 443번(HTTPS) 포트를 사용한다.</p>\n<div class=\"gatsby-highlight\" data-language=\"apache\"><pre class=\"language-apache\"><code class=\"language-apache\"># Apache HTTP 서버 설정 예시\nListen 80\n\n&lt;IfModule ssl_module&gt;\n    Listen 443\n&lt;/IfModule&gt;</code></pre></div>\n<p>클라이언트로 동작하는 프로그램은 <strong>동적 포트</strong> 범위 내에서 임의의 포트 번호를 자동으로 할당받는다. 웹 브라우저로 웹사이트에 접속할 때 브라우저는 동적 포트를 할당받아 서버의 80번 또는 443번 포트와 통신한다.</p>\n<blockquote>\n<p>💡 <strong>NAT와 NAPT</strong></p>\n<p><code class=\"language-text\">NAT(Network Address Translation)</code>는 공인 IP 주소와 사설 IP 주소 간 변환을 위한 기술이다. 사설 네트워크 내의 호스트가 외부와 통신하기 위해서는 공인 IP 주소로 변환이 필요하다.</p>\n<p><code class=\"language-text\">NAPT(Network Address Port Translation)</code>는 <strong>포트 번호까지 함께 변환</strong>하는 NAT의 일종이다. 여러 사설 IP 주소가 하나의 공인 IP 주소를 공유할 수 있도록 하여, 공인 IP 주소 부족 문제를 개선하는 기술로 활용된다.</p>\n<ul>\n<li><code class=\"language-text\">사설 IP:포트</code> ↔ <code class=\"language-text\">공인 IP:포트</code></li>\n<li>N개의 사설 IP를 1개의 공인 IP로 관리 가능</li>\n</ul>\n</blockquote>\n<h2 id=\"2️-tcp와-udp의-특징\">2️⃣ TCP와 UDP의 특징</h2>\n<h3 id=\"신뢰성과-연결-방식\">신뢰성과 연결 방식</h3>\n<h4 id=\"2-1-tcp와-udp의-기본-특성\">2-1 TCP와 UDP의 기본 특성</h4>\n<p>TCP와 UDP는 전송 계층의 대표적인 프로토콜이지만 서로 다른 특성을 가진다.</p>\n<table>\n<thead>\n<tr>\n<th>특성</th>\n<th>TCP</th>\n<th>UDP</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>신뢰성</td>\n<td>신뢰할 수 있는 통신</td>\n<td>신뢰할 수 없는 통신</td>\n</tr>\n<tr>\n<td>연결 방식</td>\n<td>연결형(Connection-oriented)</td>\n<td>비연결형(Connectionless)</td>\n</tr>\n<tr>\n<td>속도</td>\n<td>상대적으로 느림</td>\n<td>상대적으로 빠름</td>\n</tr>\n<tr>\n<td>제어 기능</td>\n<td>흐름·오류·혼잡 제어 제공</td>\n<td>제어 기능 미제공</td>\n</tr>\n<tr>\n<td>연결 과정</td>\n<td>수립 및 종료 단계 존재</td>\n<td>수립 및 종료 단계 없음</td>\n</tr>\n</tbody>\n</table>\n<p><strong>TCP</strong>는 패킷을 주고받기 전에 연결 수립 과정을 거치며, 연결 수립 이후 신뢰성 보장을 위해 상태 관리, 흐름 제어, 오류 제어, 혼잡 제어 등의 기능을 제공한다. 패킷 송수신이 완료되면 연결을 종료한다.</p>\n<p><strong>UDP</strong>는 연결 수립이나 종료 단계를 거치지 않으며, 신뢰성을 높이기 위한 기능도 제공하지 않는다. 따라서 패킷 유실 없는 송수신이 필요하면 TCP를, 빠른 송수신이 필요하면 UDP를 선택하는 것이 유리하다.</p>\n<h4 id=\"2-2-udp-헤더-구조\">2-2 UDP 헤더 구조</h4>\n<p>UDP 헤더는 단순한 구조를 가진다.</p>\n<table>\n<thead>\n<tr>\n<th>필드</th>\n<th>크기</th>\n<th>설명</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>송신지 포트</td>\n<td>16비트</td>\n<td>송신 프로세스의 포트 번호</td>\n</tr>\n<tr>\n<td>수신지 포트</td>\n<td>16비트</td>\n<td>수신 프로세스의 포트 번호</td>\n</tr>\n<tr>\n<td>길이</td>\n<td>16비트</td>\n<td>UDP 데이터그램의 바이트 크기</td>\n</tr>\n<tr>\n<td>체크섬</td>\n<td>16비트</td>\n<td>데이터그램 훼손 여부 확인 정보</td>\n</tr>\n</tbody>\n</table>\n<p>UDP 헤더는 사실상 IP 헤더를 감싸는 일종의 껍데기와 같다. 최소한의 정보만 제공하여 오버헤드가 작고 빠른 전송이 가능하다.</p>\n<h4 id=\"2-3-tcp-헤더-구조\">2-3 TCP 헤더 구조</h4>\n<p>TCP 헤더는 UDP보다 훨씬 많은 필드를 포함한다. 연결 수립과 종료, 신뢰성 보장을 위한 다양한 기능을 제공하기 때문이다.</p>\n<h5>주요 필드</h5>\n<p><strong>순서 번호 (Sequence Number)</strong></p>\n<ul>\n<li>TCP 세그먼트의 올바른 송수신 순서를 보장하기 위해 세그먼트 첫 바이트에 매겨진 번호</li>\n<li>현재 주고받는 세그먼트가 데이터의 몇 번째 바이트에 해당하는지 식별</li>\n</ul>\n<p><strong>확인 응답 번호 (Acknowledgment Number)</strong></p>\n<ul>\n<li>상대 호스트가 보낸 세그먼트에 대한 응답</li>\n<li>다음으로 수신하길 기대하는 순서 번호</li>\n<li>일반적으로 <strong>올바르게 수신한 순서 번호 + 1</strong>로 설정</li>\n</ul>\n<blockquote>\n<p>💡 <strong>순서 번호와 확인 응답 번호의 관계</strong></p>\n<div class=\"gatsby-highlight\" data-language=\"java\"><pre class=\"language-java\"><code class=\"language-java\"><span class=\"token comment\">// 호스트 A가 순서 번호 100인 세그먼트 전송</span>\nsegment<span class=\"token punctuation\">.</span>sequenceNumber <span class=\"token operator\">=</span> <span class=\"token number\">100</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token comment\">// 호스트 B가 올바르게 수신 후 응답</span>\nresponseSegment<span class=\"token punctuation\">.</span>acknowledgmentNumber <span class=\"token operator\">=</span> <span class=\"token number\">101</span><span class=\"token punctuation\">;</span>  <span class=\"token comment\">// 다음 받을 번호</span>\nresponseSegment<span class=\"token punctuation\">.</span><span class=\"token function\">setACKFlag</span><span class=\"token punctuation\">(</span><span class=\"token boolean\">true</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>  <span class=\"token comment\">// ACK 플래그 설정</span></code></pre></div>\n<p>TCP의 신뢰성 보장은 대부분 확인 응답 번호를 통해 이루어진다.</p>\n</blockquote>\n<p><strong>제어 비트 (Control Bits)</strong></p>\n<ul>\n<li>현재 세그먼트에 대한 부가 정보를 나타내는 플래그</li>\n<li>8비트로 구성되며 각 비트가 서로 다른 의미를 가짐</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th>제어 비트</th>\n<th>설명</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>ACK</td>\n<td>세그먼트의 승인을 나타냄</td>\n</tr>\n<tr>\n<td>SYN</td>\n<td>연결을 수립하기 위해 사용</td>\n</tr>\n<tr>\n<td>FIN</td>\n<td>연결을 종료하기 위해 사용</td>\n</tr>\n</tbody>\n</table>\n<h2 id=\"3️-tcp의-연결-관리\">3️⃣ TCP의 연결 관리</h2>\n<h3 id=\"tcp-연결-수립-3-way-handshake\">TCP 연결 수립: 3-way-handshake</h3>\n<h4 id=\"3-1-연결-과정-설명\">3-1 연결 과정 설명</h4>\n<p>TCP의 연결 수립은 <code class=\"language-text\">쓰리 웨이 핸드셰이크(3-way Handshake)</code>를 통해 이루어진다. 이는 세 단계로 이루어진 TCP 연결 수립 과정을 의미한다.</p>\n<p><strong>1단계: SYN 세그먼트 전송 (A → B)</strong></p>\n<ul>\n<li>호스트 A가 <code class=\"language-text\">SYN</code> 비트를 1로 설정한 세그먼트를 호스트 B에게 전송</li>\n<li>세그먼트의 순서 번호에 호스트 A의 순서 번호 포함</li>\n</ul>\n<p><strong>2단계: SYN+ACK 세그먼트 전송 (B → A)</strong></p>\n<ul>\n<li>호스트 B가 <code class=\"language-text\">SYN</code>과 <code class=\"language-text\">ACK</code> 비트를 모두 1로 설정한 세그먼트를 전송</li>\n<li>호스트 B의 순서 번호와 1단계 세그먼트에 대한 확인 응답 번호 포함</li>\n</ul>\n<p><strong>3단계: ACK 세그먼트 전송 (A → B)</strong></p>\n<ul>\n<li>호스트 A가 <code class=\"language-text\">ACK</code> 비트를 1로 설정한 세그먼트를 전송</li>\n<li>호스트 A의 순서 번호와 2단계 세그먼트에 대한 확인 응답 번호 포함</li>\n</ul>\n<p><figure class=\"gatsby-resp-image-figure\" style=\"background: transparent;\">\n    <span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 471px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/static/942c4ea62dae1b7884b63eec588b1892/9fd7e/tcp.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 99.2%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAUCAIAAAAC64paAAAACXBIWXMAAAsTAAALEwEAmpwYAAACOUlEQVR42qVU2W6jQBD0/3/QvqyUVbKW4wOIcGzAmMODOWfG3MNh7GQ7TJY4Fi+r7Qc00001XdUlJu//EZPhZB+DnYmMg2sib3/wussFkm99yQuptrdV3dQMSzXsJCs+Sm9vn2A4bXb2bCH8fHh6XgjSRm/a89DXRL603jw8TqfPC1FWQhJ/A0PQOME0ftnuQ0zzoqwY67qOl0pWnZJMVgwvJGleDPkJ7wFPQrC4Wj3NVgE+QZf5UiCU8ip/wfFxXhSX7jzCuesupmG+rBUSpzTJolNqIR/4H318DAiNU808KqqmKkrTNJdekcmdgMiL2rYdpOpnruOsIKf0x8NypxsIHVRVzbJsBHxwg7pthms/7ycvx4uquhlZ1UAMwCVjhBDGGKWkbZrr9VqUDHR6lraY0DzPvwl2G44P7Wt9v1c1fQZ72epA5ACk43RnOYvVShRFz/Pquv4Cp2kKNOqKPc1lYa1HNPGiU17WYBUQchjKsm0YByGUJMkHmBdkWRYEQZKkX7/nrKp5cgiYvNcyHOd86oNS+qru4FPAKopCWMktuJej4lfe/YszjJ3EsbRWd9bRdtzZUvSC6HK9nruOv4r8MbV5DWSYTqfyVgOesNuyaoA5uNpyfORiN6SP8/UBOZSQe8EgYMgoikzktufz3QoYq/OSzURlvlxtXl8xxvfgvwYOG+6w7wEZN8ARJkWRj3ibh2agutfpVnB+1q1jVpS3zr0H7223be/H5mDTCcBng2dHwP/0G/oDO1p0m5Ke5FcAAAAASUVORK5CYII='); background-size: cover; display: block;\"\n  ></span>\n  <picture>\n          <source\n              srcset=\"/static/942c4ea62dae1b7884b63eec588b1892/bc904/tcp.webp 250w,\n/static/942c4ea62dae1b7884b63eec588b1892/aab61/tcp.webp 471w\"\n              sizes=\"(max-width: 471px) 100vw, 471px\"\n              type=\"image/webp\"\n            />\n          <source\n            srcset=\"/static/942c4ea62dae1b7884b63eec588b1892/43fa5/tcp.png 250w,\n/static/942c4ea62dae1b7884b63eec588b1892/9fd7e/tcp.png 471w\"\n            sizes=\"(max-width: 471px) 100vw, 471px\"\n            type=\"image/png\"\n          />\n          <img\n            class=\"gatsby-resp-image-image\"\n            src=\"/static/942c4ea62dae1b7884b63eec588b1892/9fd7e/tcp.png\"\n            alt=\"3-way-handshake 과정\"\n            title=\"\"\n            loading=\"lazy\"\n            decoding=\"async\"\n            style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n          />\n        </picture>\n  </a>\n    </span>\n    <figcaption class=\"gatsby-resp-image-figcaption\">3-way-handshake 과정</figcaption>\n  </figure></p>\n<blockquote>\n<p>💡 <strong>액티브 오픈과 패시브 오픈</strong></p>\n<ul>\n<li><strong>액티브 오픈(Active Open)</strong>: 처음 연결을 시작하는 과정 (주로 클라이언트)</li>\n<li><strong>패시브 오픈(Passive Open)</strong>: 연결 요청을 수신한 뒤 연결을 수립하는 과정 (주로 서버)</li>\n</ul>\n<p>SYN 비트가 설정된 패킷을 처음 보내는 호스트가 액티브 오픈을 수행하는 호스트이다.</p>\n</blockquote>\n<h4 id=\"3-2-실제-패킷-분석을-통한-예시\">3-2 실제 패킷 분석을 통한 예시</h4>\n<p><strong>1단계: SYN 세그먼트</strong></p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">Source Port: 49859 (동적 포트)\nDestination Port: 80 (HTTP)\nSequence Number: 3588415412\nFlags: SYN=1</code></pre></div>\n<p>클라이언트가 동적 포트 49859를 할당받아 HTTP 서버(80번 포트)에 연결 요청을 보낸다.</p>\n<p><strong>2단계: SYN+ACK 세그먼트</strong></p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">Source Port: 80\nDestination Port: 49859\nSequence Number: 697411256\nAcknowledgment Number: 3588415413\nFlags: SYN=1, ACK=1</code></pre></div>\n<p>서버가 자신의 순서 번호를 보내고, 클라이언트가 보낸 순서 번호에 1을 더한 확인 응답 번호를 설정한다.</p>\n<p><strong>3단계: ACK 세그먼트</strong></p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">Source Port: 49859\nDestination Port: 80\nSequence Number: 3588415413\nAcknowledgment Number: 697411257\nFlags: ACK=1</code></pre></div>\n<p>클라이언트가 서버의 순서 번호에 1을 더한 확인 응답 번호로 응답하면 연결이 수립된다.</p>\n<h3 id=\"tcp의-제어-메커니즘\">TCP의 제어 메커니즘</h3>\n<h4 id=\"3-3-재전송을-통한-오류-제어\">3-3 재전송을 통한 오류 제어</h4>\n<p>TCP는 전송 과정에서 잘못된 세그먼트가 있을 경우 <strong>재전송</strong>을 통해 오류를 제어한다. 재전송이 발생하는 상황은 크게 2가지이다.</p>\n<h5>중복된 ACK 세그먼트 수신</h5>\n<p>송신한 세그먼트의 일부가 전송 중 유실되면 수신 측은 계속해서 같은 확인 응답 번호를 보낸다.</p>\n<p><figure class=\"gatsby-resp-image-figure\" style=\"background: transparent;\">\n    <span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 846px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/static/1151a3369dadcd4837f78ea1c632e959/ccfff/tcp-2.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 120.39999999999999%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAYCAYAAAD6S912AAAACXBIWXMAAAsTAAALEwEAmpwYAAADU0lEQVR42o1Ua08bSRDkh5+i00n5mp8SKYoUcXdEggTwOWCDAMfYxvi9rM3ann2/XVc9G7+wgxhptLMzPdXV1T19AI7FYoEg8Dk9RFGEt44wDKHUnFPxXqz3DgrAHOfnF/j69RSGMcLSye/G8kzAzs7+w+XlFTzXXQPmeYp//m3h0+c7MccrWKuR54XRWamH4xOD/9kasNfv4Y93f+LL4d96M8uyVxkWgLn+npcu8df7D3jsPBaAy4vjsQlbzTbC2g1z08lyPRoNKdUR9Q/WDOfzOWYzB8OhQrlcwe1tA09PY0wmYziOQpomK0aC89KZS/2W5wfFhoPp1MZgoPDx4wk9Vin2LY6Pr3F0VEar1UWpVEG93tgbvlL2NqDQnU4VAT3UagZ+/uwTsMbstfHtWwWHh5esgnvOO3S7Cs9mSBIp72UQHM97wTAMA4Y3R78f0FtOCXL+J7CsmAA2JRiR3RAn329welRFfFeDsjPqF6LR8NBsTnV17ACa9Cwgg0HI/1ivTTOmjjlsO8fISNHvBTAeLHQ6ElXC/Yz626skrUK2LMWZ0Ags7oBZ98gg0qwfH33c3AhTG+22j3Yn1GfjcYxeL+J6vs3Q8zw9J5MJKpU7nJ5KMu7x8BBqMAlLAIRRjww7HZ9nPmVwaS9ONkIWplEU4vnZwdXVgIYTahgjjhNtkCQLOst4HmtgAazXPQ1Wq7l63WhYa8AkSeihzUs+9XBZiwOGVqdxhyAJWUdaz/k8oZYp9Uo0uAAbRsiKcCnLRshBEJJZlcYBdeqxsO91RlstE76f68QIiFw2jEhnVhwolTKyfLewozBCl+/QsSWUAarVOmvwhto0CRDrzA+HIfUrQNJ0t3k4jqs71iopoqFSLq6vOyziMpNS43pAw4UOM8sWO81i8wluMUz57JzJE0bdJz6vPvW0WJcZmQhQuvIsF2QWTeIVwIzl4rAJzMxn6jbm8/rBTDcZ+hVfQJNspfGWmKR7XFyU9d7LBrzTHKSwbdvWTVI6i/TDLMt15mazkJ3H5wyYWalHnzJkesZxvh/Q930NWID8ru3jV/Nd6KxLkUu2peClYew8vYJhvhdoXw/cPJMsbzGc8gGbpqkT8ZaxdlJ4sSxrG1Beyz52bx2bd/8Hfd4ppSUO0mcAAAAASUVORK5CYII='); background-size: cover; display: block;\"\n  ></span>\n  <picture>\n          <source\n              srcset=\"/static/1151a3369dadcd4837f78ea1c632e959/bc904/tcp-2.webp 250w,\n/static/1151a3369dadcd4837f78ea1c632e959/4be29/tcp-2.webp 500w,\n/static/1151a3369dadcd4837f78ea1c632e959/ffdf3/tcp-2.webp 846w\"\n              sizes=\"(max-width: 846px) 100vw, 846px\"\n              type=\"image/webp\"\n            />\n          <source\n            srcset=\"/static/1151a3369dadcd4837f78ea1c632e959/43fa5/tcp-2.png 250w,\n/static/1151a3369dadcd4837f78ea1c632e959/c6e3d/tcp-2.png 500w,\n/static/1151a3369dadcd4837f78ea1c632e959/ccfff/tcp-2.png 846w\"\n            sizes=\"(max-width: 846px) 100vw, 846px\"\n            type=\"image/png\"\n          />\n          <img\n            class=\"gatsby-resp-image-image\"\n            src=\"/static/1151a3369dadcd4837f78ea1c632e959/ccfff/tcp-2.png\"\n            alt=\"세그먼트 유실 시, 서버가 동일한 ACK Number을 3번 받으면 해당 세그먼트를 다시 보냄\"\n            title=\"\"\n            loading=\"lazy\"\n            decoding=\"async\"\n            style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n          />\n        </picture>\n  </a>\n    </span>\n    <figcaption class=\"gatsby-resp-image-figcaption\">세그먼트 유실 시, 서버가 동일한 ACK Number을 3번 받으면 해당 세그먼트를 다시 보냄</figcaption>\n  </figure></p>\n<p>중복된 ACK를 받으면 송신 측은 해당 세그먼트를 재전송한다.</p>\n<h5>타임아웃 발생</h5>\n<p>TCP는 <code class=\"language-text\">재전송 타이머(Retransmission Timer)</code>를 사용한다. 세그먼트를 전송할 때마다 타이머를 시작하고, 타임아웃 시점까지 ACK를 받지 못하면 세그먼트를 재전송한다.</p>\n<blockquote>\n<p>💡 <strong>파이프라이닝 전송</strong></p>\n<p>기본적으로 TCP는 순서 번호를 보내고 확인 응답을 받는 과정을 반복한다. 그러나 이는 비효율적이므로, 현대 TCP는 <strong>파이프라이닝(Pipelining)</strong> 방식을 사용한다.</p>\n<ul>\n<li><strong>기존 방식</strong>: 한 번에 하나의 세그먼트만 송수신</li>\n<li><strong>파이프라이닝</strong>: 확인 응답을 받기 전에 여러 세그먼트를 연속으로 전송</li>\n</ul>\n<p>파이프라이닝을 통해 네트워크 대역폭을 효율적으로 활용할 수 있다.</p>\n</blockquote>\n<h4 id=\"3-4-흐름-제어\">3-4 흐름 제어</h4>\n<p><code class=\"language-text\">흐름 제어(Flow Control)</code>는 수신 호스트가 한 번에 처리할 수 있을 만큼만 전송하는 것을 의미한다. 송신 호스트가 수신 호스트의 <strong>처리 속도를 고려</strong>하여 송수신 속도를 균일하게 맞추는 기능이다.</p>\n<h5>수신 윈도우</h5>\n<p>TCP 헤더의 <code class=\"language-text\">윈도우(Window)</code> 필드에는 수신 호스트가 한 번에 처리할 수 있는 <strong>수신 윈도우(Receiver Window)</strong> 크기가 명시된다.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">수신 호스트: \"나는 한 번에 8192바이트를 처리할 수 있어\"\n             ↓ (윈도우 필드로 전달)\n송신 호스트: \"그럼 8192바이트 이하로만 보내겠어\"</code></pre></div>\n<p>수신 윈도우 크기는 <strong>TCP 수신 버퍼</strong>의 크기에 의해 결정된다. 수신 버퍼는 수신된 세그먼트가 애플리케이션 프로세스에 의해 읽히기 전에 임시 저장되는 공간이다.</p>\n<h4 id=\"3-5-혼잡-제어\">3-5 혼잡 제어</h4>\n<p><code class=\"language-text\">혼잡(Congestion)</code>이란 많은 트래픽으로 인해 패킷의 처리 속도가 느려지거나 유실될 수 있는 상황을 의미한다. <code class=\"language-text\">혼잡 제어(Congestion Control)</code>는 네트워크의 혼잡 정도에 따라 전송량을 조절하는 기능이다.</p>\n<h5>혼잡 감지</h5>\n<p>송신 호스트는 다음 상황에서 네트워크 혼잡을 감지한다.</p>\n<ul>\n<li>중복된 ACK 세그먼트 도착</li>\n<li>타임아웃 발생</li>\n</ul>\n<h5>혼잡 윈도우</h5>\n<p><code class=\"language-text\">혼잡 윈도우(Congestion Window)</code>는 혼잡 없이 전송할 수 있을 정도의 양을 나타낸다.</p>\n<ul>\n<li><strong>큰 혼잡 윈도우</strong>: 한 번에 전송할 수 있는 세그먼트 수가 많음</li>\n<li><strong>작은 혼잡 윈도우</strong>: 네트워크가 혼잡하여 전송할 수 있는 세그먼트 수가 적음</li>\n</ul>\n<h5>AIMD 알고리즘</h5>\n<p><code class=\"language-text\">AIMD(Additive Increase/Multiplicative Decrease)</code>는 가장 기본적인 혼잡 제어 알고리즘이다.</p>\n<ul>\n<li><strong>증가</strong>: 혼잡이 감지되지 않으면 혼잡 윈도우를 <strong>1씩 선형적으로 증가</strong></li>\n<li><strong>감소</strong>: 혼잡이 감지되면 혼잡 윈도우를 <strong>절반으로 감소</strong></li>\n</ul>\n<blockquote>\n<p>💡 <strong>RTT (Round Trip Time)</strong></p>\n<p><code class=\"language-text\">RTT</code>는 패킷을 보내고 그에 대한 응답을 수신하기까지의 시간이다. AIMD는 RTT마다 혼잡 윈도우를 1씩 증가시킨다고 표현할 수 있다.</p>\n<ul>\n<li>네트워크 성능 측정의 중요한 지표</li>\n<li><code class=\"language-text\">ping</code> 명령어로 RTT 확인 가능</li>\n</ul>\n</blockquote>\n<p>혼잡 윈도우는 AIMD에 따라 톱니 모양으로 변화한다. 네트워크 상태에 따라 적응적으로 전송량을 조절하여 네트워크 효율성을 높인다.</p>\n<h3 id=\"tcp-연결-종료-포-웨이-핸드셰이크\">TCP 연결 종료: 포 웨이 핸드셰이크</h3>\n<h4 id=\"3-6-포-웨이-핸드셰이크-과정\">3-6 포 웨이 핸드셰이크 과정</h4>\n<p>TCP 연결 종료는 송수신 호스트가 각자 한 번씩 <code class=\"language-text\">FIN</code>과 <code class=\"language-text\">ACK</code>를 주고받으며 이루어진다. 4개의 단계를 거친다는 점에서 <code class=\"language-text\">포 웨이 핸드셰이크(Four-way Handshake)</code>라고 부른다.</p>\n<p><strong>1단계: FIN 세그먼트 전송 (A → B)</strong></p>\n<ul>\n<li>호스트 A가 <code class=\"language-text\">FIN</code> 비트를 1로 설정한 세그먼트를 전송</li>\n</ul>\n<p><strong>2단계: ACK 세그먼트 전송 (B → A)</strong></p>\n<ul>\n<li>호스트 B가 <code class=\"language-text\">ACK</code> 세그먼트로 응답</li>\n</ul>\n<p><strong>3단계: FIN 세그먼트 전송 (B → A)</strong></p>\n<ul>\n<li>호스트 B가 <code class=\"language-text\">FIN</code> 세그먼트를 전송</li>\n</ul>\n<p><strong>4단계: ACK 세그먼트 전송 (A → B)</strong></p>\n<ul>\n<li>호스트 A가 <code class=\"language-text\">ACK</code> 세그먼트로 응답</li>\n</ul>\n<blockquote>\n<p>💡 <strong>액티브 클로즈와 패시브 클로즈</strong></p>\n<ul>\n<li><strong>액티브 클로즈(Active Close)</strong>: 먼저 연결 종료를 요청하는 호스트의 동작</li>\n<li><strong>패시브 클로즈(Passive Close)</strong>: 연결 종료 요청을 받아들이는 호스트의 동작</li>\n</ul>\n<p>FIN 세그먼트를 먼저 보내는 호스트가 액티브 클로즈를 수행한다.</p>\n</blockquote>\n<h3 id=\"tcp-상태-관리\">TCP 상태 관리</h3>\n<h4 id=\"3-7-tcp-상태의-개념\">3-7 TCP 상태의 개념</h4>\n<p>TCP는 <strong>상태를 유지하고 관리</strong>하는 프로토콜이라는 점에서 <code class=\"language-text\">스테이트풀 프로토콜(Stateful Protocol)</code>이라고 부른다. 상태(State)란 현재 어떤 통신 과정에 있는지를 나타내는 정보이다.</p>\n<p>TCP의 상태 정보는 네트워크 명령어(<code class=\"language-text\">netstat</code>, <code class=\"language-text\">ss</code> 등)를 통해 확인할 수 있으며, 현재 TCP 송수신 현황을 판단하고 디버깅에 활용할 수 있다.</p>\n<div class=\"gatsby-highlight\" data-language=\"bash\"><pre class=\"language-bash\"><code class=\"language-bash\">$ <span class=\"token function\">netstat</span> <span class=\"token parameter variable\">-a</span> <span class=\"token parameter variable\">-p</span> tcp\nProto Local Address      Foreign Address     State\ntcp4  <span class=\"token number\">10.11</span>.12.13.53625  <span class=\"token number\">123.123</span>.123.123     ESTABLISHED\ntcp4  <span class=\"token number\">10.11</span>.12.13.50102  <span class=\"token number\">123.123</span>.123.127     TIME_WAIT\ntcp4  localhost.16107    *.*                 LISTEN</code></pre></div>\n<h4 id=\"3-8-tcp-상태-분류\">3-8 TCP 상태 분류</h4>\n<p>TCP 상태는 연결 단계에 따라 3가지로 분류할 수 있다.</p>\n<h5>연결 수립 전 상태</h5>\n<table>\n<thead>\n<tr>\n<th>상태</th>\n<th>설명</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>CLOSED</td>\n<td>아무런 연결이 없는 상태</td>\n</tr>\n<tr>\n<td>LISTEN</td>\n<td>연결 대기 상태 (SYN 세그먼트를 대기)</td>\n</tr>\n</tbody>\n</table>\n<p>서버는 일반적으로 <code class=\"language-text\">LISTEN</code> 상태에서 클라이언트의 연결 요청을 기다린다.</p>\n<h5>연결 수립 과정 상태</h5>\n<table>\n<thead>\n<tr>\n<th>상태</th>\n<th>설명</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>SYN-SENT</td>\n<td>액티브 오픈 호스트가 SYN을 보낸 후 SYN+ACK를 기다리는 상태</td>\n</tr>\n<tr>\n<td>SYN-RECEIVED</td>\n<td>패시브 오픈 호스트가 SYN+ACK를 보낸 후 ACK를 기다리는 상태</td>\n</tr>\n<tr>\n<td>ESTABLISHED</td>\n<td>쓰리 웨이 핸드셰이크 완료 후 데이터를 송수신할 수 있는 상태</td>\n</tr>\n</tbody>\n</table>\n<h5>연결 종료 과정 상태</h5>\n<table>\n<thead>\n<tr>\n<th>상태</th>\n<th>설명</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>FIN-WAIT-1</td>\n<td>액티브 클로즈 호스트가 FIN을 보낸 상태</td>\n</tr>\n<tr>\n<td>CLOSE-WAIT</td>\n<td>패시브 클로즈 호스트가 FIN을 받고 ACK를 보낸 후 대기 상태</td>\n</tr>\n<tr>\n<td>FIN-WAIT-2</td>\n<td>FIN-WAIT-1 상태에서 ACK를 받은 상태</td>\n</tr>\n<tr>\n<td>LAST-ACK</td>\n<td>CLOSE-WAIT 상태에서 FIN을 보낸 후 ACK를 기다리는 상태</td>\n</tr>\n<tr>\n<td>TIME-WAIT</td>\n<td>액티브 클로즈 호스트가 마지막 ACK를 보낸 후 대기 상태</td>\n</tr>\n</tbody>\n</table>\n<h4 id=\"3-9-closing-상태\">3-9 CLOSING 상태</h4>\n<p><code class=\"language-text\">CLOSING</code> 상태는 양쪽 호스트가 동시에 FIN을 보내는 특수한 상황에서 발생한다.</p>\n<ul>\n<li>서로 FIN 세그먼트를 보내고 받음</li>\n<li>각자 ACK 세그먼트를 보냄</li>\n<li>아직 자신의 FIN에 대한 ACK를 받지 못한 상태</li>\n</ul>\n<p>이는 드문 경우이지만, 양쪽에서 동시에 연결 종료를 시도할 때 발생할 수 있다.</p>\n<h2 id=\"4️-정리\">4️⃣ 정리</h2>\n<ul>\n<li>TCP와 UDP는 각각 <strong>신뢰성</strong>과 <strong>속도</strong>라는 서로 다른 목표를 가진 프로토콜이다.\n<ul>\n<li>TCP는 <code class=\"language-text\">3-way-handshake</code>를 통한 연결 수립, <code class=\"language-text\">순서 번호</code>와 <code class=\"language-text\">확인 응답 번호</code>를 통한 신뢰성 보장, 흐름·오류·혼잡 제어를 통한 안정적인 전송, 그리고 <code class=\"language-text\">4-way-handshake</code>를 통한 안전한 연결 종료를 제공한다.</li>\n<li>UDP는 최소한의 기능만 제공하여 빠른 전송이 가능하다.</li>\n</ul>\n</li>\n</ul>\n<p>포트 번호를 통한 프로세스 식별은 TCP와 UDP 모두가 제공하는 전송 계층의 핵심 기능이다. 이를 통해 네트워크 패킷은 <strong>호스트를 넘어 최종 목적지인 애플리케이션 프로세스</strong>까지 정확히 전달될 수 있다.</p>","fields":{"slug":"/transport-layer-tcp-udp/"},"frontmatter":{"title":"[네트워크] 전송 계층 - TCP와 UDP","date":"2026-02-15","description":"네트워크 전송 계층의 핵심 프로토콜 TCP와 UDP의 동작 원리와 특징을 정리합니다.","pointColor":"#ffffff","tags":["네트워크"],"keywords":"TCP, UDP, 전송 계층, 포트, 쓰리 웨이 핸드셰이크, 포 웨이 핸드셰이크, 흐름 제어, 혼잡 제어, 오류 제어, 네트워크 프로토콜","thumbnail":{"publicURL":"/static/05bcda411ff011ba9334113ad4b0817b/index.png","childImageSharp":{"gatsbyImageData":{"layout":"fixed","placeholder":{"fallback":"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAKCAYAAAC0VX7mAAAACXBIWXMAACE4AAAhOAFFljFgAAABVUlEQVR42o2S20sCQRTG/astWysI6qGLSje6QA+9FBI99JDuKgWuujOauTeT0kgSIgP/hq8zZ3EJm40eDnPmnJ1vzvfbSbVWKtDGanUuftSTzlCkdEWZtSCWTIhMGc5iOc6lYXKu+v8XXLbQ2biHm7cRHAr0zx7gFRoI9h24ORu9kxa6W7VE0dS8TTXJ8/kjJnKMr/YY02CCd/MF0/ATbzd9fNgjDIs+T66zPydYgSBb4ZHEiA4PLjwMr3ye8vU6xOCS9sWA+oKtx1x1gmyB7MoscaLbnXQJzkKJ8hKza6ZvI560Fxkz+k7xNKzfgpKEups1dNbv8HTaQkjsvEKdrYcHDtprVeLpwN9rMkuPWLr5OnrHEgH19YLbNf4Z/m6DBd0dOz7QJlYu9dVPUXUvV+dVXaBWvWUaXbJliy3Ono7KZ0i4bkQ2VQgjwXLy465owf/1sL8BxztlBeXl47IAAAAASUVORK5CYII="},"backgroundColor":"transparent","images":{"fallback":{"src":"/static/05bcda411ff011ba9334113ad4b0817b/a1758/index.png","srcSet":"/static/05bcda411ff011ba9334113ad4b0817b/a1758/index.png 1200w","sizes":"1200px"},"sources":[{"srcSet":"/static/05bcda411ff011ba9334113ad4b0817b/afc39/index.webp 1200w","type":"image/webp","sizes":"1200px"}]},"width":1200,"height":585},"fixed":{"src":"/static/05bcda411ff011ba9334113ad4b0817b/f3583/index.png"}}}}},"previous":{"fields":{"slug":"/network-layer-ip-protocol/"},"frontmatter":{"title":"[네트워크] 네트워크 계층과 IP 프로토콜"}},"next":{"fields":{"slug":"/http-fundamentals/"},"frontmatter":{"title":"[네트워크] HTTP의 기초 - DNS와 HTTP Message, Method, Status (스압 주의) "}}},"pageContext":{"id":"e2dcd532-3c81-5f24-8d01-6fa07b647c07","previousPostId":"060ac6d5-55b8-5c55-bb44-a75b767370ab","nextPostId":"e653a78d-eff6-5ea5-ba4f-6d3c9121632f"}},"staticQueryHashes":["736397157"],"slicesMap":{}}