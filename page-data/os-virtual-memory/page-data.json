{"componentChunkName":"component---src-templates-blog-post-js","path":"/os-virtual-memory/","result":{"data":{"site":{"siteMetadata":{"title":"홈","siteUrl":"https://inyoung.dev","author":{"name":"Inyoung Chung"}}},"allMarkdownRemark":{"nodes":[{"fields":{"slug":"/troubleshooting-supabase-auth/"},"frontmatter":{"title":"[트러블슈팅] Supabase Auth를 활용한 다양한 환경에서의 세션 유지","date":"2026-02-10","tags":["Web","회고"],"pointColor":"#3ECF8D"}},{"fields":{"slug":"/waterfall-agile/"},"frontmatter":{"title":"[소프트웨어공학] Waterfall과 Agile","date":"2026-02-03","tags":["소프트웨어공학"],"pointColor":"#ffffff"}},{"fields":{"slug":"/os-file-system/"},"frontmatter":{"title":"[운영체제] 파일 시스템","date":"2026-01-27","tags":["운영체제"],"pointColor":"#ffffff"}},{"fields":{"slug":"/os-virtual-memory/"},"frontmatter":{"title":"[운영체제] 5. 가상 메모리","date":"2026-01-26","tags":["운영체제"],"pointColor":"#ffffff"}},{"fields":{"slug":"/os-cpu-scheduling/"},"frontmatter":{"title":"[운영체제] 4. CPU 스케줄링","date":"2026-01-25","tags":["운영체제"],"pointColor":"#ffffff"}},{"fields":{"slug":"/os-synchronization-deadlock/"},"frontmatter":{"title":"[운영체제] 3. 동기화와 교착 상태","date":"2026-01-24","tags":["운영체제"],"pointColor":"#ffffff"}},{"fields":{"slug":"/os-process-thread/"},"frontmatter":{"title":"[운영체제] 2. 프로세스와 스레드","date":"2026-01-23","tags":["운영체제"],"pointColor":"#ffffff"}},{"fields":{"slug":"/os-big-picture/"},"frontmatter":{"title":"[운영체제] 1. 운영체제의 큰 그림","date":"2026-01-21","tags":["운영체제"],"pointColor":"#ffffff"}},{"fields":{"slug":"/computer-architecture-cpu/"},"frontmatter":{"title":"[컴퓨터구조] 3. CPU","date":"2026-01-18","tags":["컴퓨터구조"],"pointColor":"#ffffff"}},{"fields":{"slug":"/computer-architecture-computer-information/"},"frontmatter":{"title":"[컴퓨터구조] 2. 컴퓨터가 이해하는 정보","date":"2026-01-17","tags":["컴퓨터구조"],"pointColor":"#ffffff"}},{"fields":{"slug":"/computer-architecture-big-picture/"},"frontmatter":{"title":"[컴퓨터구조] 1. 컴퓨터구조의 큰 그림","date":"2026-01-15","tags":["컴퓨터구조"],"pointColor":"#ffffff"}},{"fields":{"slug":"/java-coding-test-grammer/"},"frontmatter":{"title":"Java 코딩테스트 문법 최종 정리","date":"2026-01-08","tags":["알고리즘"],"pointColor":"#ed8b00"}},{"fields":{"slug":"/lg-webos-tv-fullstack-appliaction/"},"frontmatter":{"title":"WebOS TV에 들어갈 풀스택 애플리케이션을 만들어보자 (LG전자 산학 프로젝트 후기)","date":"2025-12-22","tags":["회고"],"pointColor":"#ffffff"}},{"fields":{"slug":"/algorithm-maximum-flow/"},"frontmatter":{"title":"알고리즘설계와분석 - 최대 유량 문제 (Maximum Flow)","date":"2025-12-16","tags":["알고리즘"],"pointColor":"#ffffff"}},{"fields":{"slug":"/algorithm-shortest-path/"},"frontmatter":{"title":"알고리즘설계와분석 - 최단경로 (Shortest Path)","date":"2025-12-13","tags":["알고리즘"],"pointColor":"#ffffff"}},{"fields":{"slug":"/algorithm-minimum-spanning-tree/"},"frontmatter":{"title":"알고리즘설계와분석 - MST (최소신장트리)","date":"2025-12-12","tags":["알고리즘"],"pointColor":"#ffffff"}},{"fields":{"slug":"/algorithm-bfs-dfs/"},"frontmatter":{"title":"알고리즘설계와분석 - BFS/DFS와 Topological Sort","date":"2025-12-11","tags":["알고리즘"],"pointColor":"#ffffff"}},{"fields":{"slug":"/algorithm-greedy-algorithm/"},"frontmatter":{"title":"알고리즘설계와분석 - Greedy algorithm (그리디 알고리즘)","date":"2025-12-10","tags":["알고리즘"],"pointColor":"#ffffff"}},{"fields":{"slug":"/algorithm-dynamic-programming/"},"frontmatter":{"title":"알고리즘설계와분석 - Dynamic Programming (동적 계획법)","date":"2025-12-07","tags":["알고리즘"],"pointColor":"#ffffff"}},{"fields":{"slug":"/algorithm-binary-search-tree/"},"frontmatter":{"title":"알고리즘설계와분석 - Binary Search Tree (이진 탐색 트리)","date":"2025-12-05","tags":["알고리즘"],"pointColor":"#ffffff"}},{"fields":{"slug":"/database-system-erd/"},"frontmatter":{"title":"데이터베이스 시스템 개론 📚 - Chapter2. ERD로 데이터베이스 설계하기","date":"2025-10-05","tags":["DB"],"pointColor":"#ffffff"}},{"fields":{"slug":"/make-huggingface-pipeline/"},"frontmatter":{"title":"허깅페이스로 파이프라인을 만들어보자 - 트랜스포머 모델 활용 가이드","date":"2025-10-04","tags":["AI"],"pointColor":"#FF9A00"}},{"fields":{"slug":"/rag-core-concept/"},"frontmatter":{"title":"RAG의 핵심 개념과 실습","date":"2025-10-01","tags":["AI"],"pointColor":"#FF6B6B"}},{"fields":{"slug":"/prompt-engineering-basic/"},"frontmatter":{"title":"프롬프트 엔지니어링 기초 - AI와 효과적으로 소통하는 방법","date":"2025-09-28","tags":["AI"],"pointColor":"#ffffff"}},{"fields":{"slug":"/how-to-use-flutter-riverpod/"},"frontmatter":{"title":"초심자 입장에서 Flutter Riverpod을 '잘' 사용하는 방법 (장문)","date":"2025-09-20","tags":["Flutter"],"pointColor":"#0468d7"}},{"fields":{"slug":"/database-system-introduction/"},"frontmatter":{"title":"데이터베이스 시스템 개론 📚 – Chapter 1. Introduction of Database Systems","date":"2025-09-16","tags":["DB"],"pointColor":"#ffffff"}},{"fields":{"slug":"/kakaobank-devrel-internship-retrospect/"},"frontmatter":{"title":"서비스 개발부터 DevRel까지: 카카오뱅크 인턴쉽 회고","date":"2025-07-28","tags":["인턴","회고","카카오뱅크","네이버랩스"],"pointColor":"#ffe300"}},{"fields":{"slug":"/my-it-startup-internship-retrospect/"},"frontmatter":{"title":"나의 IT 스타트업 인턴쉽 회고","date":"2025-03-14","tags":["인턴","회고"],"pointColor":"#6FE7FF"}},{"fields":{"slug":"/sogang-likelion-management-retrospect/"},"frontmatter":{"title":"서강대학교 멋쟁이사자처럼 운영진 회고","date":"2025-02-27","tags":["멋쟁이사자처럼","회고"],"pointColor":"#FD7911"}}]},"markdownRemark":{"id":"dc18f114-802b-5431-b431-81f1c9a487d3","excerpt":"CPU와 프로세스는 메모리의 실제 주소를 직접 다루지 않는다. 대신 논리 주소와 가상 메모리를 통해 메모리를 관리한다. 이 글에서는 가상 메모리의 개념과 페이징 기법을 다룬다. 1️⃣ 물리 주소와 논리 주소 주소 체계의 필요성 CPU…","html":"<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 1000px; background: transparent;\"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/static/3a1b802e67c087a7a9f25e9555b620d4/7c474/index.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 48.800000000000004%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAKCAYAAAC0VX7mAAAACXBIWXMAACE4AAAhOAFFljFgAAABQElEQVR42mNgqCz7j44ZgZipqvw/IxCDaKbqCgQbKo5NHxhjFSwr/s9QlP+fobgAQcMwiF9aRJyBIJcxlBf/l2lv/e85f+5/i2lT/nstmPvfftYMMNtu1vT/7vPm/Nfo6wFbitWlyBxmkAKgC0KWLv6/+/bt/1U7d/zfcuP6/77Dh/4vOHvmf9fBA/9XXrr4P3ntarA6ZkIGgsIH5B3DSRPAhupP6APT5kDXuQFd5j5vNtjFJlMmgdURdCEcg8IIGF5MoLAszIOEW0Eugl1SSEIYAg1R6en8L9hY/1+5u/O/zcxp/w2ALnaYPRMcrqZTJ4HDk7W68j9DRSkxkVLyX7y1CYzFgFgH6G1QJGj39/63mTEdaODk/2q9XUADKwgbCDcYpBCEgYaDcUUJJCmBMEyMpHQId3E5xNVQ18MwPj0AoX2aolp7iy4AAAAASUVORK5CYII='); background-size: cover; display: block;\"\n  ></span>\n  <picture>\n          <source\n              srcset=\"/static/3a1b802e67c087a7a9f25e9555b620d4/bc904/index.webp 250w,\n/static/3a1b802e67c087a7a9f25e9555b620d4/4be29/index.webp 500w,\n/static/3a1b802e67c087a7a9f25e9555b620d4/03f31/index.webp 1000w,\n/static/3a1b802e67c087a7a9f25e9555b620d4/84f56/index.webp 1329w\"\n              sizes=\"(max-width: 1000px) 100vw, 1000px\"\n              type=\"image/webp\"\n            />\n          <source\n            srcset=\"/static/3a1b802e67c087a7a9f25e9555b620d4/43fa5/index.png 250w,\n/static/3a1b802e67c087a7a9f25e9555b620d4/c6e3d/index.png 500w,\n/static/3a1b802e67c087a7a9f25e9555b620d4/da8b6/index.png 1000w,\n/static/3a1b802e67c087a7a9f25e9555b620d4/7c474/index.png 1329w\"\n            sizes=\"(max-width: 1000px) 100vw, 1000px\"\n            type=\"image/png\"\n          />\n          <img\n            class=\"gatsby-resp-image-image\"\n            src=\"/static/3a1b802e67c087a7a9f25e9555b620d4/da8b6/index.png\"\n            alt=\"index\"\n            title=\"\"\n            loading=\"lazy\"\n            decoding=\"async\"\n            style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n          />\n        </picture>\n  </a>\n    </span></p>\n<blockquote>\n<p>CPU와 프로세스는 메모리의 실제 주소를 직접 다루지 않는다. 대신 논리 주소와 가상 메모리를 통해 메모리를 관리한다. 이 글에서는 가상 메모리의 개념과 페이징 기법을 다룬다.</p>\n</blockquote>\n<h2 id=\"1️-물리-주소와-논리-주소\">1️⃣ 물리 주소와 논리 주소</h2>\n<h3 id=\"주소-체계의-필요성\">주소 체계의 필요성</h3>\n<p>CPU와 프로세스는 메모리에 무엇이 저장되어 있는지 모두 알고 있지 않다. 그 이유는 다음과 같다:</p>\n<ul>\n<li>CPU 내부의 레지스터 용량이 메모리보다 훨씬 작음</li>\n<li>프로세스는 실시간으로 메모리에 적재되고 삭제됨</li>\n<li>메모리 정보가 시시때때로 변경됨</li>\n</ul>\n<p>따라서 CPU는 메모리의 실제 주소가 아닌 다른 주소 체계를 사용한다.</p>\n<h4 id=\"1-1-물리-주소-physical-address\">1-1 물리 주소 (Physical Address)</h4>\n<p><code class=\"language-text\">물리 주소</code>는 메모리 하드웨어 상의 실제 주소를 의미한다.</p>\n<ul>\n<li>메모리에 실제로 존재하는 주소</li>\n<li>중복되는 물리 주소의 번지 수는 존재하지 않음</li>\n</ul>\n<h4 id=\"1-2-논리-주소-logical-address\">1-2 논리 주소 (Logical Address)</h4>\n<p><code class=\"language-text\">논리 주소</code>는 프로세스마다 부여되는 0번지부터 시작하는 주소 체계다.</p>\n<p><strong>📊 논리 주소의 특징</strong></p>\n<ul>\n<li>각 프로세스는 독립적인 논리 주소 공간을 가짐</li>\n<li>모든 프로세스가 0번지부터 시작하는 주소를 가짐</li>\n<li>중복되는 논리 주소의 번지 수는 얼마든지 존재 가능</li>\n</ul>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">웹 브라우저: 논리 주소 0번지 ~ 1000번지\n메모장:      논리 주소 0번지 ~ 500번지\n게임:        논리 주소 0번지 ~ 2000번지</code></pre></div>\n<h3 id=\"mmu-memory-management-unit\">MMU (Memory Management Unit)</h3>\n<p>논리 주소와 물리 주소 간의 변환을 위해 <code class=\"language-text\">MMU</code>가 존재한다.</p>\n<h4 id=\"1-3-mmu의-역할\">1-3 MMU의 역할</h4>\n<p><code class=\"language-text\">MMU</code>는 CPU와 메모리 사이에 위치하여 논리 주소를 물리 주소로 변환하는 하드웨어다.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">CPU (논리 주소) → MMU → 메모리 (물리 주소)</code></pre></div>\n<blockquote>\n<p>💡 <strong>주소 변환의 필요성</strong></p>\n<p>CPU는 논리 주소로 통신하고 메모리는 물리 주소로 통신한다. 두 장치가 원활하게 통신하려면 MMU를 통한 주소 변환이 필수적이다.</p>\n</blockquote>\n<h2 id=\"2️-스와핑-swapping\">2️⃣ 스와핑 (Swapping)</h2>\n<h3 id=\"스와핑의-개념\">스와핑의 개념</h3>\n<p><code class=\"language-text\">스와핑</code>은 메모리에 적재된 프로세스를 보조기억장치로 이동시키는 메모리 관리 방식이다.</p>\n<h4 id=\"2-1-스와핑이-필요한-경우\">2-1 스와핑이 필요한 경우</h4>\n<p>다음과 같은 프로세스는 메모리에 계속 있을 필요가 없다:</p>\n<ul>\n<li>입출력 작업으로 대기 상태가 된 프로세스</li>\n<li>오랫동안 사용되지 않은 프로세스</li>\n</ul>\n<h4 id=\"2-2-스왑-영역-swap-space\">2-2 스왑 영역 (Swap Space)</h4>\n<p><code class=\"language-text\">스왑 영역</code>은 보조기억장치의 일부 영역으로, 메모리에서 쫓겨난 프로세스가 임시로 저장되는 공간이다.</p>\n<p><strong>macOS에서 스왑 영역 확인</strong></p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">활성 상태 보기 → 메모리 탭\n사용된 스왑 공간: 0바이트</code></pre></div>\n<p><strong>Linux에서 스왑 영역 확인</strong></p>\n<div class=\"gatsby-highlight\" data-language=\"bash\"><pre class=\"language-bash\"><code class=\"language-bash\">$ <span class=\"token function\">free</span> <span class=\"token parameter variable\">-h</span>\n              total        used        <span class=\"token function\">free</span>      shared  buff/cache   available\nMem:           15Gi       <span class=\"token number\">8</span>.2Gi       <span class=\"token number\">1</span>.5Gi       589Mi       <span class=\"token number\">5</span>.8Gi       <span class=\"token number\">6</span>.5Gi\nSwap:         <span class=\"token number\">2</span>.0Gi       256Mi       <span class=\"token number\">1</span>.7Gi</code></pre></div>\n<h4 id=\"2-3-스왑-인아웃\">2-3 스왑 인/아웃</h4>\n<table>\n<thead>\n<tr>\n<th>용어</th>\n<th>설명</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>스왑 아웃 (Swap Out)</td>\n<td>메모리에서 스왑 영역으로 프로세스를 이동</td>\n</tr>\n<tr>\n<td>스왑 인 (Swap In)</td>\n<td>스왑 영역에서 메모리로 프로세스를 이동</td>\n</tr>\n</tbody>\n</table>\n<p><strong>⚠️ 중요한 특징</strong></p>\n<p>스왑 아웃되었던 프로세스가 다시 스왑 인될 때는 스왑 아웃되기 전의 물리 주소와 <strong>다른 주소</strong>에 적재될 수 있다.</p>\n<h2 id=\"3️-연속-메모리-할당과-외부-단편화\">3️⃣ 연속 메모리 할당과 외부 단편화</h2>\n<h3 id=\"연속-메모리-할당\">연속 메모리 할당</h3>\n<p><code class=\"language-text\">연속 메모리 할당</code>은 프로세스에 연속적인 메모리 공간을 할당하는 방식이다.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">메모리: [프로세스 A][프로세스 B][프로세스 C][빈 공간]</code></pre></div>\n<h4 id=\"3-1-외부-단편화-external-fragmentation\">3-1 외부 단편화 (External Fragmentation)</h4>\n<p><code class=\"language-text\">외부 단편화</code>는 프로세스 바깥에 생기는 사용 불가능한 빈 공간을 의미한다.</p>\n<p><strong>🚨 문제 상황</strong></p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">메모리: [프로세스 A][빈 공간 30MB][프로세스 B][빈 공간 20MB]\n\n새 프로세스 C (50MB) 적재 시도\n→ 총 빈 공간: 50MB\n→ 연속된 빈 공간이 없어 적재 불가능</code></pre></div>\n<p>프로세스의 실행과 종료를 반복하며 메모리 사이에 빈 공간이 생기고, 이러한 빈 공간들은 분명 비어있지만 큰 프로세스를 적재하기 어려워 <strong>메모리 낭비</strong>로 이어진다.</p>\n<h2 id=\"4️-가상-메모리-virtual-memory\">4️⃣ 가상 메모리 (Virtual Memory)</h2>\n<p><code class=\"language-text\">가상 메모리</code>는 실행하고자 하는 프로그램의 일부만 메모리에 적재해, 실제 메모리보다 더 큰 프로세스를 실행할 수 있도록 만드는 메모리 관리 기법이다.</p>\n<h3 id=\"가상-메모리의-특징\">가상 메모리의 특징</h3>\n<ul>\n<li>보조기억장치의 일부를 메모리처럼 사용</li>\n<li>프로세스의 일부만 메모리에 적재</li>\n<li>메모리를 실제 크기보다 더 크게 보이게 함</li>\n</ul>\n<blockquote>\n<p>💡 <strong>가상 주소 공간 (Virtual Address Space)</strong></p>\n<p>가상 메모리 기법으로 생성된 논리 주소 공간을 <code class=\"language-text\">가상 주소 공간</code>이라고도 부른다.</p>\n</blockquote>\n<h3 id=\"가상-메모리-관리-기법\">가상 메모리 관리 기법</h3>\n<p>대표적인 가상 메모리 관리 기법은 다음과 같다:</p>\n<ul>\n<li><strong>페이징 (Paging)</strong>: 일정한 크기로 분할</li>\n<li><strong>세그멘테이션 (Segmentation)</strong>: 가변적인 크기로 분할</li>\n</ul>\n<p>이 중 더 범용적으로 사용되는 <strong>페이징</strong>에 대해 자세히 알아본다.</p>\n<h2 id=\"5️-페이징-paging\">5️⃣ 페이징 (Paging)</h2>\n<p><code class=\"language-text\">페이징</code>은 프로세스의 논리 주소 공간을 <strong>페이지</strong>라는 일정한 단위로 나누고, 물리 주소 공간을 <strong>프레임</strong>이라는 단위로 나눈 뒤 페이지를 프레임에 할당하는 기법이다.</p>\n<h3 id=\"페이징의-구성-요소\">페이징의 구성 요소</h3>\n<table>\n<thead>\n<tr>\n<th>용어</th>\n<th>설명</th>\n<th>위치</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>페이지 (Page)</td>\n<td>논리 주소 공간을 나눈 단위</td>\n<td>논리 메모리</td>\n</tr>\n<tr>\n<td>프레임 (Frame)</td>\n<td>물리 주소 공간을 나눈 단위</td>\n<td>물리 메모리</td>\n</tr>\n</tbody>\n</table>\n<h4 id=\"5-1-페이징의-핵심-특징\">5-1 페이징의 핵심 특징</h4>\n<p><strong>🔑 불연속 할당</strong></p>\n<p>프로세스를 구성하는 페이지는 물리 메모리 내에 <strong>불연속적으로 배치</strong>될 수 있다.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">논리 주소: [페이지 0][페이지 1][페이지 2][페이지 3]\n             ↓       ↓       ↓       ↓\n물리 주소: [프레임 5][프레임 2][프레임 7][프레임 1]</code></pre></div>\n<p><strong>✅ 외부 단편화 해결</strong></p>\n<p>페이지라는 일정한 크기로 프로세스를 분할하여 불연속적으로 할당하면, 연속 메모리 할당처럼 프로세스 바깥에 빈 공간이 생기지 않는다.</p>\n<h3 id=\"페이징에서의-스와핑\">페이징에서의 스와핑</h3>\n<p>페이징 시스템에서는 프로세스 전체가 아닌 <strong>페이지 단위</strong>로 스왑 인/아웃된다.</p>\n<table>\n<thead>\n<tr>\n<th>용어</th>\n<th>설명</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>페이지 아웃 (Page Out)</td>\n<td>페이지를 메모리에서 스왑 영역으로 이동</td>\n</tr>\n<tr>\n<td>페이지 인 (Page In)</td>\n<td>페이지를 스왑 영역에서 메모리로 이동</td>\n</tr>\n</tbody>\n</table>\n<h4 id=\"5-2-메모리보다-큰-프로세스-실행\">5-2 메모리보다 큰 프로세스 실행</h4>\n<p>프로세스의 일부 페이지는 메모리에, 일부는 보조기억장치에 적재될 수 있다.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">프로세스 A의 페이지:\n- 페이지 0, 1, 2: 메모리에 적재 (페이지 인)\n- 페이지 3, 4, 5: 보조기억장치에 적재 (페이지 아웃)</code></pre></div>\n<p>이는 <strong>프로세스 전체가 메모리에 적재될 필요가 없다</strong>는 것을 의미하며, CPU 입장에서 바라본 논리 메모리의 크기가 실제 메모리보다 클 수 있다.</p>\n<blockquote>\n<p>💡 <strong>세그멘테이션 (Segmentation)</strong></p>\n<p>세그멘테이션은 프로세스를 가변적인 크기의 세그먼트 단위로 분할하는 방식이다:</p>\n<ul>\n<li>유의미한 논리적 단위로 분할 (코드 영역, 데이터 영역 등)</li>\n<li>세그먼트의 크기가 일정하지 않아 외부 단편화 발생 가능</li>\n<li>페이징보다 논리적 구조를 반영하기 쉬움</li>\n</ul>\n</blockquote>\n<h2 id=\"6️-페이지-테이블-page-table\">6️⃣ 페이지 테이블 (Page Table)</h2>\n<p>물리 메모리 내에 페이지가 불연속적으로 배치되면, CPU는 다음으로 실행할 페이지의 위치를 찾기 어렵다. 이를 해결하기 위해 <code class=\"language-text\">페이지 테이블</code>을 사용한다.</p>\n<h3 id=\"페이지-테이블의-역할\">페이지 테이블의 역할</h3>\n<p><code class=\"language-text\">페이지 테이블</code>은 프로세스의 페이지와 실제로 적재된 프레임을 짝지어주는 정보다.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">페이지 번호 → 페이지 테이블 → 프레임 번호</code></pre></div>\n<h4 id=\"6-1-페이지-테이블의-특징\">6-1 페이지 테이블의 특징</h4>\n<ul>\n<li>페이지 번호와 프레임 번호가 대응됨</li>\n<li>프로세스마다 독립적인 페이지 테이블을 가짐</li>\n<li>CPU는 페이지 테이블을 참조하여 메모리에 접근</li>\n</ul>\n<h3 id=\"페이지-테이블-엔트리-pte\">페이지 테이블 엔트리 (PTE)</h3>\n<p><code class=\"language-text\">페이지 테이블 엔트리</code>는 페이지 테이블을 구성하는 각 행을 의미한다.</p>\n<h4 id=\"6-2-pte의-구성-요소\">6-2 PTE의 구성 요소</h4>\n<p><strong>유효 비트 (Valid Bit)</strong></p>\n<p>페이지가 메모리에 적재되어 있는지 여부를 나타낸다.</p>\n<table>\n<thead>\n<tr>\n<th>값</th>\n<th>의미</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>1</td>\n<td>페이지가 메모리에 적재됨</td>\n</tr>\n<tr>\n<td>0</td>\n<td>페이지가 보조기억장치에 적재됨</td>\n</tr>\n</tbody>\n</table>\n<p><strong>보호 비트 (Protection Bit)</strong></p>\n<p>페이지 접근 권한을 나타낸다.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">r (Read): 읽기 가능\nw (Write): 쓰기 가능\nx (Execute): 실행 가능\n\n예시:\n100 → 읽기만 가능\n111 → 읽기, 쓰기, 실행 모두 가능</code></pre></div>\n<p><strong>참조 비트 (Reference Bit)</strong></p>\n<p>CPU가 해당 페이지에 접근한 적이 있는지 여부를 나타낸다.</p>\n<table>\n<thead>\n<tr>\n<th>값</th>\n<th>의미</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>1</td>\n<td>CPU가 읽거나 쓴 페이지</td>\n</tr>\n<tr>\n<td>0</td>\n<td>적재 후 한 번도 접근하지 않은 페이지</td>\n</tr>\n</tbody>\n</table>\n<p><strong>수정 비트 (Modified Bit / Dirty Bit)</strong></p>\n<p>해당 페이지에 데이터를 쓴 적이 있는지 여부를 나타낸다.</p>\n<table>\n<thead>\n<tr>\n<th>값</th>\n<th>의미</th>\n<th>페이지 삭제 시 동작</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>1</td>\n<td>쓰기 작업을 한 페이지</td>\n<td>보조기억장치에 수정 내역 반영 필요</td>\n</tr>\n<tr>\n<td>0</td>\n<td>읽기만 한 페이지</td>\n<td>별도의 쓰기 작업 없이 삭제 가능</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"페이지-폴트-page-fault\">페이지 폴트 (Page Fault)</h3>\n<p><code class=\"language-text\">페이지 폴트</code>는 CPU가 메모리에 적재되지 않은 페이지(유효 비트가 0인 페이지)에 접근하려 할 때 발생하는 예외다.</p>\n<h4 id=\"6-3-페이지-폴트-처리-과정\">6-3 페이지 폴트 처리 과정</h4>\n<ol>\n<li>기존 작업 내역을 백업</li>\n<li>페이지 폴트 처리 루틴 실행\n<ul>\n<li>원하는 페이지를 메모리로 적재</li>\n<li>유효 비트를 1로 변경</li>\n</ul>\n</li>\n<li>메모리에 적재된 페이지를 실행</li>\n</ol>\n<p><strong>Windows에서 페이지 폴트 확인</strong></p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">리소스 모니터 → 메모리 탭 → 페이지 폴트/초</code></pre></div>\n<h3 id=\"내부-단편화-internal-fragmentation\">내부 단편화 (Internal Fragmentation)</h3>\n<p><code class=\"language-text\">내부 단편화</code>는 페이지 내부에서 발생하는 메모리 낭비를 의미한다.</p>\n<h4 id=\"6-4-내부-단편화-발생-원인\">6-4 내부 단편화 발생 원인</h4>\n<p>모든 프로세스의 크기가 페이지 크기의 배수가 아니기 때문에 발생한다.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">페이지 크기: 10KB\n프로세스 크기: 107KB\n\n필요한 페이지 수: 11개 (10KB × 10 + 7KB)\n마지막 페이지: 7KB만 사용, 3KB 낭비 ← 내부 단편화</code></pre></div>\n<blockquote>\n<p>💡 <strong>외부 단편화 vs 내부 단편화</strong></p>\n<table>\n<thead>\n<tr>\n<th>구분</th>\n<th>설명</th>\n<th>발생 위치</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>외부 단편화</td>\n<td>프로세스 바깥의 빈 공간</td>\n<td>연속 메모리 할당에서 발생</td>\n</tr>\n<tr>\n<td>내부 단편화</td>\n<td>페이지 내부의 낭비되는 공간</td>\n<td>페이징에서 발생</td>\n</tr>\n</tbody>\n</table>\n</blockquote>\n<h2 id=\"7️-페이지-테이블-관리\">7️⃣ 페이지 테이블 관리</h2>\n<h3 id=\"ptbr-page-table-base-register\">PTBR (Page Table Base Register)</h3>\n<p><code class=\"language-text\">PTBR</code>은 프로세스의 페이지 테이블이 적재된 메모리 상의 위치를 가리키는 레지스터다.</p>\n<h4 id=\"7-1-ptbr의-특징\">7-1 PTBR의 특징</h4>\n<ul>\n<li>프로세스마다 다른 값을 가짐</li>\n<li>PCB에 기록됨</li>\n<li>문맥 교환 시 변경됨</li>\n</ul>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">프로세스 A 실행: PTBR → 프로세스 A의 페이지 테이블\n프로세스 B 실행: PTBR → 프로세스 B의 페이지 테이블</code></pre></div>\n<h3 id=\"페이지-테이블-관리의-문제점\">페이지 테이블 관리의 문제점</h3>\n<p>모든 프로세스의 페이지 테이블을 메모리에 두는 것은 비효율적이다:</p>\n<ol>\n<li><strong>메모리 접근 횟수 증가</strong>: 페이지 테이블 접근 + 실제 프레임 접근 = 2회</li>\n<li><strong>메모리 용량 낭비</strong>: 페이지 테이블이 상당한 메모리 공간을 차지</li>\n</ol>\n<h4 id=\"7-2-tlb-translation-lookaside-buffer\">7-2 TLB (Translation Lookaside Buffer)</h4>\n<p><code class=\"language-text\">TLB</code>는 페이지 테이블의 캐시 메모리로, 자주 사용하는 페이지 테이블 엔트리를 저장한다.</p>\n<p><strong>🚀 TLB 동작 방식</strong></p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">TLB 히트 (TLB Hit):\n논리 주소 → TLB에서 프레임 번호 찾음 → 메모리 1회 접근\n\nTLB 미스 (TLB Miss):\n논리 주소 → TLB에 없음 → 페이지 테이블 확인 → 메모리 2회 접근</code></pre></div>\n<p><strong>✅ TLB의 장점</strong></p>\n<ul>\n<li>참조 지역성의 원리에 근거하여 동작</li>\n<li>TLB 히트 시 메모리 접근 횟수를 절반으로 감소</li>\n<li>TLB 히트율을 높이면 전체 성능 향상</li>\n</ul>\n<h4 id=\"7-3-계층적-페이징-hierarchical-paging\">7-3 계층적 페이징 (Hierarchical Paging)</h4>\n<p><code class=\"language-text\">계층적 페이징</code>은 페이지 테이블을 페이징하는 방식으로, <code class=\"language-text\">다단계 페이지 테이블</code>이라고도 한다.</p>\n<p><strong>🎯 계층적 페이징의 목적</strong></p>\n<p>페이지 테이블의 크기가 크므로 모든 페이지 테이블을 메모리에 유지하는 것은 메모리 낭비다. 계층적 페이징을 사용하면 필요한 페이지 테이블만 메모리에 유지할 수 있다.</p>\n<p><strong>📊 2단계 페이징 구조</strong></p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">Outer 페이지 테이블 (메모리에 항상 유지)\n    ↓\nInner 페이지 테이블 (필요 시 메모리에 적재)\n    ↓\n실제 프레임</code></pre></div>\n<p><strong>✅ 계층적 페이징의 장점</strong></p>\n<ul>\n<li>Outer 페이지 테이블만 메모리에 유지</li>\n<li>Inner 페이지 테이블의 일부는 보조기억장치에 저장 가능</li>\n<li>메모리 사용량 감소</li>\n</ul>\n<blockquote>\n<p>💡 <strong>다단계 페이징</strong></p>\n<p>페이지 테이블의 계층은 2단계뿐만 아니라 3단계, 4단계, 그 이상으로도 구성될 수 있다. 계층이 깊어질수록 메모리 사용량은 감소하지만, 메모리 접근 횟수는 증가한다.</p>\n</blockquote>\n<h2 id=\"8️-페이징-주소-체계\">8️⃣ 페이징 주소 체계</h2>\n<p>페이징 시스템의 논리 주소는 <code class=\"language-text\">&lt;페이지 번호, 변위></code>의 형태로 구성된다.</p>\n<h3 id=\"논리-주소의-구성\">논리 주소의 구성</h3>\n<table>\n<thead>\n<tr>\n<th>구성 요소</th>\n<th>설명</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>페이지 번호 (Page Number)</td>\n<td>접근할 페이지 번호 (페이지 테이블의 인덱스)</td>\n</tr>\n<tr>\n<td>변위 (Offset)</td>\n<td>페이지 시작 번지로부터의 거리</td>\n</tr>\n</tbody>\n</table>\n<h4 id=\"8-1-주소-변환-과정\">8-1 주소 변환 과정</h4>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">논리 주소: &lt;페이지 번호, 변위>\n    ↓\n페이지 테이블 참조\n    ↓\n물리 주소: &lt;프레임 번호, 변위></code></pre></div>\n<h3 id=\"주소-변환-예시\">주소 변환 예시</h3>\n<p>다음과 같은 상황을 가정한다:</p>\n<ul>\n<li>하나의 페이지/프레임: 4개의 주소로 구성</li>\n<li>페이지 테이블:\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">페이지 0 → 프레임 5\n페이지 1 → 프레임 4\n페이지 2 → 프레임 6\n페이지 3 → 프레임 2\n페이지 4 → 프레임 7\n페이지 5 → 프레임 1</code></pre></div>\n</li>\n</ul>\n<h4 id=\"8-2-주소-변환-계산\">8-2 주소 변환 계산</h4>\n<p>CPU가 논리 주소 <code class=\"language-text\">&lt;5, 2></code>에 접근하는 경우:</p>\n<ol>\n<li>페이지 5는 프레임 1에 적재됨</li>\n<li>프레임 1은 물리 주소 8번지부터 시작 (1 × 4 = 4번지부터 시작하는 프레임 1)</li>\n<li>변위 2를 더하면 10번지</li>\n<li><strong>최종 물리 주소: 10번지</strong></li>\n</ol>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">논리 주소 &lt;5, 2>\n    ↓\n페이지 5 → 프레임 1 (물리 주소 8번지~11번지)\n    ↓\n물리 주소: 8번지 + 2 = 10번지</code></pre></div>\n<h2 id=\"9️-요구-페이징-demand-paging\">9️⃣ 요구 페이징 (Demand Paging)</h2>\n<p><code class=\"language-text\">요구 페이징</code>은 메모리에 필요한(요구되는) 페이지만을 적재하는 기법이다.</p>\n<h3 id=\"요구-페이징의-동작-방식\">요구 페이징의 동작 방식</h3>\n<ol>\n<li>CPU가 특정 페이지에 접근하는 명령어를 실행</li>\n<li><strong>페이지가 메모리에 있는 경우</strong> (유효 비트 = 1):\n<ul>\n<li>CPU는 페이지가 적재된 프레임에 접근</li>\n</ul>\n</li>\n<li><strong>페이지가 메모리에 없는 경우</strong> (유효 비트 = 0):\n<ul>\n<li>페이지 폴트 발생</li>\n<li>페이지 폴트 처리 루틴 실행</li>\n<li>해당 페이지를 메모리로 적재</li>\n<li>유효 비트를 1로 설정</li>\n</ul>\n</li>\n<li>1번 과정 재수행</li>\n</ol>\n<h4 id=\"9-1-순수-요구-페이징-pure-demand-paging\">9-1 순수 요구 페이징 (Pure Demand Paging)</h4>\n<p><code class=\"language-text\">순수 요구 페이징</code>은 아무런 페이지도 메모리에 적재하지 않은 채 프로세스를 실행하는 방식이다.</p>\n<p><strong>📊 순수 요구 페이징의 특징</strong></p>\n<ul>\n<li>프로세스의 첫 명령어 실행 순간부터 페이지 폴트 발생</li>\n<li>실행에 필요한 페이지가 어느 정도 적재된 후 페이지 폴트 발생 빈도 감소</li>\n</ul>\n<h3 id=\"페이지-교체의-필요성\">페이지 교체의 필요성</h3>\n<p>요구 페이징을 통해 페이지를 메모리에 적재하다 보면 언젠가는 메모리가 가득 찬다. 메모리가 가득 찬 상황에서 추가로 페이지를 적재하려면 <strong>일부 페이지를 스왑 아웃</strong>해야 한다.</p>\n<h2 id=\"-페이지-교체-알고리즘\">🔟 페이지 교체 알고리즘</h2>\n<p><code class=\"language-text\">페이지 교체 알고리즘</code>은 메모리에서 보조기억장치로 내보낼 페이지를 선택하는 방법이다.</p>\n<h3 id=\"페이지-교체-알고리즘의-중요성\">페이지 교체 알고리즘의 중요성</h3>\n<p>좋은 페이지 교체 알고리즘은 <strong>페이지 폴트의 발생 빈도를 줄인다</strong>:</p>\n<ul>\n<li>좋은 알고리즘: 사용되지 않을 페이지를 내보냄 → 페이지 폴트 적음</li>\n<li>나쁜 알고리즘: 곧 사용될 페이지를 내보냄 → 페이지 폴트 빈번</li>\n</ul>\n<p><strong>⚠️ 스래싱 (Thrashing)</strong></p>\n<p>지나친 페이지 교체로 인해 프로세스가 실제 실행되는 시간보다 페이징에 더 많은 시간을 소요하여 성능이 저하되는 문제를 <code class=\"language-text\">스래싱</code>이라고 한다.</p>\n<h3 id=\"fifo-first-in-first-out\">FIFO (First-In-First-Out)</h3>\n<p><code class=\"language-text\">FIFO 페이지 교체 알고리즘</code>은 메모리에 가장 먼저 적재된 페이지부터 스왑 아웃하는 알고리즘이다.</p>\n<h4 id=\"10-1-fifo의-특징\">10-1 FIFO의 특징</h4>\n<p><strong>✅ 장점</strong></p>\n<ul>\n<li>아이디어와 구현이 간단함</li>\n</ul>\n<p><strong>⚠️ 단점</strong></p>\n<ul>\n<li>초기에 적재되어 줄곧 참조되고 있는 페이지를 스왑 아웃할 우려</li>\n<li>머지않아 페이지 폴트 발생 가능</li>\n</ul>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">메모리 상태: [페이지 1][페이지 2][페이지 3]\n새 페이지 4 적재 시: 페이지 1 교체 (가장 먼저 적재됨)\n→ 페이지 1이 자주 사용되는 페이지라면 비효율적</code></pre></div>\n<h3 id=\"최적-optimal\">최적 (Optimal)</h3>\n<p><code class=\"language-text\">최적 페이지 교체 알고리즘</code>은 앞으로의 사용 빈도가 가장 낮은 페이지를 교체하는 알고리즘이다.</p>\n<h4 id=\"10-2-최적-알고리즘의-특징\">10-2 최적 알고리즘의 특징</h4>\n<p><strong>✅ 장점</strong></p>\n<ul>\n<li>가장 낮은 페이지 폴트율 보장</li>\n<li>이론적으로 최적의 성능</li>\n</ul>\n<p><strong>⚠️ 단점</strong></p>\n<ul>\n<li>앞으로 가장 적게 사용할 페이지를 미리 예측하기 어려움</li>\n<li>실제 구현이 어려움</li>\n</ul>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">미래의 페이지 참조 순서를 알 수 없으므로\n실제로는 구현 불가능</code></pre></div>\n<h3 id=\"lru-least-recently-used\">LRU (Least Recently Used)</h3>\n<p><code class=\"language-text\">LRU 페이지 교체 알고리즘</code>은 가장 오래 사용하지 않은 페이지를 교체하는 알고리즘이다.</p>\n<h4 id=\"10-3-lru의-특징\">10-3 LRU의 특징</h4>\n<p><strong>🎯 핵심 아이디어</strong></p>\n<p>최적 알고리즘이 \"앞으로 가장 적게 사용할\" 페이지를 교체한다면, LRU는 \"과거에 가장 적게 사용한\" 페이지를 교체한다.</p>\n<p><strong>✅ 장점</strong></p>\n<ul>\n<li>참조 지역성의 원리를 활용</li>\n<li>최근에 사용된 페이지는 앞으로도 사용될 가능성이 높다는 가정</li>\n<li>실제로 구현 가능하며 효율적</li>\n<li>가장 보편적으로 사용됨</li>\n</ul>\n<p><strong>📊 LRU 동작 예시</strong></p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">메모리 상태: [페이지 1 (10초 전)][페이지 2 (5초 전)][페이지 3 (1초 전)]\n새 페이지 4 적재 시: 페이지 1 교체 (가장 오래 전에 사용됨)</code></pre></div>\n<blockquote>\n<p>💡 <strong>페이지 교체 알고리즘 비교</strong></p>\n<table>\n<thead>\n<tr>\n<th>알고리즘</th>\n<th>기준</th>\n<th>장점</th>\n<th>단점</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>FIFO</td>\n<td>적재 순서</td>\n<td>구현 간단</td>\n<td>자주 사용하는 페이지도 교체 가능</td>\n</tr>\n<tr>\n<td>최적</td>\n<td>미래 사용 빈도</td>\n<td>최적의 성능</td>\n<td>구현 불가능</td>\n</tr>\n<tr>\n<td>LRU</td>\n<td>과거 사용 시점</td>\n<td>실용적이고 효율적</td>\n<td>구현 복잡도가 상대적으로 높음</td>\n</tr>\n</tbody>\n</table>\n</blockquote>\n<h2 id=\"정리\">정리</h2>\n<p>가상 메모리의 핵심 개념을 정리하면 다음과 같다:</p>\n<p><strong>주소 체계</strong></p>\n<ul>\n<li><strong>논리 주소</strong>: 프로세스가 사용하는 0번지부터 시작하는 주소</li>\n<li><strong>물리 주소</strong>: 메모리의 실제 주소</li>\n<li><strong>MMU</strong>: 논리 주소를 물리 주소로 변환하는 하드웨어</li>\n</ul>\n<p><strong>메모리 관리 기법</strong></p>\n<ul>\n<li><strong>스와핑</strong>: 프로세스를 메모리와 보조기억장치 간에 이동</li>\n<li><strong>페이징</strong>: 일정한 크기의 페이지/프레임 단위로 메모리 관리</li>\n<li><strong>요구 페이징</strong>: 필요한 페이지만 메모리에 적재</li>\n</ul>\n<p><strong>페이지 테이블</strong></p>\n<ul>\n<li>페이지와 프레임을 매핑하는 정보</li>\n<li>PTE에는 유효 비트, 보호 비트, 참조 비트, 수정 비트 포함</li>\n<li>PTBR로 페이지 테이블의 위치 관리</li>\n<li>TLB로 페이지 테이블 접근 속도 향상</li>\n</ul>\n<p><strong>페이지 교체 알고리즘</strong></p>\n<ul>\n<li><strong>FIFO</strong>: 먼저 적재된 페이지를 교체</li>\n<li><strong>최적</strong>: 앞으로 가장 적게 사용할 페이지를 교체 (이론적)</li>\n<li><strong>LRU</strong>: 가장 오래 사용하지 않은 페이지를 교체 (실용적)</li>\n</ul>","fields":{"slug":"/os-virtual-memory/"},"frontmatter":{"title":"[운영체제] 5. 가상 메모리","date":"2026-01-26","description":"이것이 취업을 위한 컴퓨터 과학이다 + 혼자 공부하는 컴퓨터 구조/운영체제를 읽으면서 배운 내용을 정리합니다.","pointColor":"#ffffff","tags":["운영체제"],"keywords":"운영체제, OS, 가상메모리, 페이징, 페이지테이블, MMU, TLB, 페이지폴트, 페이지교체알고리즘, FIFO, LRU","thumbnail":{"publicURL":"/static/3a1b802e67c087a7a9f25e9555b620d4/index.png","childImageSharp":{"gatsbyImageData":{"layout":"fixed","placeholder":{"fallback":"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAKCAYAAAC0VX7mAAAACXBIWXMAACE4AAAhOAFFljFgAAABQElEQVR42mNgqCz7jw0zAjFTVfl/RiAG0UzVFQg2VByrXlwGMpQV/2coyv/PUFyAoGEYxC8tIs5AkMsYyov/y7S3/vecP/e/xbQp/70WzP1vP2sGmG03a/p/93lz/mv09YAtxXApuoHMIAVAF4QsXfx/9+3b/6t27vi/5cb1/32HD/1fcPbM/66DB/6vvHTxf/La1WB1zIQMBIUPyDuGkyaADdWf0AemzYGucwO6zH3ebLCLTaZMAqsj6EI4BoURMLyYQGFZmAcJt4JcBLukkIQwBBqi0tP5X7Cx/r9yd+d/m5nT/hsAXewweyY4XE2nTgKHJ2t15X+GilJiIqXkv3hrExiLAbEO0NugSNDu7/1vM2M60MDJ/9V6u4AGVhA2EG4wSCEIAw0H44oSSFICYZgYSekQ7uJyiKuhrodhXHoAPvWaons1dJgAAAAASUVORK5CYII="},"backgroundColor":"transparent","images":{"fallback":{"src":"/static/3a1b802e67c087a7a9f25e9555b620d4/a1758/index.png","srcSet":"/static/3a1b802e67c087a7a9f25e9555b620d4/a1758/index.png 1200w","sizes":"1200px"},"sources":[{"srcSet":"/static/3a1b802e67c087a7a9f25e9555b620d4/afc39/index.webp 1200w","type":"image/webp","sizes":"1200px"}]},"width":1200,"height":585},"fixed":{"src":"/static/3a1b802e67c087a7a9f25e9555b620d4/f3583/index.png"}}}}},"previous":{"fields":{"slug":"/os-cpu-scheduling/"},"frontmatter":{"title":"[운영체제] 4. CPU 스케줄링"}},"next":{"fields":{"slug":"/os-file-system/"},"frontmatter":{"title":"[운영체제] 파일 시스템"}}},"pageContext":{"id":"dc18f114-802b-5431-b431-81f1c9a487d3","previousPostId":"9e765125-acd0-5406-b767-ae2e8bd61808","nextPostId":"85cfd330-990b-5ed0-badd-a1cfe5351de4"}},"staticQueryHashes":["736397157"],"slicesMap":{}}