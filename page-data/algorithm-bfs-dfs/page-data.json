{"componentChunkName":"component---src-templates-blog-post-js","path":"/algorithm-bfs-dfs/","result":{"data":{"site":{"siteMetadata":{"title":"홈","siteUrl":"https://inyoung.dev","author":{"name":"Inyoung Chung"}}},"allMarkdownRemark":{"nodes":[{"fields":{"slug":"/[트러블슈팅] Supabase를 활용한 인증, 인가/"},"frontmatter":{"title":"[트러블슈팅] Supabase Auth를 활용한 다양한 환경에서의 세션 유지","date":"2026-02-10","tags":["Web","회고"],"pointColor":"#3ECF8D"}},{"fields":{"slug":"/waterfall-agile/"},"frontmatter":{"title":"[소프트웨어공학] Waterfall과 Agile","date":"2026-02-03","tags":["소프트웨어공학"],"pointColor":"#ffffff"}},{"fields":{"slug":"/os-file-system/"},"frontmatter":{"title":"[운영체제] 파일 시스템","date":"2026-01-27","tags":["운영체제"],"pointColor":"#ffffff"}},{"fields":{"slug":"/os-virtual-memory/"},"frontmatter":{"title":"[운영체제] 5. 가상 메모리","date":"2026-01-26","tags":["운영체제"],"pointColor":"#ffffff"}},{"fields":{"slug":"/os-cpu-scheduling/"},"frontmatter":{"title":"[운영체제] 4. CPU 스케줄링","date":"2026-01-25","tags":["운영체제"],"pointColor":"#ffffff"}},{"fields":{"slug":"/os-synchronization-deadlock/"},"frontmatter":{"title":"[운영체제] 3. 동기화와 교착 상태","date":"2026-01-24","tags":["운영체제"],"pointColor":"#ffffff"}},{"fields":{"slug":"/os-process-thread/"},"frontmatter":{"title":"[운영체제] 2. 프로세스와 스레드","date":"2026-01-23","tags":["운영체제"],"pointColor":"#ffffff"}},{"fields":{"slug":"/os-big-picture/"},"frontmatter":{"title":"[운영체제] 1. 운영체제의 큰 그림","date":"2026-01-21","tags":["운영체제"],"pointColor":"#ffffff"}},{"fields":{"slug":"/computer-architecture-cpu/"},"frontmatter":{"title":"[컴퓨터구조] 3. CPU","date":"2026-01-18","tags":["컴퓨터구조"],"pointColor":"#ffffff"}},{"fields":{"slug":"/computer-architecture-computer-information/"},"frontmatter":{"title":"[컴퓨터구조] 2. 컴퓨터가 이해하는 정보","date":"2026-01-17","tags":["컴퓨터구조"],"pointColor":"#ffffff"}},{"fields":{"slug":"/computer-architecture-big-picture/"},"frontmatter":{"title":"[컴퓨터구조] 1. 컴퓨터구조의 큰 그림","date":"2026-01-15","tags":["컴퓨터구조"],"pointColor":"#ffffff"}},{"fields":{"slug":"/java-coding-test-grammer/"},"frontmatter":{"title":"Java 코딩테스트 문법 최종 정리","date":"2026-01-08","tags":["알고리즘"],"pointColor":"#ed8b00"}},{"fields":{"slug":"/lg-webos-tv-fullstack-appliaction/"},"frontmatter":{"title":"WebOS TV에 들어갈 풀스택 애플리케이션을 만들어보자 (LG전자 산학 프로젝트 후기)","date":"2025-12-22","tags":["회고"],"pointColor":"#ffffff"}},{"fields":{"slug":"/algorithm-maximum-flow/"},"frontmatter":{"title":"알고리즘설계와분석 - 최대 유량 문제 (Maximum Flow)","date":"2025-12-16","tags":["알고리즘"],"pointColor":"#ffffff"}},{"fields":{"slug":"/algorithm-shortest-path/"},"frontmatter":{"title":"알고리즘설계와분석 - 최단경로 (Shortest Path)","date":"2025-12-13","tags":["알고리즘"],"pointColor":"#ffffff"}},{"fields":{"slug":"/algorithm-minimum-spanning-tree/"},"frontmatter":{"title":"알고리즘설계와분석 - MST (최소신장트리)","date":"2025-12-12","tags":["알고리즘"],"pointColor":"#ffffff"}},{"fields":{"slug":"/algorithm-bfs-dfs/"},"frontmatter":{"title":"알고리즘설계와분석 - BFS/DFS와 Topological Sort","date":"2025-12-11","tags":["알고리즘"],"pointColor":"#ffffff"}},{"fields":{"slug":"/algorithm-greedy-algorithm/"},"frontmatter":{"title":"알고리즘설계와분석 - Greedy algorithm (그리디 알고리즘)","date":"2025-12-10","tags":["알고리즘"],"pointColor":"#ffffff"}},{"fields":{"slug":"/algorithm-dynamic-programming/"},"frontmatter":{"title":"알고리즘설계와분석 - Dynamic Programming (동적 계획법)","date":"2025-12-07","tags":["알고리즘"],"pointColor":"#ffffff"}},{"fields":{"slug":"/algorithm-binary-search-tree/"},"frontmatter":{"title":"알고리즘설계와분석 - Binary Search Tree (이진 탐색 트리)","date":"2025-12-05","tags":["알고리즘"],"pointColor":"#ffffff"}},{"fields":{"slug":"/database-system-erd/"},"frontmatter":{"title":"데이터베이스 시스템 개론 📚 - Chapter2. ERD로 데이터베이스 설계하기","date":"2025-10-05","tags":["DB"],"pointColor":"#ffffff"}},{"fields":{"slug":"/make-huggingface-pipeline/"},"frontmatter":{"title":"허깅페이스로 파이프라인을 만들어보자 - 트랜스포머 모델 활용 가이드","date":"2025-10-04","tags":["AI"],"pointColor":"#FF9A00"}},{"fields":{"slug":"/rag-core-concept/"},"frontmatter":{"title":"RAG의 핵심 개념과 실습","date":"2025-10-01","tags":["AI"],"pointColor":"#FF6B6B"}},{"fields":{"slug":"/prompt-engineering-basic/"},"frontmatter":{"title":"프롬프트 엔지니어링 기초 - AI와 효과적으로 소통하는 방법","date":"2025-09-28","tags":["AI"],"pointColor":"#ffffff"}},{"fields":{"slug":"/how-to-use-flutter-riverpod/"},"frontmatter":{"title":"초심자 입장에서 Flutter Riverpod을 '잘' 사용하는 방법 (장문)","date":"2025-09-20","tags":["Flutter"],"pointColor":"#0468d7"}},{"fields":{"slug":"/database-system-introduction/"},"frontmatter":{"title":"데이터베이스 시스템 개론 📚 – Chapter 1. Introduction of Database Systems","date":"2025-09-16","tags":["DB"],"pointColor":"#ffffff"}},{"fields":{"slug":"/kakaobank-devrel-internship-retrospect/"},"frontmatter":{"title":"서비스 개발부터 DevRel까지: 카카오뱅크 인턴쉽 회고","date":"2025-07-28","tags":["인턴","회고","카카오뱅크","네이버랩스"],"pointColor":"#ffe300"}},{"fields":{"slug":"/my-it-startup-internship-retrospect/"},"frontmatter":{"title":"나의 IT 스타트업 인턴쉽 회고","date":"2025-03-14","tags":["인턴","회고"],"pointColor":"#6FE7FF"}},{"fields":{"slug":"/sogang-likelion-management-retrospect/"},"frontmatter":{"title":"서강대학교 멋쟁이사자처럼 운영진 회고","date":"2025-02-27","tags":["멋쟁이사자처럼","회고"],"pointColor":"#FD7911"}}]},"markdownRemark":{"id":"c3f8c648-5cf2-578a-b827-89342247108b","excerpt":"학부 수업 \"알고리즘설계와분석\" 내용을 정리한다. 1️⃣ BFS (Breadth-First Search) BFS 핵심 개념 1-1 BFS란? BFS는 그래프 탐색 알고리즘으로, 거리(distance) 기준으로 정점을 계층별로 방문한다. 출발점 S…","html":"<blockquote>\n<p>학부 수업 \"알고리즘설계와분석\" 내용을 정리한다.</p>\n</blockquote>\n<h2 id=\"1️-bfs-breadth-first-search\">1️⃣ BFS (Breadth-First Search)</h2>\n<h3 id=\"bfs-핵심-개념\">BFS 핵심 개념</h3>\n<h4 id=\"1-1-bfs란\">1-1 BFS란?</h4>\n<p>BFS는 그래프 탐색 알고리즘으로, <strong>거리(distance)</strong> 기준으로 정점을 계층별로 방문한다. 출발점 S에서 시작해 인접한 정점들을 단계적으로 탐색하는 방식이다.</p>\n<p>🔥 <strong>Wave 기반 탐색</strong></p>\n<p>BFS는 파동(wave)처럼 확장되며 탐색을 진행한다.</p>\n<ul>\n<li>출발점 S에서 시작</li>\n<li>S와 인접한 정점들(거리 1) 먼저 탐색</li>\n<li>그 다음 거리 2인 정점들 탐색</li>\n<li>거리 k → k+1 순서로 wavefront 확장</li>\n</ul>\n<p>이러한 특성으로 인해 BFS는 <strong>unweighted graph에서 최단 경로</strong>를 보장한다.</p>\n<h4 id=\"1-2-bfs가-생성하는-정보\">1-2 BFS가 생성하는 정보</h4>\n<p>BFS는 탐색 과정에서 각 정점에 대해 다음 정보를 제공한다.</p>\n<p><strong><code class=\"language-text\">v.d</code> (distance)</strong></p>\n<ul>\n<li>S에서 v까지의 최단 거리</li>\n<li>거리는 간선 개수로 측정</li>\n<li>BFS 실행 중 점진적으로 갱신됨</li>\n</ul>\n<p><strong><code class=\"language-text\">v.π</code> (predecessor)</strong></p>\n<ul>\n<li>v의 부모 정점</li>\n<li>BFS 트리에서 v를 처음 발견하게 한 정점</li>\n<li>parent chain을 따라가면 S→v 최단 경로를 복원할 수 있음</li>\n</ul>\n<p><strong>Predecessor subgraph = BFS Tree</strong></p>\n<ul>\n<li>BFS로 만든 parent 구조는 트리가 된다</li>\n<li>트리의 간선들은 최단 경로를 구성하는 간선들만 포함한다</li>\n<li>이를 <strong>최단 경로 트리(shortest path tree)</strong> 라고 한다</li>\n</ul>\n<h3 id=\"bfs-알고리즘-구조\">BFS 알고리즘 구조</h3>\n<h4 id=\"1-3-자료구조와-색상-관리\">1-3 자료구조와 색상 관리</h4>\n<p>🔥 <strong>큐(FIFO Queue)</strong></p>\n<p>BFS는 큐를 사용하여 방문할 정점들을 관리한다. 큐의 FIFO 특성으로 인해 거리 순서가 자동으로 보장된다.</p>\n<ul>\n<li>큐에는 항상 거리 k와 k+1인 정점들만 존재</li>\n<li>먼저 발견된 정점이 먼저 처리됨</li>\n</ul>\n<p>🔥 <strong>색상(Color) 시스템</strong></p>\n<p>BFS는 세 가지 색상으로 정점의 상태를 관리한다.</p>\n<ul>\n<li><code class=\"language-text\">white</code>: 아직 방문되지 않은 정점</li>\n<li><code class=\"language-text\">gray</code>: 발견되어 큐에 들어간 정점</li>\n<li><code class=\"language-text\">black</code>: 탐색이 완료된 정점</li>\n</ul>\n<p>정점은 항상 <strong>white → gray → black</strong> 순서로 상태가 변한다.</p>\n<h4 id=\"1-4-bfs-의사코드\">1-4 BFS 의사코드</h4>\n<div class=\"gatsby-highlight\" data-language=\"python\"><pre class=\"language-python\"><code class=\"language-python\"><span class=\"token comment\"># 초기화</span>\n<span class=\"token keyword\">for</span> each vertex v <span class=\"token keyword\">in</span> G<span class=\"token punctuation\">.</span>V <span class=\"token operator\">-</span> <span class=\"token punctuation\">{</span>S<span class=\"token punctuation\">}</span><span class=\"token punctuation\">:</span>\n    v<span class=\"token punctuation\">.</span>color <span class=\"token operator\">=</span> white\n    v<span class=\"token punctuation\">.</span>d <span class=\"token operator\">=</span> ∞\n    v<span class=\"token punctuation\">.</span>π <span class=\"token operator\">=</span> nil\n\nS<span class=\"token punctuation\">.</span>color <span class=\"token operator\">=</span> gray\nS<span class=\"token punctuation\">.</span>d <span class=\"token operator\">=</span> <span class=\"token number\">0</span>\nS<span class=\"token punctuation\">.</span>π <span class=\"token operator\">=</span> nil\nQ <span class=\"token operator\">=</span> empty queue\nenqueue<span class=\"token punctuation\">(</span>Q<span class=\"token punctuation\">,</span> S<span class=\"token punctuation\">)</span>\n\n<span class=\"token comment\"># 메인 루프</span>\n<span class=\"token keyword\">while</span> Q ≠ ∅<span class=\"token punctuation\">:</span>\n    u <span class=\"token operator\">=</span> dequeue<span class=\"token punctuation\">(</span>Q<span class=\"token punctuation\">)</span>\n    <span class=\"token keyword\">for</span> each v <span class=\"token keyword\">in</span> G<span class=\"token punctuation\">.</span>Adj<span class=\"token punctuation\">[</span>u<span class=\"token punctuation\">]</span><span class=\"token punctuation\">:</span>  <span class=\"token comment\"># u의 모든 인접 정점</span>\n        <span class=\"token keyword\">if</span> v<span class=\"token punctuation\">.</span>color <span class=\"token operator\">==</span> white<span class=\"token punctuation\">:</span>  <span class=\"token comment\"># 처음 발견한 정점</span>\n            v<span class=\"token punctuation\">.</span>color <span class=\"token operator\">=</span> gray\n            v<span class=\"token punctuation\">.</span>d <span class=\"token operator\">=</span> u<span class=\"token punctuation\">.</span>d <span class=\"token operator\">+</span> <span class=\"token number\">1</span>\n            v<span class=\"token punctuation\">.</span>π <span class=\"token operator\">=</span> u\n            enqueue<span class=\"token punctuation\">(</span>Q<span class=\"token punctuation\">,</span> v<span class=\"token punctuation\">)</span>\n    u<span class=\"token punctuation\">.</span>color <span class=\"token operator\">=</span> black  <span class=\"token comment\"># 탐색 완료</span></code></pre></div>\n<h4 id=\"1-5-bfs-동작-예시\">1-5 BFS 동작 예시</h4>\n<p>다음과 같은 그래프에서 S를 출발점으로 BFS를 수행한다고 가정하자.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">S --- R --- T\n|     |     |\nU --- V     W --- X\n|           |\nY           Z</code></pre></div>\n<p><strong>탐색 과정:</strong></p>\n<ol>\n<li>S에서 시작, S와 인접한 R, U, V 발견 → 거리 = 1 → 큐에 삽입</li>\n<li>S는 black으로 변경</li>\n<li>큐에서 R 꺼냄 → 인접한 W, T 발견 → 거리 = 2 → 큐 삽입</li>\n<li>R은 black으로 변경</li>\n<li>큐에서 U 꺼냄 → white인 Y 발견 → 거리 = 2 → 큐 삽입</li>\n<li>U는 black으로 변경</li>\n<li>큐에서 V 꺼냄 → 모든 이웃이 이미 방문됨 → 변화 없음</li>\n<li>큐에서 T 꺼냄 → white 없음 → 변화 없음</li>\n<li>큐에서 W 꺼냄 → X, Z 발견 → 거리 3 → gray → 큐 삽입</li>\n<li>큐가 빌 때까지 반복</li>\n</ol>\n<p>최종적으로 모든 reachable 정점이 black 상태가 되며 탐색이 완료된다.</p>\n<h3 id=\"bfs-성능-분석\">BFS 성능 분석</h3>\n<h4 id=\"1-6-시간-복잡도\">1-6 시간 복잡도</h4>\n<p>BFS의 시간 복잡도는 그래프 표현 방식에 따라 결정된다. adjacency list를 사용할 때 가장 효율적이다.</p>\n<p><strong>초기화 단계</strong></p>\n<ul>\n<li>모든 정점에 대해 색상, 거리, 부모 설정</li>\n<li>시간 복잡도: <code class=\"language-text\">O(V)</code></li>\n</ul>\n<p><strong>큐 연산</strong></p>\n<ul>\n<li>각 정점은 최대 한 번 enqueue &#x26; dequeue</li>\n<li>시간 복잡도: <code class=\"language-text\">O(V)</code></li>\n</ul>\n<p><strong>인접 리스트 스캔</strong></p>\n<ul>\n<li>각 간선 (u,v)는 최대 한 번씩만 확인됨</li>\n<li>시간 복잡도: <code class=\"language-text\">O(E)</code></li>\n</ul>\n<p><strong>최종 시간 복잡도: <code class=\"language-text\">O(V + E)</code></strong></p>\n<p>이는 그래프 탐색에서 가장 효율적인 형태 중 하나이다.</p>\n<h3 id=\"bfs-정확성-증명\">BFS 정확성 증명</h3>\n<h4 id=\"1-7-bfs가-최단-경로를-찾는-이유\">1-7 BFS가 최단 경로를 찾는 이유</h4>\n<p>🔥 <strong>핵심 명제</strong></p>\n<p>모든 간선 (u, v)에 대해 다음 부등식이 성립한다.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">δ(S, v) ≤ δ(S, u) + 1</code></pre></div>\n<p>여기서 <code class=\"language-text\">δ(S, v)</code>는 S에서 v까지의 최단 거리를 의미한다.</p>\n<p><strong>직관적 이해:</strong></p>\n<ul>\n<li>S→u까지 최단 경로 뒤에 u→v 간선 하나만 추가하면 S→v에 도달 가능</li>\n<li>따라서 v까지의 최단 경로는 u까지의 최단 경로보다 최대 1만 크다</li>\n</ul>\n<p>🔥 <strong>모순법을 이용한 증명</strong></p>\n<p>BFS가 올바른 최단 거리를 계산하지 못한다고 가정하자.</p>\n<ol>\n<li>BFS가 <code class=\"language-text\">v.d</code>를 최단 거리 <code class=\"language-text\">δ(S,v)</code>와 다르게 설정한 정점 v 중, <code class=\"language-text\">δ(S,v)</code>가 가장 작은 정점을 선택</li>\n<li>v의 실제 최단 경로 상의 parent를 u라고 하면, <code class=\"language-text\">δ(S,v) = δ(S,u) + 1</code></li>\n<li>v가 가장 작은 최단 거리를 가진 오류 정점이므로, u는 올바른 거리를 가짐: <code class=\"language-text\">u.d = δ(S,u)</code></li>\n<li>BFS 알고리즘 절차를 분석하면:\n<ul>\n<li><strong>v가 white일 때:</strong> u를 처리할 때 <code class=\"language-text\">v.d = u.d + 1 = δ(S,u) + 1 = δ(S,v)</code>로 올바르게 설정됨 → 모순</li>\n<li><strong>v가 black일 때:</strong> v가 u보다 먼저 처리됨 → <code class=\"language-text\">v.d ≤ u.d</code> → 거리 관계 모순</li>\n<li><strong>v가 gray일 때:</strong> v가 더 일찍 발견됨 → <code class=\"language-text\">v.d ≤ u.d + 1 = δ(S,v)</code> → 모순</li>\n</ul>\n</li>\n</ol>\n<p>모든 경우에서 모순이 발생하므로 BFS는 항상 최단 거리를 올바르게 계산한다.</p>\n<h4 id=\"1-8-최단-경로-복원\">1-8 최단 경로 복원</h4>\n<p>BFS가 생성한 predecessor 정보를 이용하여 실제 최단 경로를 복원할 수 있다.</p>\n<div class=\"gatsby-highlight\" data-language=\"python\"><pre class=\"language-python\"><code class=\"language-python\"><span class=\"token keyword\">def</span> <span class=\"token function\">print_path</span><span class=\"token punctuation\">(</span>s<span class=\"token punctuation\">,</span> v<span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span>\n    <span class=\"token keyword\">if</span> v <span class=\"token operator\">==</span> s<span class=\"token punctuation\">:</span>\n        <span class=\"token keyword\">print</span><span class=\"token punctuation\">(</span>s<span class=\"token punctuation\">)</span>\n    <span class=\"token keyword\">elif</span> v<span class=\"token punctuation\">.</span>π <span class=\"token operator\">==</span> nil<span class=\"token punctuation\">:</span>\n        <span class=\"token keyword\">print</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"경로 없음\"</span><span class=\"token punctuation\">)</span>\n    <span class=\"token keyword\">else</span><span class=\"token punctuation\">:</span>\n        print_path<span class=\"token punctuation\">(</span>s<span class=\"token punctuation\">,</span> v<span class=\"token punctuation\">.</span>π<span class=\"token punctuation\">)</span>\n        <span class=\"token keyword\">print</span><span class=\"token punctuation\">(</span>v<span class=\"token punctuation\">)</span></code></pre></div>\n<p>이 재귀 함수는 parent chain을 따라 역순으로 경로를 복원한다.</p>\n<blockquote>\n<p>💡 <strong>BFS의 주요 특징 정리</strong></p>\n<ul>\n<li><strong>거리 순서 보장</strong>: 항상 거리 증가 순서로 방문 (wave 1 → wave 2 → wave 3)</li>\n<li><strong>최단 경로 보장</strong>: unweighted graph에서 최단 경로를 찾음</li>\n<li><strong>효율성</strong>: <code class=\"language-text\">O(V + E)</code> 시간 복잡도로 최적의 성능</li>\n<li><strong>완전성</strong>: 출발점에서 reachable한 모든 정점을 탐색</li>\n</ul>\n</blockquote>\n<h2 id=\"2️-dfs-depth-first-search\">2️⃣ DFS (Depth-First Search)</h2>\n<h3 id=\"dfs-핵심-개념\">DFS 핵심 개념</h3>\n<h4 id=\"2-1-dfs란\">2-1 DFS란?</h4>\n<p>DFS는 그래프 탐색 알고리즘으로, BFS와 달리 <strong>깊이(depth)</strong> 기준으로 탐색한다. 한 정점에서 가능한 한 깊이 들어간 후, 더 이상 갈 곳이 없으면 되돌아오는 방식이다.</p>\n<p>🔥 <strong>BFS와의 주요 차이점</strong></p>\n<ul>\n<li><strong>자료구조</strong>: 큐 대신 재귀 호출 스택 사용 (또는 명시적 스택)</li>\n<li><strong>출력 구조</strong>: 단일 트리가 아닌 <strong>forest(포레스트)</strong> 생성 가능</li>\n<li><strong>시작점</strong>: 하나의 고정된 source가 없음</li>\n<li><strong>기록 정보</strong>: 거리 대신 <code class=\"language-text\">discovery time</code>과 <code class=\"language-text\">finish time</code> 기록</li>\n</ul>\n<h4 id=\"2-2-dfs가-생성하는-정보\">2-2 DFS가 생성하는 정보</h4>\n<p><strong><code class=\"language-text\">v.d</code> (discovery time)</strong></p>\n<ul>\n<li>v를 처음 발견한 시점</li>\n<li>탐색을 시작할 때 증가하는 타임스탬프</li>\n</ul>\n<p><strong><code class=\"language-text\">v.f</code> (finish time)</strong></p>\n<ul>\n<li>v의 탐색이 완료된 시점</li>\n<li>항상 <code class=\"language-text\">v.f > v.d</code></li>\n</ul>\n<p><strong><code class=\"language-text\">v.π</code> (predecessor)</strong></p>\n<ul>\n<li>DFS 트리에서 v의 부모 정점</li>\n</ul>\n<h3 id=\"dfs-알고리즘-구조\">DFS 알고리즘 구조</h3>\n<h4 id=\"2-3-dfs-의사코드\">2-3 DFS 의사코드</h4>\n<div class=\"gatsby-highlight\" data-language=\"python\"><pre class=\"language-python\"><code class=\"language-python\"><span class=\"token comment\"># 초기화 및 메인 루프</span>\n<span class=\"token keyword\">def</span> <span class=\"token function\">DFS</span><span class=\"token punctuation\">(</span>G<span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span>\n    <span class=\"token keyword\">for</span> each vertex u <span class=\"token keyword\">in</span> G<span class=\"token punctuation\">.</span>V<span class=\"token punctuation\">:</span>\n        u<span class=\"token punctuation\">.</span>color <span class=\"token operator\">=</span> white\n        u<span class=\"token punctuation\">.</span>π <span class=\"token operator\">=</span> nil\n    time <span class=\"token operator\">=</span> <span class=\"token number\">0</span>\n\n    <span class=\"token keyword\">for</span> each vertex u <span class=\"token keyword\">in</span> G<span class=\"token punctuation\">.</span>V<span class=\"token punctuation\">:</span>\n        <span class=\"token keyword\">if</span> u<span class=\"token punctuation\">.</span>color <span class=\"token operator\">==</span> white<span class=\"token punctuation\">:</span>\n            DFS_VISIT<span class=\"token punctuation\">(</span>G<span class=\"token punctuation\">,</span> u<span class=\"token punctuation\">)</span>\n\n<span class=\"token comment\"># 재귀적 방문</span>\n<span class=\"token keyword\">def</span> <span class=\"token function\">DFS_VISIT</span><span class=\"token punctuation\">(</span>G<span class=\"token punctuation\">,</span> u<span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span>\n    <span class=\"token keyword\">global</span> time\n    time <span class=\"token operator\">=</span> time <span class=\"token operator\">+</span> <span class=\"token number\">1</span>\n    u<span class=\"token punctuation\">.</span>d <span class=\"token operator\">=</span> time          <span class=\"token comment\"># discovery time 기록</span>\n    u<span class=\"token punctuation\">.</span>color <span class=\"token operator\">=</span> gray\n\n    <span class=\"token keyword\">for</span> each v <span class=\"token keyword\">in</span> G<span class=\"token punctuation\">.</span>Adj<span class=\"token punctuation\">[</span>u<span class=\"token punctuation\">]</span><span class=\"token punctuation\">:</span>\n        <span class=\"token keyword\">if</span> v<span class=\"token punctuation\">.</span>color <span class=\"token operator\">==</span> white<span class=\"token punctuation\">:</span>\n            v<span class=\"token punctuation\">.</span>π <span class=\"token operator\">=</span> u\n            DFS_VISIT<span class=\"token punctuation\">(</span>G<span class=\"token punctuation\">,</span> v<span class=\"token punctuation\">)</span>\n\n    u<span class=\"token punctuation\">.</span>color <span class=\"token operator\">=</span> black\n    time <span class=\"token operator\">=</span> time <span class=\"token operator\">+</span> <span class=\"token number\">1</span>\n    u<span class=\"token punctuation\">.</span>f <span class=\"token operator\">=</span> time          <span class=\"token comment\"># finish time 기록</span></code></pre></div>\n<h4 id=\"2-4-dfs-작동-방식\">2-4 DFS 작동 방식</h4>\n<p>🔥 <strong>재귀적 탐색</strong></p>\n<ul>\n<li>큐를 사용하지 않고 재귀 호출 스택 활용</li>\n<li>한 경로를 끝까지 탐색한 후 백트래킹</li>\n<li>discovery time과 finish time을 보존하며 깊이 우선 탐색</li>\n</ul>\n<p>🔥 <strong>색상 의미</strong></p>\n<ul>\n<li><code class=\"language-text\">gray</code>: 방문했지만 아직 완료되지 않은 상태 (현재 탐색 중인 경로 상의 정점)</li>\n<li><code class=\"language-text\">black</code>: 해당 정점 관련된 모든 탐색이 끝남</li>\n<li>finish time이 기록되는 순간은 \"이 정점에서 더 이상 탐색할 곳이 없음\"을 의미</li>\n</ul>\n<h3 id=\"dfs-성능-분석\">DFS 성능 분석</h3>\n<h4 id=\"2-5-시간-복잡도\">2-5 시간 복잡도</h4>\n<p><strong>정점 방문</strong></p>\n<ul>\n<li>각 정점은 정확히 한 번 방문</li>\n<li>시간 복잡도: <code class=\"language-text\">Θ(V)</code></li>\n</ul>\n<p><strong>간선 스캔</strong></p>\n<ul>\n<li>각 간선은 정확히 한 번 확인</li>\n<li>시간 복잡도: <code class=\"language-text\">Θ(E)</code></li>\n</ul>\n<p><strong>최종 시간 복잡도: <code class=\"language-text\">Θ(V + E)</code></strong></p>\n<p>BFS와 동일하지만, tight bound로 표현된다.</p>\n<blockquote>\n<p>💡 <strong>BFS vs DFS 비교</strong></p>\n<table>\n<thead>\n<tr>\n<th>특성</th>\n<th>BFS</th>\n<th>DFS</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>자료구조</td>\n<td>큐(Queue)</td>\n<td>스택(Stack) 또는 재귀</td>\n</tr>\n<tr>\n<td>탐색 방식</td>\n<td>너비 우선 (레벨별)</td>\n<td>깊이 우선 (경로별)</td>\n</tr>\n<tr>\n<td>출력 구조</td>\n<td>단일 트리</td>\n<td>포레스트</td>\n</tr>\n<tr>\n<td>기록 정보</td>\n<td>거리(distance)</td>\n<td>discovery/finish time</td>\n</tr>\n<tr>\n<td>최단 경로</td>\n<td>보장</td>\n<td>보장 안 함</td>\n</tr>\n<tr>\n<td>시간 복잡도</td>\n<td>O(V + E)</td>\n<td>Θ(V + E)</td>\n</tr>\n</tbody>\n</table>\n</blockquote>\n<h2 id=\"3️-dag와-topological-sort\">3️⃣ DAG와 Topological Sort</h2>\n<h3 id=\"dag-개념\">DAG 개념</h3>\n<h4 id=\"3-1-dag란\">3-1 DAG란?</h4>\n<p>DAG(Directed Acyclic Graph)는 <strong>방향 그래프이며 사이클이 없는</strong> 그래프이다.</p>\n<p>🔥 <strong>DAG의 특징과 활용</strong></p>\n<ul>\n<li>사이클이 없으므로 <strong>의존성(dependency)</strong> 표현에 적합</li>\n<li>작업 순서, 컴파일 순서, 강의 선수과목 등을 모델링</li>\n</ul>\n<p><strong>예시: 옷 입는 순서</strong></p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">속옷 → 바지 → 벨트\n양말 → 신발\n셔츠 → 넥타이\n셔츠 → 재킷</code></pre></div>\n<p>각 화살표는 \"이것을 먼저 입어야 한다\"는 의존성을 나타낸다.</p>\n<h3 id=\"topological-sort-기본\">Topological Sort 기본</h3>\n<h4 id=\"3-2-topological-sort-정의\">3-2 Topological Sort 정의</h4>\n<p>DAG의 정점들을 <strong>선형 순서로 나열</strong>하되, 모든 간선 (u → v)에 대해 <strong>u가 v보다 앞에 오도록</strong> 정렬하는 것을 Topological Sort라고 한다.</p>\n<p>이 순서를 <strong>topological order</strong> 또는 <strong>topological ordering</strong>이라고 한다.</p>\n<h4 id=\"3-3-in-degree-기반-알고리즘\">3-3 In-degree 기반 알고리즘</h4>\n<div class=\"gatsby-highlight\" data-language=\"python\"><pre class=\"language-python\"><code class=\"language-python\">result <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span>\n<span class=\"token keyword\">while</span> 그래프에 정점이 남아있음<span class=\"token punctuation\">:</span>\n    진입 차수가 <span class=\"token number\">0</span>인 정점 v 선택\n    result에 v 추가\n    v와 v에서 나가는 모든 간선 제거\n<span class=\"token keyword\">return</span> result</code></pre></div>\n<p>🔥 <strong>문제점</strong></p>\n<ul>\n<li>매 단계마다 in-degree가 0인 정점을 찾는 데 비용이 큼</li>\n<li>adjacency list 전체 탐색이 필요 → <code class=\"language-text\">O(V + E)</code> per deletion</li>\n<li>전체 수행 시간 = <strong><code class=\"language-text\">O(V² + VE)</code></strong> → 비효율적</li>\n</ul>\n<h3 id=\"dfs를-이용한-topological-sort\">DFS를 이용한 Topological Sort</h3>\n<h4 id=\"3-4-핵심-아이디어\">3-4 핵심 아이디어</h4>\n<p>DFS의 finish time을 활용하면 효율적으로 topological sort를 수행할 수 있다.</p>\n<p>🔥 <strong>Finish Time의 의미</strong></p>\n<p>finish time이 기록되는 순간은:</p>\n<ul>\n<li>그 정점으로부터 나가는 모든 경로를 이미 방문 완료</li>\n<li>즉, 그 정점 이후에 방문할 정점이 없음</li>\n</ul>\n<p>따라서:</p>\n<p><strong>DFS에서 finish time이 큰 정점일수록 선형 순서의 앞쪽에 배치되어야 한다.</strong></p>\n<h4 id=\"3-5-dfs-기반-topological-sort-알고리즘\">3-5 DFS 기반 Topological Sort 알고리즘</h4>\n<div class=\"gatsby-highlight\" data-language=\"python\"><pre class=\"language-python\"><code class=\"language-python\"><span class=\"token keyword\">def</span> <span class=\"token function\">topological_sort</span><span class=\"token punctuation\">(</span>G<span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span>\n    result <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span>\n\n    <span class=\"token comment\"># DFS 수행</span>\n    DFS<span class=\"token punctuation\">(</span>G<span class=\"token punctuation\">)</span>\n\n    <span class=\"token comment\"># finish time 내림차순으로 정렬</span>\n    <span class=\"token comment\"># (또는 DFS 중 finish될 때마다 리스트 앞에 삽입)</span>\n    <span class=\"token keyword\">return</span> <span class=\"token builtin\">sorted</span><span class=\"token punctuation\">(</span>G<span class=\"token punctuation\">.</span>V<span class=\"token punctuation\">,</span> key<span class=\"token operator\">=</span><span class=\"token keyword\">lambda</span> v<span class=\"token punctuation\">:</span> v<span class=\"token punctuation\">.</span>f<span class=\"token punctuation\">,</span> reverse<span class=\"token operator\">=</span><span class=\"token boolean\">True</span><span class=\"token punctuation\">)</span></code></pre></div>\n<p>더 효율적인 방법:</p>\n<div class=\"gatsby-highlight\" data-language=\"python\"><pre class=\"language-python\"><code class=\"language-python\"><span class=\"token keyword\">def</span> <span class=\"token function\">DFS_VISIT_with_topological</span><span class=\"token punctuation\">(</span>G<span class=\"token punctuation\">,</span> u<span class=\"token punctuation\">,</span> result<span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span>\n    <span class=\"token keyword\">global</span> time\n    time <span class=\"token operator\">=</span> time <span class=\"token operator\">+</span> <span class=\"token number\">1</span>\n    u<span class=\"token punctuation\">.</span>d <span class=\"token operator\">=</span> time\n    u<span class=\"token punctuation\">.</span>color <span class=\"token operator\">=</span> gray\n\n    <span class=\"token keyword\">for</span> each v <span class=\"token keyword\">in</span> G<span class=\"token punctuation\">.</span>Adj<span class=\"token punctuation\">[</span>u<span class=\"token punctuation\">]</span><span class=\"token punctuation\">:</span>\n        <span class=\"token keyword\">if</span> v<span class=\"token punctuation\">.</span>color <span class=\"token operator\">==</span> white<span class=\"token punctuation\">:</span>\n            v<span class=\"token punctuation\">.</span>π <span class=\"token operator\">=</span> u\n            DFS_VISIT_with_topological<span class=\"token punctuation\">(</span>G<span class=\"token punctuation\">,</span> v<span class=\"token punctuation\">,</span> result<span class=\"token punctuation\">)</span>\n\n    u<span class=\"token punctuation\">.</span>color <span class=\"token operator\">=</span> black\n    time <span class=\"token operator\">=</span> time <span class=\"token operator\">+</span> <span class=\"token number\">1</span>\n    u<span class=\"token punctuation\">.</span>f <span class=\"token operator\">=</span> time\n    result<span class=\"token punctuation\">.</span>insert<span class=\"token punctuation\">(</span><span class=\"token number\">0</span><span class=\"token punctuation\">,</span> u<span class=\"token punctuation\">)</span>  <span class=\"token comment\"># 앞에 삽입 (finish time 큰 것부터)</span></code></pre></div>\n<h4 id=\"3-6-시간-복잡도\">3-6 시간 복잡도</h4>\n<ul>\n<li>DFS 실행: <code class=\"language-text\">Θ(V + E)</code></li>\n<li>추가 비용: <code class=\"language-text\">O(1)</code> (각 정점의 finish 시 리스트 앞에 삽입)</li>\n<li><strong>최종 시간 복잡도: <code class=\"language-text\">Θ(V + E)</code></strong></li>\n</ul>\n<p>이는 in-degree 기반 방법보다 훨씬 효율적이다.</p>\n<h3 id=\"dfs와-topological-sort의-특성\">DFS와 Topological Sort의 특성</h3>\n<h4 id=\"3-7-비결정성과-정확성\">3-7 비결정성과 정확성</h4>\n<p>🔥 <strong>DFS 결과의 비결정성</strong></p>\n<p>DFS 결과는 <strong>유일하지 않다</strong>.</p>\n<ul>\n<li>시작 정점 선택 순서</li>\n<li>adjacency list 내부 정점 순서</li>\n</ul>\n<p>에 따라 discovery time과 finish time이 달라진다.</p>\n<p>🔥 <strong>Topological Sort의 정확성</strong></p>\n<p>하지만 <strong>topological sort 결과는 순서가 달라도 언제나 valid하다</strong>.</p>\n<ul>\n<li>finish time ordering은 상대적 순서를 보존</li>\n<li>간선 (u → v)에 대해 u가 v보다 먼저 finish되는 경우는 없음</li>\n<li>따라서 어떤 DFS 수행 결과든 올바른 topological order를 생성</li>\n</ul>\n<p><strong>예시:</strong></p>\n<p>같은 DAG에서 DFS를 여러 번 수행하면 다른 topological order를 얻을 수 있지만, 모두 유효한 순서이다.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">A → C\nB → C\n\n가능한 topological orders:\n- A, B, C\n- B, A, C</code></pre></div>\n<p>두 순서 모두 \"C보다 A와 B가 앞에 온다\"는 조건을 만족한다.</p>\n<blockquote>\n<p>💡 <strong>Topological Sort 응용 분야</strong></p>\n<ul>\n<li><strong>작업 스케줄링</strong>: 작업 간 의존성을 고려한 실행 순서 결정</li>\n<li><strong>컴파일 순서</strong>: 모듈 간 의존성을 고려한 컴파일 순서</li>\n<li><strong>선수과목 체계</strong>: 강의 수강 순서 결정</li>\n<li><strong>Makefile 의존성</strong>: 파일 빌드 순서 결정</li>\n</ul>\n</blockquote>","fields":{"slug":"/algorithm-bfs-dfs/"},"frontmatter":{"title":"알고리즘설계와분석 - BFS/DFS와 Topological Sort","date":"2025-12-11","description":"그래프 탐색의 두 가지 핵심 알고리즘인 BFS와 DFS의 원리, 구현 및 Topological Sort에 대해 알아본다.","pointColor":"#ffffff","tags":["알고리즘"],"keywords":"알고리즘, BFS, DFS, 너비 우선 탐색, 깊이 우선 탐색, 그래프 탐색, Topological Sort, 위상 정렬, 그래프, Graph","thumbnail":{"publicURL":"/static/92cfd98e80a1411995f7457255b74046/index.png","childImageSharp":{"gatsbyImageData":{"layout":"fixed","placeholder":{"fallback":"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAKCAYAAAC0VX7mAAAACXBIWXMAAAsTAAALEwEAmpwYAAABiklEQVR42m1Si1LCMBDk/78OdQYURekjpY+kJGkLSB/r5tAOop25mfTusre7ucWEAT8BxntewjSe5wnjTe133wjbtXjLcozT79ri9mcYB0Rlibpt5NI49X/AQi7UDgTcVSXv9P8Dhs+2LZbbSCaHS5PEPcNR2L/tMyx3O9SiBrMaAfTHDnFVIdUaTx8xZRdkWqGwB1zGywwWzoU7YFcWeC9yPBAw0RUiMvWn9grYk3JcaryojMAnrBOF0jpkdY3nVIlXEFZX316UYs2gco71FK7rsCHbmMA9BwrDABJ8s12Dhw9K3ufizTpJKamZAU3rsUoTqb0S5DGiZOa0d1irVHoWyhg8E9D4RrxbxUoGxJUWCzZkHiaH2GQZUvYnzG8peU0FAXib5xKls1h05xNyehVebxWnItV4j5Z5d2zl/OOhbpx4FVg9RRF7jqi8RXPuaIHFuT8HyddXuwwXYRoAw/80v/LNS0/XbchtTbZKht73zmszkKHSRqbje99k7/7ZwcA8MRqfZIS7ni8+FwGPiK1oLQAAAABJRU5ErkJggg=="},"backgroundColor":"transparent","images":{"fallback":{"src":"/static/92cfd98e80a1411995f7457255b74046/f35ad/index.png","srcSet":"/static/92cfd98e80a1411995f7457255b74046/f35ad/index.png 640w","sizes":"640px"},"sources":[{"srcSet":"/static/92cfd98e80a1411995f7457255b74046/df57d/index.webp 640w","type":"image/webp","sizes":"640px"}]},"width":1200,"height":624},"fixed":{"src":"/static/92cfd98e80a1411995f7457255b74046/f3dec/index.png"}}}}},"previous":{"fields":{"slug":"/algorithm-greedy-algorithm/"},"frontmatter":{"title":"알고리즘설계와분석 - Greedy algorithm (그리디 알고리즘)"}},"next":{"fields":{"slug":"/algorithm-minimum-spanning-tree/"},"frontmatter":{"title":"알고리즘설계와분석 - MST (최소신장트리)"}}},"pageContext":{"id":"c3f8c648-5cf2-578a-b827-89342247108b","previousPostId":"d17f2020-6926-58f5-a943-e02168debf04","nextPostId":"32eacbb3-4de6-5df5-ae61-d67b221901ce"}},"staticQueryHashes":["736397157"],"slicesMap":{}}