{"componentChunkName":"component---src-templates-blog-post-js","path":"/computer-architecture-computer-information/","result":{"data":{"site":{"siteMetadata":{"title":"메인","siteUrl":"https://rmdnps10.github.io","author":{"name":"Inyoung Chung"}}},"markdownRemark":{"id":"ca16e931-9dfc-5af5-ad59-bb436c3a5c66","excerpt":"'이것이 취업을 위한 컴퓨터 과학이다 with CS 기술 면접' 책을 읽으면서 배운 점을 정리합니다. 2진법 체계와 명령어 구조를 중심으로 살펴봅니다. 1비트와 바이트 컴퓨터는 0과 1만을 이해한다. 0과 1을 나타내는 가장 작은 작업 단위를 라고 한다. 비트와 정보 표현 k비트는…","html":"<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 1000px; background: transparent;\"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/static/f0a910359965b97ebd62fb1d0d744e59/60f98/index.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 47.599999999999994%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAKCAYAAAC0VX7mAAAACXBIWXMAAAsTAAALEwEAmpwYAAACaklEQVR42h2S124aURCG95Ej5SpSepMTEoc4NjZem2p6r0tZwNSlF4OxAVeiRJFf4svAxUhnz5n55y+rLG7WLG/X3K+fWNz8ZXn3j+XjE4PpktZwTH96LbXAGF5iDGZU6l1SWoUTu59ILMv1as3q7g/L1QPzq1uUhYBdrx7J6Q3SuSpGf8ZKwINxjXJzQHs0pzO+onexEOAlYbmPxHO8eW/Ccuig2Z7QG1zSMvqMJ3OUq+UDLk+Yjzs/UG0ezL+sDGc3xLUyg/kdk+Wa2eo3U6m5MAkncviCCWyuoMxFsRy7OTp24XT6aAqoksqW2N1T+f7TinlfFUCVnW8H2GVJttIiLxK1qoEmZ63cwnxwilOAQvE8Lm+UU2cQfyjNx08mtEIZxbRr4e2HL0yv7ml1pzx7/pIXrz9TrHVJ5s/xRjKYj2ycOAN4QykcAhJLl1AdfpxyDkaypPNVbHYPermGUpFB0+4+aTH6LBDn8OSMSmvI8PKWsSxp9KbojT75akdCmnMhFpTku9G9IFuobwE3nuaLNVqdIUpH0tOK9W0o/kiagDSEpMEbTuMOJKRihFNF7N4YbmHYkXDy52180SxZmdFrva30ZEanLYEq5+0R58amhhzZvMLQI/5FOHYEOFDd7KsuLKdnmPasuER+OK1jFbmZUoNATONQ3lMiudaZUKr3RLKA1YV+pTUiKs2+WG5bkUyZkHi1ATx2B4iJpGBKJ5wsooqfr959Ze/QTqZQ2xIqCmtdbFEK1R56vS++DCjIRTJfk+0GzdE1JWOMTeT4BaS88axsbOVuGAXl94mL7z5hnchWKJTqYl2V/w5jdma0jL+fAAAAAElFTkSuQmCC'); background-size: cover; display: block;\"\n  ></span>\n  <picture>\n          <source\n              srcset=\"/static/f0a910359965b97ebd62fb1d0d744e59/bc904/index.webp 250w,\n/static/f0a910359965b97ebd62fb1d0d744e59/4be29/index.webp 500w,\n/static/f0a910359965b97ebd62fb1d0d744e59/03f31/index.webp 1000w,\n/static/f0a910359965b97ebd62fb1d0d744e59/fab20/index.webp 1122w\"\n              sizes=\"(max-width: 1000px) 100vw, 1000px\"\n              type=\"image/webp\"\n            />\n          <source\n            srcset=\"/static/f0a910359965b97ebd62fb1d0d744e59/43fa5/index.png 250w,\n/static/f0a910359965b97ebd62fb1d0d744e59/c6e3d/index.png 500w,\n/static/f0a910359965b97ebd62fb1d0d744e59/da8b6/index.png 1000w,\n/static/f0a910359965b97ebd62fb1d0d744e59/60f98/index.png 1122w\"\n            sizes=\"(max-width: 1000px) 100vw, 1000px\"\n            type=\"image/png\"\n          />\n          <img\n            class=\"gatsby-resp-image-image\"\n            src=\"/static/f0a910359965b97ebd62fb1d0d744e59/da8b6/index.png\"\n            alt=\"index\"\n            title=\"\"\n            loading=\"lazy\"\n            decoding=\"async\"\n            style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n          />\n        </picture>\n  </a>\n    </span></p>\n<blockquote>\n<p>'이것이 취업을 위한 컴퓨터 과학이다 with CS 기술 면접' 책을 읽으면서 배운 점을 정리합니다. 2진법 체계와 명령어 구조를 중심으로 살펴봅니다.</p>\n</blockquote>\n<h2 id=\"1비트와-바이트\">1비트와 바이트</h2>\n<p>컴퓨터는 0과 1만을 이해한다. 0과 1을 나타내는 가장 작은 작업 단위를 <code class=\"language-text\">비트(bit)</code>라고 한다.</p>\n<p><strong>비트와 정보 표현</strong></p>\n<ul>\n<li>k비트는 2^k 만큼의 정보를 표현할 수 있다</li>\n<li>1byte = 8bit (256가지 표현 가능)</li>\n<li>1KB = 1,000byte</li>\n<li>1MB = 1,000KB</li>\n</ul>\n<div class=\"gatsby-highlight\" data-language=\"python\"><pre class=\"language-python\"><code class=\"language-python\"><span class=\"token comment\"># 비트로 표현 가능한 정보의 수</span>\nbits <span class=\"token operator\">=</span> <span class=\"token number\">8</span>\npossible_values <span class=\"token operator\">=</span> <span class=\"token number\">2</span> <span class=\"token operator\">**</span> bits\n<span class=\"token keyword\">print</span><span class=\"token punctuation\">(</span><span class=\"token string-interpolation\"><span class=\"token string\">f\"</span><span class=\"token interpolation\"><span class=\"token punctuation\">{</span>bits<span class=\"token punctuation\">}</span></span><span class=\"token string\">비트로 표현 가능한 값: </span><span class=\"token interpolation\"><span class=\"token punctuation\">{</span>possible_values<span class=\"token punctuation\">}</span></span><span class=\"token string\">개\"</span></span><span class=\"token punctuation\">)</span>  <span class=\"token comment\"># 256개</span></code></pre></div>\n<h2 id=\"2️-2진법으로-소수-표현하기\">2️⃣ 2진법으로 소수 표현하기</h2>\n<h3 id=\"부동-소수점의-한계\">부동 소수점의 한계</h3>\n<div class=\"gatsby-highlight\" data-language=\"python\"><pre class=\"language-python\"><code class=\"language-python\"><span class=\"token keyword\">print</span><span class=\"token punctuation\">(</span><span class=\"token number\">0.1</span> <span class=\"token operator\">+</span> <span class=\"token number\">0.2</span> <span class=\"token operator\">==</span> <span class=\"token number\">0.3</span><span class=\"token punctuation\">)</span>  <span class=\"token comment\"># False</span>\n<span class=\"token keyword\">print</span><span class=\"token punctuation\">(</span><span class=\"token number\">0.1</span> <span class=\"token operator\">+</span> <span class=\"token number\">0.2</span><span class=\"token punctuation\">)</span>  <span class=\"token comment\"># 0.30000000000000004</span></code></pre></div>\n<p>대부분의 프로그래밍 언어에서 위 코드의 결과는 <code class=\"language-text\">False</code>이다. 이유는 <code class=\"language-text\">부동 소수점(floating point)</code> 표현 방식의 정밀도에 한계가 있기 때문이다.</p>\n<h3 id=\"부동-소수점-표현-방식\">부동 소수점 표현 방식</h3>\n<p>부동 소수점은 소수점의 위치가 고정되지 않은(floating) 소수 표현 방식이다.</p>\n<p><strong>🔍 10진수 예시</strong></p>\n<p>10진수 123.123을 m*10^n 형태로 표현하면:</p>\n<ul>\n<li>n=2, m=1.23123</li>\n<li>n=-1, m=1231.23</li>\n</ul>\n<p>이렇게 소수점의 위치를 고정시키지 않고 같은 소수를 다양하게 표현할 수 있는 방식이 부동 소수점 표현 방식이다.</p>\n<h3 id=\"ieee-754-표준\">IEEE 754 표준</h3>\n<p>2진수 체계에서는 IEEE 754 표준을 사용하여 부동 소수점을 표현한다.</p>\n<p><strong>⚙️ IEEE 754 구조 (32bit 단정밀도)</strong></p>\n<table>\n<thead>\n<tr>\n<th>구성 요소</th>\n<th>비트 수</th>\n<th>역할</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>부호(Sign)</td>\n<td>1bit</td>\n<td>양수(0) 또는 음수(1)</td>\n</tr>\n<tr>\n<td>지수(Exponent)</td>\n<td>8bit</td>\n<td>소수점 위치 결정</td>\n</tr>\n<tr>\n<td>가수(Mantissa)</td>\n<td>23bit</td>\n<td>실제 숫자 값 저장</td>\n</tr>\n</tbody>\n</table>\n<p><strong>⚠️ 정밀도 한계</strong></p>\n<p>10진수 소수를 2진수로 표현할 때 10진수와 2진수의 표현이 딱 맞아떨어지지 않을 수 있다.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">1/3 = 0.333333...  # 10진수 무한 소수\n0.1(10진수) = 0.0001100110011...(2진수)  # 2진수 무한 소수</code></pre></div>\n<p>이럴 경우 일부 소수점을 생략하여 저장하므로 오차가 발생한다.</p>\n<h2 id=\"3️-명령어\">3️⃣ 명령어</h2>\n<h3 id=\"명령어-구조\">명령어 구조</h3>\n<p>명령어는 <code class=\"language-text\">연산 코드(opcode)</code>와 <code class=\"language-text\">오퍼랜드(operand)</code>로 구성되어 있다.</p>\n<table>\n<thead>\n<tr>\n<th>구성 요소</th>\n<th>역할</th>\n<th>예시</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>연산 코드</td>\n<td>명령어가 수행할 동작</td>\n<td>ADD, SUB, LOAD, STORE</td>\n</tr>\n<tr>\n<td>오퍼랜드</td>\n<td>데이터가 저장된 위치</td>\n<td>메모리 주소, 레지스터 이름</td>\n</tr>\n</tbody>\n</table>\n<p><strong>🎯 연산 코드의 주요 유형</strong></p>\n<ul>\n<li><strong>데이터 전송</strong>: LOAD, STORE, MOVE</li>\n<li><strong>산술 연산</strong>: ADD, SUB, MUL, DIV</li>\n<li><strong>제어 흐름 변경</strong>: JUMP, CALL, RETURN</li>\n<li><strong>입출력 제어</strong>: READ, WRITE</li>\n</ul>\n<h3 id=\"주소-지정-방식\">주소 지정 방식</h3>\n<p>오퍼랜드 필드에는 데이터가 직접 명시되기보다는 <strong>메모리 주소</strong>나 <strong>레지스터 이름</strong>이 명시된다.</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\"><span class=\"token constant\">LOAD</span> <span class=\"token constant\">R1</span><span class=\"token punctuation\">,</span> <span class=\"token punctuation\">[</span><span class=\"token number\">1000</span><span class=\"token punctuation\">]</span>  # 메모리 주소 <span class=\"token number\">1000</span>의 값을 <span class=\"token constant\">R1</span> 레지스터로 로드\n<span class=\"token constant\">ADD</span> <span class=\"token constant\">R1</span><span class=\"token punctuation\">,</span> <span class=\"token constant\">R2</span>       # <span class=\"token constant\">R1</span>과 <span class=\"token constant\">R2</span>의 값을 더해서 <span class=\"token constant\">R1</span>에 저장</code></pre></div>\n<p>CPU가 메모리에서 인출한 명령어를 곧바로 실행하지 못하고 한 번 더 메모리에 접근해야 하는 이유가 바로 이 때문이다.</p>\n<blockquote>\n<p><strong>💡 주소 지정 방식의 종류</strong></p>\n<ul>\n<li><strong>즉시 주소 지정</strong>: 오퍼랜드에 데이터 직접 명시</li>\n<li><strong>직접 주소 지정</strong>: 오퍼랜드에 메모리 주소 명시</li>\n<li><strong>간접 주소 지정</strong>: 오퍼랜드에 메모리 주소를 가리키는 주소 명시</li>\n<li><strong>레지스터 주소 지정</strong>: 오퍼랜드에 레지스터 이름 명시</li>\n</ul>\n</blockquote>\n<h2 id=\"4️-명령어-사이클\">4️⃣ 명령어 사이클</h2>\n<p>CPU가 명령어를 처리하는 과정을 <code class=\"language-text\">명령어 사이클(instruction cycle)</code>이라고 한다.</p>\n<h3 id=\"명령어-사이클의-단계\">명령어 사이클의 단계</h3>\n<p><strong>1. 인출 사이클 (Fetch Cycle)</strong></p>\n<p>메모리에서 실행할 명령어를 가져오는 단계이다.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">1. PC(Program Counter)가 가리키는 메모리 주소에서 명령어 읽기\n2. 읽어온 명령어를 IR(Instruction Register)에 저장\n3. PC 값을 다음 명령어 주소로 증가</code></pre></div>\n<p><strong>2. 실행 사이클 (Execution Cycle)</strong></p>\n<p>인출한 명령어를 해석하고 실행하는 단계이다.</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\"><span class=\"token number\">1.</span> 제어장치가 명령어 해독\n<span class=\"token number\">2.</span> <span class=\"token constant\">ALU</span>에서 연산 수행\n<span class=\"token number\">3.</span> 결과를 레지스터나 메모리에 저장</code></pre></div>\n<p><strong>3. 간접 사이클 (Indirect Cycle)</strong></p>\n<p>오퍼랜드 필드에 주소가 명시된 경우, 명령어 실행을 위해 메모리에 접근하는 단계이다.</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\"><span class=\"token number\">1.</span> 오퍼랜드가 가리키는 메모리 주소 접근\n<span class=\"token number\">2.</span> 실제 데이터 주소 획득\n<span class=\"token number\">3.</span> 해당 주소의 데이터 인출</code></pre></div>\n<h3 id=\"명령어-사이클의-흐름\">명령어 사이클의 흐름</h3>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\">인출 사이클 <span class=\"token function\">→</span> <span class=\"token punctuation\">(</span>간접 사이클<span class=\"token punctuation\">)</span> → 실행 사이클 → 인출 사이클 → <span class=\"token operator\">...</span></code></pre></div>\n<p>간접 사이클은 필요한 경우에만 수행되며, 이 과정이 반복되면서 프로그램이 실행된다.</p>\n<blockquote>\n<p><strong>💡 명령어 사이클과 성능</strong></p>\n<ul>\n<li>명령어 사이클이 짧을수록 CPU 성능이 향상된다</li>\n<li><code class=\"language-text\">클럭(Clock)</code>: 명령어 사이클의 기본 단위 시간</li>\n<li><code class=\"language-text\">CPI(Cycles Per Instruction)</code>: 명령어당 필요한 클럭 수</li>\n<li>CPU 성능 = 클럭 속도 / CPI</li>\n</ul>\n</blockquote>","fields":{"slug":"/computer-architecture-computer-information/"},"frontmatter":{"title":"[컴퓨터구조] 2. 컴퓨터가 이해하는 정보","date":"2026-01-17","description":"이것이 컴퓨터 과학이다 + 혼자 공부하는 컴퓨터 구조/운영체제를 읽으면서 배운 내용을 정리합니다. 컴퓨터가 데이터와 명령어를 어떻게 이해하고 처리하는지 2진법 체계와 명령어 구조를 중심으로 살펴봅니다. ","pointColor":"#ffffff","tags":["컴퓨터구조"],"keywords":"컴퓨터구조, CS, Computer Science, 컴퓨터 과학, CPU, 메모리, 데이터, 이것이 취업을 위한 컴퓨터 과학이다, 혼공컴운, 혼자 공부하는 컴퓨터 구조","thumbnail":{"publicURL":"/static/f0a910359965b97ebd62fb1d0d744e59/index.png","childImageSharp":{"gatsbyImageData":{"layout":"fixed","placeholder":{"fallback":"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAKCAYAAAC0VX7mAAAACXBIWXMAAAsTAAALEwEAmpwYAAACaElEQVR42h2SZ0/bABCG/ZMr9VOl7tKKNi1NKSsJZJI9IXtP4uxBQoYNAYJaVfyJp5d8OOls3733Diuzhc7ydo12t+Z+/Sz9X7TVP7THZ/oTjeZgRG+ykFqiDm5Q+1PK9Q7xdJlTm49wNMVCX6Ov/qDpDyjz5R1LAVvoj2QKDRKZKmpvii7ggVia0lWf1nBGezSne70UYI2QvA/HMrz7aODo2M5Va0y3f0NT7aHMBHCuPeB0h9jZ/YnF6sb428RgekssXaI/WzHW1kz1JyZSM2ESusjgDVxgdQZkL8KR2cWJ2YnD4UVZ6PfEU0X29i38+GXCeGARQAu73w+xyZFUuUlWJKarKmnp06UmxsMzHAIUjGVxeiKcOQL4ggl2PhtQtNUThr0j3n/6ymR+T7Mz4cXL17x6+4V8rcNltoInnMR4YuXU4ccTjGMXkGiiiMXuwyF9IJwika1itblRhhOdsiwa9g5IiNHn/hjHp+eUmwMGN3eM5EijO6HQ6JGttiWkGddiQVGeG51rUrn6FnDjaTZfQ2kNJrQlvXS+vg3FF07gl4GgDHhCCVz+C6kooXgemyeKSxi2JZxspYU3kiIlO4Vadyv9MllAaXTHVFpDKuqmBpxYPcLQLf6FMdv9HFpcHFicHJ2dY9g34RT5oUQBk8hNFhv4o2mO5XtcJNfaY5RKc0hZwOpCvyx9RIa90cy2wskSQfFqA2h2+YmKpEC8QOgyj0X8fPPhG/vHNpK52pZQXlgr+WqHXLVLod4TX/rStyWImlxXuRouKKojrCLHJyCljWcldSt3wyggv09MfPcK64tUmVyxzn89o3fJ0XUFRgAAAABJRU5ErkJggg=="},"backgroundColor":"transparent","images":{"fallback":{"src":"/static/f0a910359965b97ebd62fb1d0d744e59/a57e7/index.png","srcSet":"/static/f0a910359965b97ebd62fb1d0d744e59/a57e7/index.png 1122w","sizes":"1122px"},"sources":[{"srcSet":"/static/f0a910359965b97ebd62fb1d0d744e59/38b06/index.webp 1122w","type":"image/webp","sizes":"1122px"}]},"width":1200,"height":571},"fixed":{"src":"/static/f0a910359965b97ebd62fb1d0d744e59/3cf18/index.png"}}}}},"previous":{"fields":{"slug":"/computer-architecture-big-picture/"},"frontmatter":{"title":"[컴퓨터구조] 1. 컴퓨터구조의 큰 그림"}},"next":{"fields":{"slug":"/computer-architecture-cpu/"},"frontmatter":{"title":"[컴퓨터구조] 3. CPU"}}},"pageContext":{"id":"ca16e931-9dfc-5af5-ad59-bb436c3a5c66","previousPostId":"da1d04f2-e4be-5c21-b8bc-b4296f385696","nextPostId":"e061ed17-1331-5791-9cff-13e3fd0948e3"}},"staticQueryHashes":["736397157"],"slicesMap":{}}