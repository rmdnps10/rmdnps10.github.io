{"componentChunkName":"component---src-templates-blog-post-js","path":"/algorithm-binary-search-tree/","result":{"data":{"site":{"siteMetadata":{"title":"메인","siteUrl":"https://inyoung.dev","author":{"name":"Inyoung Chung"}}},"markdownRemark":{"id":"1b4b98fd-9e5f-5564-a004-ea9e94cb1273","excerpt":"학부 수업 \"알고리즘설계와분석\" 내용을 정리합니다. Binary Search Tree는 데이터를 효율적으로 탐색하고 정렬하기 위한 트리 구조다. BST의 핵심 규칙과 주요 연산들을 이해하고, 트리의 높이가 성능에 미치는 영향을 살펴본다. 1️⃣ Binary Search Tree…","html":"<blockquote>\n<p>학부 수업 \"알고리즘설계와분석\" 내용을 정리합니다.</p>\n</blockquote>\n<p>Binary Search Tree는 데이터를 효율적으로 탐색하고 정렬하기 위한 트리 구조다. BST의 핵심 규칙과 주요 연산들을 이해하고, 트리의 높이가 성능에 미치는 영향을 살펴본다.</p>\n<h2 id=\"1️-binary-search-tree란\">1️⃣ Binary Search Tree란?</h2>\n<h3 id=\"bst의-정의\">BST의 정의</h3>\n<p><code class=\"language-text\">Binary Search Tree(BST)</code>는 각 노드가 특정 규칙을 만족하는 이진 트리다.</p>\n<blockquote>\n<p>💡 <strong>이진 트리란?</strong></p>\n<p>이진 트리는 각 노드가 최대 2개의 자식 노드를 가지는 트리 구조다. 이진 트리는 탐색, 삽입, 삭제 등의 연산을 효율적으로 수행할 수 있는 자료구조로 자주 사용된다.</p>\n</blockquote>\n<h4 id=\"1-1-bst의-핵심-규칙\">1-1 BST의 핵심 규칙</h4>\n<p><strong>🔑 BST 속성</strong></p>\n<p>모든 노드 <code class=\"language-text\">i</code>에 대해 다음 조건을 만족해야 한다:</p>\n<ul>\n<li>왼쪽 서브트리의 모든 값 &#x3C; <code class=\"language-text\">i</code>의 값</li>\n<li>오른쪽 서브트리의 모든 값 ≥ <code class=\"language-text\">i</code>의 값</li>\n</ul>\n<p>이 규칙이 <strong>모든 노드</strong>에 대해 재귀적으로 성립해야 BST가 된다.</p>\n<div class=\"gatsby-highlight\" data-language=\"python\"><pre class=\"language-python\"><code class=\"language-python\"><span class=\"token comment\"># BST 예시</span>\n<span class=\"token comment\">#       12</span>\n<span class=\"token comment\">#      /  \\</span>\n<span class=\"token comment\">#     8    14</span>\n<span class=\"token comment\">#    / \\     \\</span>\n<span class=\"token comment\">#   5   9    20</span>\n\n<span class=\"token comment\"># 노드 12: 왼쪽(8,5,9) &lt; 12 ≤ 오른쪽(14,20) ✓</span>\n<span class=\"token comment\"># 노드 8: 왼쪽(5) &lt; 8 ≤ 오른쪽(9) ✓</span>\n<span class=\"token comment\"># 노드 14: 왼쪽(없음), 오른쪽(20) ≥ 14 ✓</span></code></pre></div>\n<h4 id=\"1-2-bst의-구조적-특성\">1-2 BST의 구조적 특성</h4>\n<p><strong>📍 최소값과 최대값의 위치</strong></p>\n<p>BST의 구조적 특성 덕분에 최소값과 최대값을 <code class=\"language-text\">O(h)</code> 시간 복잡도로 쉽게 찾을 수 있다:</p>\n<ul>\n<li><strong>최소값</strong>: 루트에서 왼쪽 자식으로 계속 이동하여 더 이상 왼쪽이 없을 때의 노드</li>\n<li><strong>최대값</strong>: 루트에서 오른쪽 자식으로 계속 이동하여 더 이상 오른쪽이 없을 때의 노드</li>\n</ul>\n<hr>\n<h2 id=\"2️-bst의-기본-연산\">2️⃣ BST의 기본 연산</h2>\n<p>BST에서 제공하는 주요 연산들은 다음과 같다:</p>\n<table>\n<thead>\n<tr>\n<th>연산</th>\n<th>의미</th>\n<th>시간 복잡도</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><code class=\"language-text\">Search(T, k)</code></td>\n<td>키 k를 가진 노드 탐색</td>\n<td>O(h)</td>\n</tr>\n<tr>\n<td><code class=\"language-text\">Insert(T, k)</code></td>\n<td>트리에 k 삽입</td>\n<td>O(h)</td>\n</tr>\n<tr>\n<td><code class=\"language-text\">Delete(T, k)</code></td>\n<td>노드 삭제</td>\n<td>O(h)</td>\n</tr>\n<tr>\n<td><code class=\"language-text\">Min(T)</code></td>\n<td>최소값 반환</td>\n<td>O(h)</td>\n</tr>\n<tr>\n<td><code class=\"language-text\">Max(T)</code></td>\n<td>최대값 반환</td>\n<td>O(h)</td>\n</tr>\n<tr>\n<td><code class=\"language-text\">Successor(x)</code></td>\n<td>x보다 큰 값 중 최소값</td>\n<td>O(h)</td>\n</tr>\n<tr>\n<td><code class=\"language-text\">Predecessor(x)</code></td>\n<td>x보다 작은 값 중 최대값</td>\n<td>O(h)</td>\n</tr>\n</tbody>\n</table>\n<blockquote>\n<p>💡 <strong>높이(h)란?</strong></p>\n<p>트리의 <code class=\"language-text\">높이(height)</code>는 루트에서 가장 먼 리프 노드까지의 경로 길이다. BST의 모든 연산은 트리의 높이에 비례하므로, 높이를 낮게 유지하는 것이 핵심이다.</p>\n</blockquote>\n<h3 id=\"탐색search\">탐색(Search)</h3>\n<h4 id=\"2-1-search-알고리즘\">2-1 Search 알고리즘</h4>\n<p><strong>🔍 탐색 과정</strong></p>\n<p><code class=\"language-text\">Search</code> 연산은 재귀적으로 정의된다. 현재 노드의 값과 비교하여 왼쪽 또는 오른쪽으로만 이동한다.</p>\n<div class=\"gatsby-highlight\" data-language=\"python\"><pre class=\"language-python\"><code class=\"language-python\"><span class=\"token keyword\">def</span> <span class=\"token function\">BST_Search</span><span class=\"token punctuation\">(</span>x<span class=\"token punctuation\">,</span> k<span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span>\n    <span class=\"token comment\"># x가 null이거나 찾는 값이면 반환</span>\n    <span class=\"token keyword\">if</span> x <span class=\"token operator\">==</span> <span class=\"token boolean\">None</span> <span class=\"token keyword\">or</span> k <span class=\"token operator\">==</span> x<span class=\"token punctuation\">.</span>key<span class=\"token punctuation\">:</span>\n        <span class=\"token keyword\">return</span> x\n\n    <span class=\"token comment\"># k가 현재 노드보다 작으면 왼쪽으로</span>\n    <span class=\"token keyword\">if</span> k <span class=\"token operator\">&lt;</span> x<span class=\"token punctuation\">.</span>key<span class=\"token punctuation\">:</span>\n        <span class=\"token keyword\">return</span> BST_Search<span class=\"token punctuation\">(</span>x<span class=\"token punctuation\">.</span>left<span class=\"token punctuation\">,</span> k<span class=\"token punctuation\">)</span>\n    <span class=\"token comment\"># k가 현재 노드보다 크면 오른쪽으로</span>\n    <span class=\"token keyword\">else</span><span class=\"token punctuation\">:</span>\n        <span class=\"token keyword\">return</span> BST_Search<span class=\"token punctuation\">(</span>x<span class=\"token punctuation\">.</span>right<span class=\"token punctuation\">,</span> k<span class=\"token punctuation\">)</span></code></pre></div>\n<p>한 단계마다 탐색 공간이 절반으로 줄어들기 때문에, 균형 잡힌 트리에서는 매우 효율적이다.\n그렇다면 균형이 잡히지 않은 트리에서는.. 시간 복잡도가 최악의 경우 <code class=\"language-text\">O(n)</code>이 될 수 있다는 것이다.</p>\n<h3 id=\"삽입insert\">삽입(Insert)</h3>\n<h4 id=\"2-2-insert-알고리즘\">2-2 Insert 알고리즘</h4>\n<p><strong>➕ 삽입 과정</strong></p>\n<p>새로운 값을 삽입할 때는 <code class=\"language-text\">Search</code>처럼 적절한 위치를 찾아 내려간다:</p>\n<ol>\n<li>트리가 비어있으면 새 노드를 루트로 설정</li>\n<li>그렇지 않으면 삽입할 값과 현재 노드를 비교\n<ul>\n<li>삽입 값 &#x3C; 현재 노드: 왼쪽으로 이동</li>\n<li>삽입 값 ≥ 현재 노드: 오른쪽으로 이동</li>\n</ul>\n</li>\n<li><code class=\"language-text\">null</code> 위치에 도달하면 해당 위치에 새 노드 삽입</li>\n</ol>\n<div class=\"gatsby-highlight\" data-language=\"python\"><pre class=\"language-python\"><code class=\"language-python\"><span class=\"token keyword\">def</span> <span class=\"token function\">BST_Insert</span><span class=\"token punctuation\">(</span>T<span class=\"token punctuation\">,</span> k<span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span>\n    new_node <span class=\"token operator\">=</span> Node<span class=\"token punctuation\">(</span>k<span class=\"token punctuation\">)</span>\n    parent <span class=\"token operator\">=</span> <span class=\"token boolean\">None</span>\n    current <span class=\"token operator\">=</span> T<span class=\"token punctuation\">.</span>root\n\n    <span class=\"token comment\"># 삽입 위치 찾기</span>\n    <span class=\"token keyword\">while</span> current <span class=\"token operator\">!=</span> <span class=\"token boolean\">None</span><span class=\"token punctuation\">:</span>\n        parent <span class=\"token operator\">=</span> current\n        <span class=\"token keyword\">if</span> k <span class=\"token operator\">&lt;</span> current<span class=\"token punctuation\">.</span>key<span class=\"token punctuation\">:</span>\n            current <span class=\"token operator\">=</span> current<span class=\"token punctuation\">.</span>left\n        <span class=\"token keyword\">else</span><span class=\"token punctuation\">:</span>\n            current <span class=\"token operator\">=</span> current<span class=\"token punctuation\">.</span>right\n\n    <span class=\"token comment\"># 부모 노드에 연결</span>\n    new_node<span class=\"token punctuation\">.</span>parent <span class=\"token operator\">=</span> parent\n    <span class=\"token keyword\">if</span> parent <span class=\"token operator\">==</span> <span class=\"token boolean\">None</span><span class=\"token punctuation\">:</span>\n        T<span class=\"token punctuation\">.</span>root <span class=\"token operator\">=</span> new_node  <span class=\"token comment\"># 트리가 비어있었음</span>\n    <span class=\"token keyword\">elif</span> k <span class=\"token operator\">&lt;</span> parent<span class=\"token punctuation\">.</span>key<span class=\"token punctuation\">:</span>\n        parent<span class=\"token punctuation\">.</span>left <span class=\"token operator\">=</span> new_node\n    <span class=\"token keyword\">else</span><span class=\"token punctuation\">:</span>\n        parent<span class=\"token punctuation\">.</span>right <span class=\"token operator\">=</span> new_node</code></pre></div>\n<h4 id=\"2-3-삽입-과정-예시\">2-3 삽입 과정 예시</h4>\n<p><strong>📝 14를 삽입하는 과정</strong></p>\n<p>다음 트리에 15를 삽입한다고 가정하자:</p>\n<div class=\"gatsby-highlight\" data-language=\"python\"><pre class=\"language-python\"><code class=\"language-python\"><span class=\"token comment\">#       12</span>\n<span class=\"token comment\">#      /  \\</span>\n<span class=\"token comment\">#     8    14</span>\n<span class=\"token comment\">#          \\</span>\n<span class=\"token comment\">#          20</span>\n<span class=\"token comment\">#          /</span>\n<span class=\"token comment\">#        15</span></code></pre></div>\n<ol>\n<li>루트 12와 비교: 15 ≥ 12 → 오른쪽으로</li>\n<li>노드 14와 비교: 15 ≥ 14 → 오른쪽으로</li>\n<li>노드 20과 비교: 15 &#x3C; 20 → 왼쪽으로</li>\n<li>왼쪽이 <code class=\"language-text\">null</code>이므로 해당 위치에 삽입</li>\n</ol>\n<p><strong>중요한 특성</strong>: 삽입은 항상 리프 노드의 자식 위치에서 발생한다.</p>\n<h3 id=\"최소값과-최대값\">최소값과 최대값</h3>\n<h4 id=\"2-4-min과-max-찾기\">2-4 Min과 Max 찾기</h4>\n<p><strong>⬅️ 최소값 찾기</strong></p>\n<div class=\"gatsby-highlight\" data-language=\"python\"><pre class=\"language-python\"><code class=\"language-python\"><span class=\"token keyword\">def</span> <span class=\"token function\">BST_Min</span><span class=\"token punctuation\">(</span>x<span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span>\n    <span class=\"token comment\"># 왼쪽 자식이 없을 때까지 이동</span>\n    <span class=\"token keyword\">while</span> x<span class=\"token punctuation\">.</span>left <span class=\"token operator\">!=</span> <span class=\"token boolean\">None</span><span class=\"token punctuation\">:</span>\n        x <span class=\"token operator\">=</span> x<span class=\"token punctuation\">.</span>left\n    <span class=\"token keyword\">return</span> x</code></pre></div>\n<p><strong>➡️ 최대값 찾기</strong></p>\n<div class=\"gatsby-highlight\" data-language=\"python\"><pre class=\"language-python\"><code class=\"language-python\"><span class=\"token keyword\">def</span> <span class=\"token function\">BST_Max</span><span class=\"token punctuation\">(</span>x<span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span>\n    <span class=\"token comment\"># 오른쪽 자식이 없을 때까지 이동</span>\n    <span class=\"token keyword\">while</span> x<span class=\"token punctuation\">.</span>right <span class=\"token operator\">!=</span> <span class=\"token boolean\">None</span><span class=\"token punctuation\">:</span>\n        x <span class=\"token operator\">=</span> x<span class=\"token punctuation\">.</span>right\n    <span class=\"token keyword\">return</span> x</code></pre></div>\n<p>두 연산 모두 트리의 높이만큼만 이동하므로 <code class=\"language-text\">O(h)</code> 시간이 소요된다.</p>\n<hr>\n<h2 id=\"3️-순회traversal\">3️⃣ 순회(Traversal)</h2>\n<h3 id=\"in-order-traversal\">In-order Traversal</h3>\n<h4 id=\"3-1-in-order-traversal\">3-1 In-order Traversal</h4>\n<p><strong>🔄 정렬된 출력</strong></p>\n<p><code class=\"language-text\">In-order Traversal</code>은 BST를 <strong>오름차순</strong>으로 출력하는 방법이다.</p>\n<div class=\"gatsby-highlight\" data-language=\"python\"><pre class=\"language-python\"><code class=\"language-python\"><span class=\"token keyword\">def</span> <span class=\"token function\">Inorder</span><span class=\"token punctuation\">(</span>x<span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span>\n    <span class=\"token keyword\">if</span> x <span class=\"token operator\">!=</span> <span class=\"token boolean\">None</span><span class=\"token punctuation\">:</span>\n        Inorder<span class=\"token punctuation\">(</span>x<span class=\"token punctuation\">.</span>left<span class=\"token punctuation\">)</span>    <span class=\"token comment\"># 왼쪽 서브트리 먼저</span>\n        <span class=\"token keyword\">print</span><span class=\"token punctuation\">(</span>x<span class=\"token punctuation\">.</span>key<span class=\"token punctuation\">)</span>       <span class=\"token comment\"># 현재 노드 출력</span>\n        Inorder<span class=\"token punctuation\">(</span>x<span class=\"token punctuation\">.</span>right<span class=\"token punctuation\">)</span>   <span class=\"token comment\"># 오른쪽 서브트리</span></code></pre></div>\n<p><strong>왜 오름차순이 보장되는가?</strong></p>\n<ul>\n<li>왼쪽 서브트리의 모든 값 &#x3C; 현재 노드 &#x3C; 오른쪽 서브트리의 모든 값</li>\n<li>따라서 왼쪽 → 자신 → 오른쪽 순서로 방문하면 자동으로 정렬된다</li>\n</ul>\n<div class=\"gatsby-highlight\" data-language=\"python\"><pre class=\"language-python\"><code class=\"language-python\"><span class=\"token comment\"># 예시 트리</span>\n<span class=\"token comment\">#       12</span>\n<span class=\"token comment\">#      /  \\</span>\n<span class=\"token comment\">#     8    14</span>\n<span class=\"token comment\">#    / \\     \\</span>\n<span class=\"token comment\">#   5   9    20</span>\n<span class=\"token comment\"># In-order 출력: 5 → 8 → 9 → 12 → 14 → 20</span></code></pre></div>\n<p><strong>⏱️ 시간 복잡도</strong></p>\n<p>각 노드를 정확히 한 번씩 방문하므로 <code class=\"language-text\">Θ(n)</code>이다. 모든 노드를 출력해야 하므로 이는 최적이다.</p>\n<h3 id=\"pre-order와-post-order-traversal\">Pre-order와 Post-order Traversal</h3>\n<h4 id=\"3-2-pre-order와-post-order-traversal\">3-2 Pre-order와 Post-order Traversal</h4>\n<p><strong>📋 다른 순회 방법들</strong></p>\n<ul>\n<li><strong>Pre-order</strong>: 자신 → 왼쪽 → 오른쪽\n<ul>\n<li>트리 복제, 직렬화 등에 유용</li>\n</ul>\n</li>\n<li><strong>Post-order</strong>: 왼쪽 → 오른쪽 → 자신\n<ul>\n<li>하위 구조부터 처리/삭제할 때 유용</li>\n</ul>\n</li>\n</ul>\n<div class=\"gatsby-highlight\" data-language=\"python\"><pre class=\"language-python\"><code class=\"language-python\"><span class=\"token keyword\">def</span> <span class=\"token function\">Preorder</span><span class=\"token punctuation\">(</span>x<span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span>\n    <span class=\"token keyword\">if</span> x <span class=\"token operator\">!=</span> <span class=\"token boolean\">None</span><span class=\"token punctuation\">:</span>\n        <span class=\"token keyword\">print</span><span class=\"token punctuation\">(</span>x<span class=\"token punctuation\">.</span>key<span class=\"token punctuation\">)</span>\n        Preorder<span class=\"token punctuation\">(</span>x<span class=\"token punctuation\">.</span>left<span class=\"token punctuation\">)</span>\n        Preorder<span class=\"token punctuation\">(</span>x<span class=\"token punctuation\">.</span>right<span class=\"token punctuation\">)</span>\n\n<span class=\"token keyword\">def</span> <span class=\"token function\">Postorder</span><span class=\"token punctuation\">(</span>x<span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span>\n    <span class=\"token keyword\">if</span> x <span class=\"token operator\">!=</span> <span class=\"token boolean\">None</span><span class=\"token punctuation\">:</span>\n        Postorder<span class=\"token punctuation\">(</span>x<span class=\"token punctuation\">.</span>left<span class=\"token punctuation\">)</span>\n        Postorder<span class=\"token punctuation\">(</span>x<span class=\"token punctuation\">.</span>right<span class=\"token punctuation\">)</span>\n        <span class=\"token keyword\">print</span><span class=\"token punctuation\">(</span>x<span class=\"token punctuation\">.</span>key<span class=\"token punctuation\">)</span></code></pre></div>\n<p>BST에서 <strong>정렬된 출력</strong>이 필요한 경우에는 반드시 <code class=\"language-text\">In-order</code>를 사용해야 한다.</p>\n<hr>\n<h2 id=\"4️-전임자와-후임자\">4️⃣ 전임자와 후임자</h2>\n<h4 id=\"4-1-predecessor와-successor-개념\">4-1 Predecessor와 Successor 개념</h4>\n<p><strong>🔢 순서상 이웃 찾기</strong></p>\n<p>어떤 노드의 값을 기준으로:</p>\n<ul>\n<li><strong>Predecessor(전임자)</strong>: 현재 노드보다 작은 값들 중 최대값</li>\n<li><strong>Successor(후임자)</strong>: 현재 노드보다 큰 값들 중 최소값</li>\n</ul>\n<p>이들은 <code class=\"language-text\">In-order Traversal</code>에서 해당 노드의 직전/직후 노드에 해당한다.</p>\n<h4 id=\"4-2-서브트리가-있을-때\">4-2 서브트리가 있을 때</h4>\n<p><strong>⬇️ 서브트리로 내려가기</strong></p>\n<p>노드 <code class=\"language-text\">v</code>에 대해:</p>\n<p><strong>Successor 찾기</strong> (오른쪽 서브트리가 있을 때)</p>\n<ol>\n<li>오른쪽 자식으로 한 칸 이동</li>\n<li>왼쪽으로 끝까지 이동</li>\n</ol>\n<div class=\"gatsby-highlight\" data-language=\"python\"><pre class=\"language-python\"><code class=\"language-python\"><span class=\"token keyword\">def</span> <span class=\"token function\">BST_Successor_WithSubtree</span><span class=\"token punctuation\">(</span>x<span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span>\n    <span class=\"token keyword\">if</span> x<span class=\"token punctuation\">.</span>right <span class=\"token operator\">!=</span> <span class=\"token boolean\">None</span><span class=\"token punctuation\">:</span>\n        <span class=\"token comment\"># 오른쪽 서브트리의 최소값</span>\n        <span class=\"token keyword\">return</span> BST_Min<span class=\"token punctuation\">(</span>x<span class=\"token punctuation\">.</span>right<span class=\"token punctuation\">)</span></code></pre></div>\n<p><strong>Predecessor 찾기</strong> (왼쪽 서브트리가 있을 때)</p>\n<ol>\n<li>왼쪽 자식으로 한 칸 이동</li>\n<li>오른쪽으로 끝까지 이동</li>\n</ol>\n<div class=\"gatsby-highlight\" data-language=\"python\"><pre class=\"language-python\"><code class=\"language-python\"><span class=\"token keyword\">def</span> <span class=\"token function\">BST_Predecessor_WithSubtree</span><span class=\"token punctuation\">(</span>x<span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span>\n    <span class=\"token keyword\">if</span> x<span class=\"token punctuation\">.</span>left <span class=\"token operator\">!=</span> <span class=\"token boolean\">None</span><span class=\"token punctuation\">:</span>\n        <span class=\"token comment\"># 왼쪽 서브트리의 최대값</span>\n        <span class=\"token keyword\">return</span> BST_Max<span class=\"token punctuation\">(</span>x<span class=\"token punctuation\">.</span>left<span class=\"token punctuation\">)</span></code></pre></div>\n<h4 id=\"4-3-서브트리가-없을-때\">4-3 서브트리가 없을 때</h4>\n<p><strong>⬆️ 부모로 올라가기</strong></p>\n<p>해당 방향 서브트리가 없는 경우, 부모 노드들을 따라 올라가며 찾는다.</p>\n<p><strong>Successor 찾기</strong> (오른쪽 서브트리가 없을 때)</p>\n<ol>\n<li>현재 노드가 부모의 오른쪽 자식인 동안 계속 부모로 올라간다</li>\n<li>처음으로 왼쪽 자식이 되는 순간, 그 부모가 <code class=\"language-text\">Successor</code></li>\n</ol>\n<div class=\"gatsby-highlight\" data-language=\"python\"><pre class=\"language-python\"><code class=\"language-python\"><span class=\"token keyword\">def</span> <span class=\"token function\">BST_Successor_NoSubtree</span><span class=\"token punctuation\">(</span>x<span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span>\n    y <span class=\"token operator\">=</span> x<span class=\"token punctuation\">.</span>parent\n    <span class=\"token comment\"># x가 부모의 오른쪽 자식인 동안 올라감</span>\n    <span class=\"token keyword\">while</span> y <span class=\"token operator\">!=</span> <span class=\"token boolean\">None</span> <span class=\"token keyword\">and</span> x <span class=\"token operator\">==</span> y<span class=\"token punctuation\">.</span>right<span class=\"token punctuation\">:</span>\n        x <span class=\"token operator\">=</span> y\n        y <span class=\"token operator\">=</span> y<span class=\"token punctuation\">.</span>parent\n    <span class=\"token keyword\">return</span> y  <span class=\"token comment\"># x가 왼쪽 자식이 되는 순간의 부모</span></code></pre></div>\n<p><strong>Predecessor 찾기</strong> (왼쪽 서브트리가 없을 때)</p>\n<ol>\n<li>현재 노드가 부모의 왼쪽 자식인 동안 계속 부모로 올라간다</li>\n<li>처음으로 오른쪽 자식이 되는 순간, 그 부모가 <code class=\"language-text\">Predecessor</code></li>\n</ol>\n<blockquote>\n<p>💡 <strong>왜 이렇게 동작하는가?</strong></p>\n<p>오른쪽 서브트리가 없으면, 현재 노드보다 큰 값은 \"위쪽\"에만 존재한다. 현재 노드가 어떤 조상의 <strong>왼쪽 가지</strong>에 속해있다면, 그 조상이 처음으로 만나는 더 큰 값이다.</p>\n</blockquote>\n<p><strong>📝 예시</strong></p>\n<div class=\"gatsby-highlight\" data-language=\"python\"><pre class=\"language-python\"><code class=\"language-python\"><span class=\"token comment\">#        12</span>\n<span class=\"token comment\">#       /  \\</span>\n<span class=\"token comment\">#      8    14</span>\n<span class=\"token comment\">#       \\</span>\n<span class=\"token comment\">#        9</span>\n\n<span class=\"token comment\"># Successor(9) 찾기:</span>\n<span class=\"token comment\"># 1. 9는 오른쪽 자식이 없음</span>\n<span class=\"token comment\"># 2. 9는 8의 오른쪽 자식 → 올라감</span>\n<span class=\"token comment\"># 3. 8은 12의 왼쪽 자식 → 멈춤</span>\n<span class=\"token comment\"># 4. Successor(9) = 12</span></code></pre></div>\n<hr>\n<h2 id=\"5️-삭제delete\">5️⃣ 삭제(Delete)</h2>\n<p>BST에서 노드 삭제는 자식의 개수에 따라 세 가지 경우로 나뉜다.</p>\n<h4 id=\"5-1-자식이-0개인-경우\">5-1 자식이 0개인 경우</h4>\n<p><strong>🍃 리프 노드 삭제</strong></p>\n<p>가장 간단한 경우다. 해당 노드를 그냥 제거하면 된다.</p>\n<div class=\"gatsby-highlight\" data-language=\"python\"><pre class=\"language-python\"><code class=\"language-python\"><span class=\"token comment\"># 부모의 해당 자식 포인터를 null로 설정</span>\n<span class=\"token keyword\">if</span> node <span class=\"token operator\">==</span> node<span class=\"token punctuation\">.</span>parent<span class=\"token punctuation\">.</span>left<span class=\"token punctuation\">:</span>\n    node<span class=\"token punctuation\">.</span>parent<span class=\"token punctuation\">.</span>left <span class=\"token operator\">=</span> <span class=\"token boolean\">None</span>\n<span class=\"token keyword\">else</span><span class=\"token punctuation\">:</span>\n    node<span class=\"token punctuation\">.</span>parent<span class=\"token punctuation\">.</span>right <span class=\"token operator\">=</span> <span class=\"token boolean\">None</span></code></pre></div>\n<h4 id=\"5-2-자식이-1개인-경우\">5-2 자식이 1개인 경우</h4>\n<p><strong>🔗 자식을 부모와 연결</strong></p>\n<p>삭제할 노드를 건너뛰고, 부모와 유일한 자식을 직접 연결한다.</p>\n<div class=\"gatsby-highlight\" data-language=\"python\"><pre class=\"language-python\"><code class=\"language-python\"><span class=\"token comment\"># 자식을 부모에게 직접 연결</span>\n<span class=\"token keyword\">if</span> node<span class=\"token punctuation\">.</span>left <span class=\"token operator\">!=</span> <span class=\"token boolean\">None</span><span class=\"token punctuation\">:</span>\n    child <span class=\"token operator\">=</span> node<span class=\"token punctuation\">.</span>left\n<span class=\"token keyword\">else</span><span class=\"token punctuation\">:</span>\n    child <span class=\"token operator\">=</span> node<span class=\"token punctuation\">.</span>right\n\n<span class=\"token keyword\">if</span> node <span class=\"token operator\">==</span> node<span class=\"token punctuation\">.</span>parent<span class=\"token punctuation\">.</span>left<span class=\"token punctuation\">:</span>\n    node<span class=\"token punctuation\">.</span>parent<span class=\"token punctuation\">.</span>left <span class=\"token operator\">=</span> child\n<span class=\"token keyword\">else</span><span class=\"token punctuation\">:</span>\n    node<span class=\"token punctuation\">.</span>parent<span class=\"token punctuation\">.</span>right <span class=\"token operator\">=</span> child\nchild<span class=\"token punctuation\">.</span>parent <span class=\"token operator\">=</span> node<span class=\"token punctuation\">.</span>parent</code></pre></div>\n<h4 id=\"5-3-자식이-2개인-경우\">5-3 자식이 2개인 경우</h4>\n<p><strong>🔄 Successor로 치환</strong></p>\n<p>가장 복잡한 경우다. 삭제할 노드의 값을 <code class=\"language-text\">Successor</code>의 값으로 대체한 후, <code class=\"language-text\">Successor</code> 노드를 삭제한다.</p>\n<p><strong>왜 Successor를 사용하는가?</strong></p>\n<ul>\n<li><code class=\"language-text\">Successor</code>는 오른쪽 서브트리의 최소값이므로, 왼쪽 서브트리보다 크고 나머지 오른쪽 서브트리보다 작다.</li>\n<li>오른쪽 서브트리의 최소값은 항상 왼쪽 자식이 없다 (리프 또는 오른쪽 자식만 존재).</li>\n<li>따라서 <code class=\"language-text\">Successor</code> 삭제는 케이스 1 또는 2로 귀착된다.</li>\n</ul>\n<div class=\"gatsby-highlight\" data-language=\"python\"><pre class=\"language-python\"><code class=\"language-python\"><span class=\"token keyword\">def</span> <span class=\"token function\">BST_Delete_TwoChildren</span><span class=\"token punctuation\">(</span>node<span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span>\n    <span class=\"token comment\"># 1. Successor 찾기 (오른쪽 서브트리의 최소값)</span>\n    successor <span class=\"token operator\">=</span> BST_Min<span class=\"token punctuation\">(</span>node<span class=\"token punctuation\">.</span>right<span class=\"token punctuation\">)</span>\n\n    <span class=\"token comment\"># 2. 노드의 값을 Successor의 값으로 교체</span>\n    node<span class=\"token punctuation\">.</span>key <span class=\"token operator\">=</span> successor<span class=\"token punctuation\">.</span>key\n\n    <span class=\"token comment\"># 3. Successor 삭제 (자식 0개 또는 1개)</span>\n    <span class=\"token comment\"># Successor는 왼쪽 자식이 없으므로 간단히 삭제</span>\n    <span class=\"token keyword\">if</span> successor<span class=\"token punctuation\">.</span>right <span class=\"token operator\">!=</span> <span class=\"token boolean\">None</span><span class=\"token punctuation\">:</span>\n        <span class=\"token comment\"># 자식 1개 케이스</span>\n        successor<span class=\"token punctuation\">.</span>parent<span class=\"token punctuation\">.</span>left <span class=\"token operator\">=</span> successor<span class=\"token punctuation\">.</span>right\n        successor<span class=\"token punctuation\">.</span>right<span class=\"token punctuation\">.</span>parent <span class=\"token operator\">=</span> successor<span class=\"token punctuation\">.</span>parent\n    <span class=\"token keyword\">else</span><span class=\"token punctuation\">:</span>\n        <span class=\"token comment\"># 자식 0개 케이스</span>\n        successor<span class=\"token punctuation\">.</span>parent<span class=\"token punctuation\">.</span>left <span class=\"token operator\">=</span> <span class=\"token boolean\">None</span></code></pre></div>\n<p><strong>📝 삭제 과정 예시</strong></p>\n<div class=\"gatsby-highlight\" data-language=\"python\"><pre class=\"language-python\"><code class=\"language-python\"><span class=\"token comment\"># 노드 12 삭제 (자식 2개)</span>\n<span class=\"token comment\">#       12              14</span>\n<span class=\"token comment\">#      /  \\            /  \\</span>\n<span class=\"token comment\">#     8    14   →     8    20</span>\n<span class=\"token comment\">#    / \\     \\       / \\</span>\n<span class=\"token comment\">#   5   9    20     5   9</span>\n\n<span class=\"token comment\"># 1. Successor(12) = 14 찾기</span>\n<span class=\"token comment\"># 2. 12의 값을 14로 교체</span>\n<span class=\"token comment\"># 3. 원래 14 노드 삭제 (자식 1개 케이스)</span></code></pre></div>\n<p>모든 삭제 연산의 시간 복잡도는 <code class=\"language-text\">O(h)</code>다.</p>\n<hr>\n<h2 id=\"6️-시간-복잡도와-효율성\">6️⃣ 시간 복잡도와 효율성</h2>\n<h4 id=\"6-1-높이height의-중요성\">6-1 높이(Height)의 중요성</h4>\n<p><strong>📊 높이가 성능을 결정한다</strong></p>\n<p>BST의 모든 주요 연산은 트리의 높이 <code class=\"language-text\">h</code>에 비례한다:</p>\n<ul>\n<li><code class=\"language-text\">Search</code>, <code class=\"language-text\">Insert</code>, <code class=\"language-text\">Delete</code>: O(h)</li>\n<li><code class=\"language-text\">Min</code>, <code class=\"language-text\">Max</code>: O(h)</li>\n<li><code class=\"language-text\">Predecessor</code>, <code class=\"language-text\">Successor</code>: O(h)</li>\n</ul>\n<p>따라서 <strong>높이를 낮게 유지하는 것이 BST 성능의 핵심</strong>이다.</p>\n<h4 id=\"6-2-균형-트리-vs-편향-트리\">6-2 균형 트리 vs 편향 트리</h4>\n<p><strong>⚖️ 트리의 형태에 따른 성능 차이</strong></p>\n<p>노드가 <code class=\"language-text\">n</code>개일 때:</p>\n<table>\n<thead>\n<tr>\n<th>트리 형태</th>\n<th>높이</th>\n<th>연산 시간 복잡도</th>\n<th>예시</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><strong>균형 트리</strong></td>\n<td>Θ(log n)</td>\n<td>O(log n)</td>\n<td>완전 이진 트리</td>\n</tr>\n<tr>\n<td><strong>편향 트리</strong></td>\n<td>Θ(n)</td>\n<td>O(n)</td>\n<td>연결 리스트처럼 한쪽으로 치우침</td>\n</tr>\n</tbody>\n</table>\n<div class=\"gatsby-highlight\" data-language=\"python\"><pre class=\"language-python\"><code class=\"language-python\"><span class=\"token comment\"># 균형 트리</span>\n<span class=\"token comment\">#       12</span>\n<span class=\"token comment\">#      /  \\</span>\n<span class=\"token comment\">#     8    16</span>\n<span class=\"token comment\">#    / \\   / \\</span>\n<span class=\"token comment\">#   4  10 14  20</span>\n<span class=\"token comment\"># 높이 = 2 (log₂7 ≈ 2.8)</span>\n\n<span class=\"token comment\"># 편향 트리 (최악)</span>\n<span class=\"token comment\">#   4</span>\n<span class=\"token comment\">#    \\</span>\n<span class=\"token comment\">#     8</span>\n<span class=\"token comment\">#      \\</span>\n<span class=\"token comment\">#      10</span>\n<span class=\"token comment\">#       \\</span>\n<span class=\"token comment\">#       12</span>\n<span class=\"token comment\"># 높이 = 3 (선형)</span></code></pre></div>\n<p><strong>🎲 평균 케이스</strong></p>\n<p>입력 키를 무작위 순서로 삽입하면:</p>\n<ul>\n<li>평균 높이는 <code class=\"language-text\">Θ(log n)</code></li>\n<li>평균적으로는 효율적이지만, 최악의 경우 <code class=\"language-text\">O(n)</code>이 될 수 있다</li>\n</ul>\n<blockquote>\n<p>💡 <strong>균형 유지 방법</strong></p>\n<p>높이를 항상 <code class=\"language-text\">O(log n)</code>으로 보장하기 위해 <strong>자가 균형 트리(Self-Balancing Tree)</strong> 가 사용된다. 대표적으로 <code class=\"language-text\">AVL Tree</code>, <code class=\"language-text\">Red-Black Tree</code> 등이 있으며, 삽입/삭제 시 자동으로 트리를 재구성하여 균형을 유지한다.</p>\n</blockquote>\n<hr>\n<h2 id=\"정리\">정리</h2>\n<p><code class=\"language-text\">Binary Search Tree</code>는 효율적인 탐색과 정렬을 제공하는 자료구조임</p>\n<ul>\n<li>BST의 <strong>핵심 규칙</strong>은 왼쪽 &#x3C; 노드 ≤ 오른쪽</li>\n<li>모든 주요 연산의 시간 복잡도는 <strong>O(h)</strong></li>\n<li><code class=\"language-text\">In-order Traversal</code>은 자동으로 <strong>정렬된 출력</strong> 제공</li>\n<li><strong>높이를 낮게 유지</strong>하는 것이 성능의 핵심</li>\n<li>균형 잡힌 트리에서는 <code class=\"language-text\">O(log n)</code>, 편향 트리에서는 <code class=\"language-text\">O(n)</code></li>\n</ul>","fields":{"slug":"/algorithm-binary-search-tree/"},"frontmatter":{"title":"알고리즘설계와분석 - Binary Search Tree (이진 탐색 트리)","date":"2025-12-05","description":"Binary Search Tree(이진 탐색 트리) 의 정의, 핵심 연산, 그리고 시간 복잡도에 관한 모든 것에 대해 알아보자.","pointColor":"#ffffff","tags":["알고리즘"],"keywords":"알고리즘, 이진 탐색 트리, Binary Search Tree, BST, 자료구조, 트리, Tree, 탐색, 삽입, 삭제, 시간 복잡도","thumbnail":{"publicURL":"/static/89e7cfff14d8c7c9b4380204af2cd5d2/index.png","childImageSharp":{"gatsbyImageData":{"layout":"fixed","placeholder":{"fallback":"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAJCAIAAAC9o5sfAAAACXBIWXMAAAsTAAALEwEAmpwYAAAA80lEQVR42mWQyY6DMBBE/f//BIdhOcIRRYhLJMS+w7A4JKm4IoeQOnhp1+tut3go3Q96/GjbtmVZ9HW9yb/r5V9u4uQ7wbju+951XVEUUsqbEoJyf61C556maZ7ndV01j0Nd133fE8jzHCkQRxYaBK1RFBmG4TiO7/uwkkSiNE2HYWB9FKiqCiuvHzjLMtd1Pc+zbbssS0SQAkECaIpuVE6ShK8fOI5j0zQtywLA2eAZldFz0zRsG/FEaRzHd9vckDsMwyAITvPDqLQVHiRCI1i/4ON42QsYfDhTQvOIlEqE6RFHhh/TdWqltm0JAyuUcCD8BM3IB1L6ZIIMAAAAAElFTkSuQmCC"},"backgroundColor":"transparent","images":{"fallback":{"src":"/static/89e7cfff14d8c7c9b4380204af2cd5d2/a7e33/index.png","srcSet":"/static/89e7cfff14d8c7c9b4380204af2cd5d2/a7e33/index.png 990w","sizes":"990px"},"sources":[{"srcSet":"/static/89e7cfff14d8c7c9b4380204af2cd5d2/34133/index.webp 990w","type":"image/webp","sizes":"990px"}]},"width":1200,"height":560},"fixed":{"src":"/static/89e7cfff14d8c7c9b4380204af2cd5d2/035d9/index.png"}}}}},"previous":{"fields":{"slug":"/database-system-erd/"},"frontmatter":{"title":"데이터베이스 시스템 개론 📚 - Chapter2. ERD로 데이터베이스 설계하기"}},"next":{"fields":{"slug":"/algorithm-dynamic-programming/"},"frontmatter":{"title":"알고리즘설계와분석 - Dynamic Programming (동적 계획법)"}}},"pageContext":{"id":"1b4b98fd-9e5f-5564-a004-ea9e94cb1273","previousPostId":"83fce3ff-c65c-5491-83f0-60685623ec84","nextPostId":"f6099559-e2d6-554c-97b6-86c64f3734ff"}},"staticQueryHashes":["736397157"],"slicesMap":{}}