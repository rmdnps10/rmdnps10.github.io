{"componentChunkName":"component---src-templates-blog-post-js","path":"/boj-1106-hotel/","result":{"data":{"site":{"siteMetadata":{"title":"홈","siteUrl":"https://inyoung.dev","author":{"name":"Inyoung Chung"}}},"allMarkdownRemark":{"nodes":[{"fields":{"slug":"/boj-1106-hotel/"},"frontmatter":{"title":"[백준 JAVA] 호텔 1106 머릿속에 박아넣기","date":"2026-02-20","tags":["알고리즘"],"pointColor":"#ffffff"}},{"fields":{"slug":"/http-advanced-features/"},"frontmatter":{"title":"[네트워크] HTTP의 응용 - 쿠키, 캐시, 보안","date":"2026-02-17","tags":["네트워크"],"pointColor":"#ffffff"}},{"fields":{"slug":"/http-fundamentals/"},"frontmatter":{"title":"[네트워크] HTTP의 기초 - DNS와 HTTP Message, Method, Status (스압 주의) ","date":"2026-02-16","tags":["네트워크"],"pointColor":"#ffffff"}},{"fields":{"slug":"/transport-layer-tcp-udp/"},"frontmatter":{"title":"[네트워크] 전송 계층 - TCP와 UDP","date":"2026-02-15","tags":["네트워크"],"pointColor":"#ffffff"}},{"fields":{"slug":"/network-layer-ip-protocol/"},"frontmatter":{"title":"[네트워크] 네트워크 계층과 IP 프로토콜","date":"2026-02-14","tags":["네트워크"],"pointColor":"#ffffff"}},{"fields":{"slug":"/physical-and-data-link-layer/"},"frontmatter":{"title":"[네트워크] 물리 계층과 데이터 링크 계층 - 이더넷과 네트워크 장비","date":"2026-02-13","tags":["네트워크"],"pointColor":"#ffffff"}},{"fields":{"slug":"/network-big-picture/"},"frontmatter":{"title":"[네트워크] 네트워크의 큰 그림","date":"2026-02-12","tags":["네트워크"],"pointColor":"#ffffff"}},{"fields":{"slug":"/troubleshooting-supabase-auth/"},"frontmatter":{"title":"[트러블슈팅] Supabase Auth를 활용한 다양한 환경에서의 세션 유지","date":"2026-02-10","tags":["Web","회고"],"pointColor":"#3ECF8D"}},{"fields":{"slug":"/waterfall-agile/"},"frontmatter":{"title":"[소프트웨어공학] Waterfall과 Agile","date":"2026-02-03","tags":["소프트웨어공학"],"pointColor":"#ffffff"}},{"fields":{"slug":"/os-file-system/"},"frontmatter":{"title":"[운영체제] 파일 시스템","date":"2026-01-27","tags":["운영체제"],"pointColor":"#ffffff"}},{"fields":{"slug":"/os-virtual-memory/"},"frontmatter":{"title":"[운영체제] 5. 가상 메모리","date":"2026-01-26","tags":["운영체제"],"pointColor":"#ffffff"}},{"fields":{"slug":"/os-cpu-scheduling/"},"frontmatter":{"title":"[운영체제] 4. CPU 스케줄링","date":"2026-01-25","tags":["운영체제"],"pointColor":"#ffffff"}},{"fields":{"slug":"/os-synchronization-deadlock/"},"frontmatter":{"title":"[운영체제] 3. 동기화와 교착 상태","date":"2026-01-24","tags":["운영체제"],"pointColor":"#ffffff"}},{"fields":{"slug":"/os-process-thread/"},"frontmatter":{"title":"[운영체제] 2. 프로세스와 스레드","date":"2026-01-23","tags":["운영체제"],"pointColor":"#ffffff"}},{"fields":{"slug":"/os-big-picture/"},"frontmatter":{"title":"[운영체제] 1. 운영체제의 큰 그림","date":"2026-01-21","tags":["운영체제"],"pointColor":"#ffffff"}},{"fields":{"slug":"/computer-architecture-cpu/"},"frontmatter":{"title":"[컴퓨터구조] 3. CPU","date":"2026-01-18","tags":["컴퓨터구조"],"pointColor":"#ffffff"}},{"fields":{"slug":"/computer-architecture-computer-information/"},"frontmatter":{"title":"[컴퓨터구조] 2. 컴퓨터가 이해하는 정보","date":"2026-01-17","tags":["컴퓨터구조"],"pointColor":"#ffffff"}},{"fields":{"slug":"/computer-architecture-big-picture/"},"frontmatter":{"title":"[컴퓨터구조] 1. 컴퓨터구조의 큰 그림","date":"2026-01-15","tags":["컴퓨터구조"],"pointColor":"#ffffff"}},{"fields":{"slug":"/java-coding-test-grammer/"},"frontmatter":{"title":"Java 코딩테스트 문법 최종 정리","date":"2026-01-08","tags":["알고리즘"],"pointColor":"#ed8b00"}},{"fields":{"slug":"/lg-webos-tv-fullstack-appliaction/"},"frontmatter":{"title":"WebOS TV에 들어갈 풀스택 애플리케이션을 만들어보자 (LG전자 산학 프로젝트 후기)","date":"2025-12-22","tags":["회고"],"pointColor":"#ffffff"}},{"fields":{"slug":"/algorithm-maximum-flow/"},"frontmatter":{"title":"알고리즘설계와분석 - 최대 유량 문제 (Maximum Flow)","date":"2025-12-16","tags":["알고리즘"],"pointColor":"#ffffff"}},{"fields":{"slug":"/algorithm-shortest-path/"},"frontmatter":{"title":"알고리즘설계와분석 - 최단경로 (Shortest Path)","date":"2025-12-13","tags":["알고리즘"],"pointColor":"#ffffff"}},{"fields":{"slug":"/algorithm-minimum-spanning-tree/"},"frontmatter":{"title":"알고리즘설계와분석 - MST (최소신장트리)","date":"2025-12-12","tags":["알고리즘"],"pointColor":"#ffffff"}},{"fields":{"slug":"/algorithm-bfs-dfs/"},"frontmatter":{"title":"BFS/DFS와 Topological Sort","date":"2025-12-11","tags":["알고리즘"],"pointColor":"#ffffff"}},{"fields":{"slug":"/algorithm-greedy-algorithm/"},"frontmatter":{"title":"알고리즘설계와분석 - Greedy algorithm (그리디 알고리즘)","date":"2025-12-10","tags":["알고리즘"],"pointColor":"#ffffff"}},{"fields":{"slug":"/algorithm-dynamic-programming/"},"frontmatter":{"title":"알고리즘설계와분석 - Dynamic Programming (동적 계획법)","date":"2025-12-07","tags":["알고리즘"],"pointColor":"#ffffff"}},{"fields":{"slug":"/algorithm-binary-search-tree/"},"frontmatter":{"title":"알고리즘설계와분석 - Binary Search Tree (이진 탐색 트리)","date":"2025-12-05","tags":["알고리즘"],"pointColor":"#ffffff"}},{"fields":{"slug":"/database-system-erd/"},"frontmatter":{"title":"데이터베이스 시스템 개론 📚 - Chapter2. ERD로 데이터베이스 설계하기","date":"2025-10-05","tags":["DB"],"pointColor":"#ffffff"}},{"fields":{"slug":"/make-huggingface-pipeline/"},"frontmatter":{"title":"허깅페이스로 파이프라인을 만들어보자","date":"2025-10-04","tags":["AI"],"pointColor":"#FF9A00"}},{"fields":{"slug":"/rag-core-concept/"},"frontmatter":{"title":"RAG의 핵심 개념과 원리를 실습과 함께 알아봅니다.","date":"2025-10-01","tags":["AI"],"pointColor":"#FF6B6B"}},{"fields":{"slug":"/prompt-engineering-basic/"},"frontmatter":{"title":"프롬프트 엔지니어링 기초 - AI와 효과적으로 소통하는 방법","date":"2025-09-28","tags":["AI"],"pointColor":"#ffffff"}},{"fields":{"slug":"/how-to-use-flutter-riverpod/"},"frontmatter":{"title":"초심자 입장에서 Flutter Riverpod을 '잘' 사용하는 방법 (장문)","date":"2025-09-20","tags":["Flutter"],"pointColor":"#0468d7"}},{"fields":{"slug":"/database-system-introduction/"},"frontmatter":{"title":"데이터베이스 시스템 개론 📚 – Chapter 1. Introduction of Database Systems","date":"2025-09-16","tags":["DB"],"pointColor":"#ffffff"}},{"fields":{"slug":"/kakaobank-devrel-internship-retrospect/"},"frontmatter":{"title":"서비스 개발부터 DevRel까지: 카카오뱅크 인턴쉽 회고","date":"2025-07-28","tags":["인턴","회고","카카오뱅크","네이버랩스"],"pointColor":"#ffe300"}},{"fields":{"slug":"/my-it-startup-internship-retrospect/"},"frontmatter":{"title":"나의 IT 스타트업 인턴쉽 회고","date":"2025-03-14","tags":["인턴","회고"],"pointColor":"#6FE7FF"}},{"fields":{"slug":"/sogang-likelion-management-retrospect/"},"frontmatter":{"title":"서강대학교 멋쟁이사자처럼 운영진 회고","date":"2025-02-27","tags":["멋쟁이사자처럼","회고"],"pointColor":"#FD7911"}}]},"markdownRemark":{"id":"5a4a3655-11d3-5058-b525-adbae1b8b163","excerpt":"…","html":"<h2 id=\"문제\">문제</h2>\n<p><figure class=\"gatsby-resp-image-figure\" style=\"background: transparent;\">\n    <span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 1000px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/static/fef16ecf3d6cb8810d89fe47fcad6b32/0076f/problem.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 42.4%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAICAYAAAD5nd/tAAAACXBIWXMAABYlAAAWJQFJUiTwAAAA3ElEQVR42oVRCQ6EIAz0/y81eKCCHHJ0mSqsMXs0mfSinbZ0xjlSeqcQAh3HUXBq+DXm/UExRnpKzhWZNaRDgZSSlmUhpRRt28aAX+11XUlrfTX3jE8E3NCVCcdx5KbzPLMNPU0T6xq/54QYOA8yDIE31tprwsI2DAMDBU+NQiFE86Wc2Ua873veBM1SSmdDYz3txvEdsAYSv4A3MZ4aN0YMtSmdR+xwD0wA9roSWO/6Dcm3NMYwdPlM+EBb2TpMaBs7WGMM1yQVoeVy/c4vwg31vpMvnwOWfwX/5AXn4G74Euir2AAAAABJRU5ErkJggg=='); background-size: cover; display: block;\"\n  ></span>\n  <picture>\n          <source\n              srcset=\"/static/fef16ecf3d6cb8810d89fe47fcad6b32/bc904/problem.webp 250w,\n/static/fef16ecf3d6cb8810d89fe47fcad6b32/4be29/problem.webp 500w,\n/static/fef16ecf3d6cb8810d89fe47fcad6b32/03f31/problem.webp 1000w,\n/static/fef16ecf3d6cb8810d89fe47fcad6b32/9579c/problem.webp 1500w,\n/static/fef16ecf3d6cb8810d89fe47fcad6b32/b1218/problem.webp 2000w,\n/static/fef16ecf3d6cb8810d89fe47fcad6b32/60261/problem.webp 2490w\"\n              sizes=\"(max-width: 1000px) 100vw, 1000px\"\n              type=\"image/webp\"\n            />\n          <source\n            srcset=\"/static/fef16ecf3d6cb8810d89fe47fcad6b32/43fa5/problem.png 250w,\n/static/fef16ecf3d6cb8810d89fe47fcad6b32/c6e3d/problem.png 500w,\n/static/fef16ecf3d6cb8810d89fe47fcad6b32/da8b6/problem.png 1000w,\n/static/fef16ecf3d6cb8810d89fe47fcad6b32/2e9ed/problem.png 1500w,\n/static/fef16ecf3d6cb8810d89fe47fcad6b32/9fabd/problem.png 2000w,\n/static/fef16ecf3d6cb8810d89fe47fcad6b32/0076f/problem.png 2490w\"\n            sizes=\"(max-width: 1000px) 100vw, 1000px\"\n            type=\"image/png\"\n          />\n          <img\n            class=\"gatsby-resp-image-image\"\n            src=\"/static/fef16ecf3d6cb8810d89fe47fcad6b32/da8b6/problem.png\"\n            alt=\"호텔 1106.JAVA\"\n            title=\"\"\n            loading=\"lazy\"\n            decoding=\"async\"\n            style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n          />\n        </picture>\n  </a>\n    </span>\n    <figcaption class=\"gatsby-resp-image-figcaption\">호텔 1106.JAVA</figcaption>\n  </figure></p>\n<h3 id=\"문제-요약\">문제 요약</h3>\n<p>도시들과 각 도시별로 <code class=\"language-text\">홍보 비용</code>과 그 떄 몇명의 <code class=\"language-text\">고객</code>이 늘어나는지에 대한 정보가 있을 때,\n<code class=\"language-text\">홍보 비용</code>을 <strong>최소한</strong>으로 줄이면서 적어도 <code class=\"language-text\">C</code>명 이상의 <code class=\"language-text\">고객</code>을 유치하고 싶을 때,\n호텔의 비용을 구하여라.</p>\n<h2 id=\"생각의-흐름\">생각의 흐름</h2>\n<h3 id=\"초기\">초기</h3>\n<p>처음에는 그리디 알고리즘을 적용하면 되지 않을까 생각을 했다.\n여러 도시들 중에서, 고객/비용을 나눈 순서로 정렬해서, 거스름돈 거슬러주것마냥 접근하면 그게 무조건 답이 될 수 없는 거 아닌가 생각을 했다.</p>\n<h3 id=\"생각의-문제점\">생각의 문제점</h3>\n<p>예를 들어, 목표 고객 유치수가 12라고 생각해보자.</p>\n<table>\n<thead>\n<tr>\n<th>도시</th>\n<th>비용</th>\n<th>고객</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>A</td>\n<td>3</td>\n<td>5</td>\n</tr>\n<tr>\n<td>B</td>\n<td>4</td>\n<td>6</td>\n</tr>\n</tbody>\n</table>\n<p>내 가설에 따르면 가성비순은 A-B 순이므로 A도시에서 10명의 고객을 유치하고, 그 다음 B도시에서 6명을 유치를 해야할 것이다.\n그렇게 되면 총 비용은 10이다. 하지만 최적해는 B에서 12명을 유치하여 총 비용이 8이다.\n가성비가 제일 떨어지는 회사만 선택이 되었는데, 그게 최적해인 것이다.</p>\n<p>그리디를 하면서 다른 조건을 제약사항으로 걸어주면 되지 않나? 하는 의문이 들었지만,\n이 문제는 <code class=\"language-text\">타겟 넘버</code>가 아닌 적어도 <code class=\"language-text\">타겟 넘버</code> 이상인 고객을 유치할 때 나오는 최솟값도 고려해야한다.</p>\n<p>즉 그리디적 사고방식은 버리는 게 맞다!</p>\n<h3 id=\"적어도-조건이-빠지면-그리디가-될까\">\"적어도\" 조건이 빠지면 그리디가 될까?</h3>\n<p>방금 상황에서, 적어도 고객 12명이 아니라 무조건 12명만을 유치하는 경우를 생각해보자.</p>\n<table>\n<thead>\n<tr>\n<th>도시</th>\n<th>비용</th>\n<th>고객</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>A</td>\n<td>3</td>\n<td>5</td>\n</tr>\n<tr>\n<td>B</td>\n<td>4</td>\n<td>6</td>\n</tr>\n</tbody>\n</table>\n<p>가성비면에선는 A가 우위지만, 최적 비용은 B에서 8을 소모할 때다. 타겟 넘버가 하나로 정해져도, 그리디로 풀 수 없는 문제가 생긴다.\n즉 최소 비용을 구하기 위해서는 모든 도시들에 있어서, 비용 지출을 얼마나 할 지를 고려해야 한다.</p>\n<h3 id=\"그렇다면-언제-그리디가-될까\">그렇다면 언제 그리디가 될까</h3>\n<p>그리디가 되기 위해서는 현재의 선택이 이후 선택에 의해 뒤집혀지지 않아야 한다. 예를 들어 분할이 가능한 배낭 문제, 다익스트라 알고리즘 (최단거리를 poll()할 떄 확정)가 이에 해당하는데...</p>\n<p>이 문제는 (비용, 고객)의 입력이 임의로 주어지게 되므로 반례가 무조건 생긴다.\n직관적으로 그리디가 생각날 수 있지만, 그리디가 되기 위한 조건 자체가 꽤 까다롭다.</p>\n<h2 id=\"풀이\">풀이</h2>\n<h3 id=\"dp-점화식-설정\">DP 점화식 설정</h3>\n<p>DP로 문제를 풀기 위해서는 우선적으로 테이블의 정의와 점화식을 세워야 한다.\n점화식을 어떻게 세워야 할까. 만약에 <code class=\"language-text\">0-1 배낭 문제</code>가 기억에 있다면 (필자도 전공수업 때 지겹게 외웠으나 기억에 없다...), 문제에서 어느 정도의 유사적인 느낌을 받을 수 있을 것이다. 정확히 말하면 이 문제는 하나의 배낭에 하나의 물건을 여러 번 선택할 수 있는 <code class=\"language-text\">무한으로 물건을 선택할 수 있는 배낭 문제</code>에 가깝다.</p>\n<p>비록 <code class=\"language-text\">0-1 배낭 문제</code>의 경우 배낭 선택을 <strong>한 번</strong>만 할 수 있고, 가치 최대가 목표이지만 배낭 문제의 본질을 알면, 이 문제의 점화식을 세우는데 도움이 될 거라고 생각하여 아래에 정리를 해보겠다.</p>\n<h3 id=\"참고--knapnack-problem\">참고 : knapnack problem</h3>\n<p>잠깐 배낭 문제애 대해서 알아보자.\n최대 무게를 <code class=\"language-text\">w</code> 까지 담을 수 있는 배낭이 1개있고, 여기에 무게와 가치가 다른 물건들이 있을 때 가방으로 담을 수 있는 물건의 최대 가치를 구하려면 어떻게 해야 할까?</p>\n<p><figure class=\"gatsby-resp-image-figure\" style=\"background: transparent;\">\n    <span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 1000px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/static/d2ceb54c6054efffd1a3be0a2772f54b/da8b6/bag.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 84%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAARCAIAAABSJhvpAAAACXBIWXMAAAsTAAALEwEAmpwYAAACmElEQVR42m1Ta1PaUBDNv2/VD/ZTrR2nX+yMFh1eTksVAQkJSQigPBIQhAQEQxCCQB4NuTfpkii2ozsZWLi7e/ace0JgjF0/TNNUlAdVeRirI6nTSV0mRVHwPA8hx32JoNjzAxICvlarVbHAFVhGlrqqOhLqNb5YpBmm0Wg4q5UkSY7jBNXwCTnAaNPpcDAgoK112xSFWp6m6FxOFASeh0kFmqLarRZUy7IcNGuadt/vwyHH5BmayqQuibt2S5K6Yr1eKpfyFFUuFQssW+T5mTYFqKenma4vgz1vrsvJ3wmW40LHR+GTULfTWa+NMHZMvTBcNCemYxm6bgSkrtKpg6/7PMdZpgXgeL01yknTSm9sLefAnsDrWP9tYxcezye2sm3YDWZTJAm8SnxhsVj4A7GBPAutM4RQ0LyOZw39RB2N7oDPbbNWqZwnEqcnoVq16iuPXisBOdDQ/mPD7Mnjo67r8HNwfw91sUhke2vr0+7uzvb298ND5MvmILRYLJ9moMmUGCnKeKwCvVTy/Cwa7bTbUHHbbAAmQP84Pvp2cLD/Ze9nPD6dTOC0WrlOJy9i0XA2kyaoHNlqNvIsFzoNF3nOsixohquORyNQyjL5Xk8G5uRVxjAMqXtXFcXYr4tY+FRRFMIXy23PEanAVs/i9Xs92OthONzf+wxb7Hz8wLGMzxQPdCTMnMAyhO84DPdgOu5GucfxGMzA5Gl4bsplOkfqy+WLYC7CblBKuO+FF+zgurZtz+dzyzRlSYI8EHkTr834/2aQHSwlCnUwPGwRi0aWPjjevEn/NgcvDRzPNA1sCN4AqybO4nAR2WyWZZhAy/eRN5iA0O/JqqqCTZI59ipLNhuiaRhv2b3PeTNINlzD8e/D9d42/wUqEprYzFCaPQAAAABJRU5ErkJggg=='); background-size: cover; display: block;\"\n  ></span>\n  <picture>\n          <source\n              srcset=\"/static/d2ceb54c6054efffd1a3be0a2772f54b/bc904/bag.webp 250w,\n/static/d2ceb54c6054efffd1a3be0a2772f54b/4be29/bag.webp 500w,\n/static/d2ceb54c6054efffd1a3be0a2772f54b/03f31/bag.webp 1000w\"\n              sizes=\"(max-width: 1000px) 100vw, 1000px\"\n              type=\"image/webp\"\n            />\n          <source\n            srcset=\"/static/d2ceb54c6054efffd1a3be0a2772f54b/43fa5/bag.png 250w,\n/static/d2ceb54c6054efffd1a3be0a2772f54b/c6e3d/bag.png 500w,\n/static/d2ceb54c6054efffd1a3be0a2772f54b/da8b6/bag.png 1000w\"\n            sizes=\"(max-width: 1000px) 100vw, 1000px\"\n            type=\"image/png\"\n          />\n          <img\n            class=\"gatsby-resp-image-image\"\n            src=\"/static/d2ceb54c6054efffd1a3be0a2772f54b/da8b6/bag.png\"\n            alt=\"가방 문제 (출처-나무위키)\"\n            title=\"\"\n            loading=\"lazy\"\n            decoding=\"async\"\n            style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n          />\n        </picture>\n  </a>\n    </span>\n    <figcaption class=\"gatsby-resp-image-figcaption\">가방 문제 (출처-나무위키)</figcaption>\n  </figure></p>\n<h4 id=\"물건을-쪼갤-수-있을-경우\">물건을 쪼갤 수 있을 경우</h4>\n<p>만약에 물건을 쪼갤 수 있으면, <code class=\"language-text\">가치/무게</code> 가 가장 큰 물건들부터 가방에다가 넣으면 될 것이다.\n그리디하게 접근하면, 쉽게 끝나는 경우이다.</p>\n<h4 id=\"물건을-쪼갤-수-없는-경우\">물건을 쪼갤 수 없는 경우</h4>\n<p>하지만 우리가 아는 DP를 활용한 배낭 문제는 이 경우에 해당한다.\n이 경우에는 <code class=\"language-text\">가치/무게</code>가 제일 높은 물건이라고 해도, 배낭에 넣지 못하는 경우가 생길 수도 있고 물건을 넣지 못할 수 있는 수많은 고려사항들이 존재하기에 다른 방식으로 접근을 해야 되는데, 이때 필요한 접근법이 <code class=\"language-text\">DP</code>이다.</p>\n<p>이 문제는 이렇게 풀면 된다. 먼저 <code class=\"language-text\">dp 테이블</code>을 정의해보자.</p>\n<ul>\n<li><code class=\"language-text\">dp[w] = 가방의 무게 제한이 w일 때 얻을 수 있는 최대 가치</code></li>\n</ul>\n<p>이렇게 설정한 DP 테이블을 업데이트한다는 건 결국 “현재 물건을 넣을지/말지”를 매 순간 선택하는 것이다.</p>\n<p>여기서 유의해야 할점은, 물건 (weight, value)을 한 번만 넣을 수 있으므로 w를 <code class=\"language-text\">큰 쪽</code>에서 <code class=\"language-text\">작은 쪽</code>으로 내림차순으로 내려오며 현재 아이템을 넣지말지에 따라 dp 테이블을 갱신한다.</p>\n<div class=\"gatsby-highlight\" data-language=\"java\"><pre class=\"language-java\"><code class=\"language-java\"><span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token class-name\">Item</span> item <span class=\"token operator\">:</span> items<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span> <span class=\"token comment\">// 이 아이템을 넣거나 넣지 않을건데.</span>\n    <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> w <span class=\"token operator\">=</span> <span class=\"token class-name\">W</span><span class=\"token punctuation\">;</span> w <span class=\"token operator\">>=</span> item<span class=\"token punctuation\">.</span>weight<span class=\"token punctuation\">;</span> w<span class=\"token operator\">--</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span> <span class=\"token comment\">// 목표 무게에서부터 내림차순으로 무게를 순회하면서</span>\n        dp<span class=\"token punctuation\">[</span>w<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> <span class=\"token class-name\">Math</span><span class=\"token punctuation\">.</span><span class=\"token function\">max</span><span class=\"token punctuation\">(</span>dp<span class=\"token punctuation\">[</span>w<span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span> dp<span class=\"token punctuation\">[</span>w <span class=\"token operator\">-</span> item<span class=\"token punctuation\">.</span>weight<span class=\"token punctuation\">]</span> <span class=\"token operator\">+</span> item<span class=\"token punctuation\">.</span>value<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// 해당 dp 테이블을 업데이트한다.</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>왜 내림차순으로 갱신을 해야할까?</p>\n<p>내림차순으로 업데이트를 해야, <code class=\"language-text\">dp[w-item.weight]</code> 가 하나의 아이템의 weight에 대해 <strong>여러 번</strong> 갱신되지 않는다.\n왜 여러 번 갱신되지 않아야 하는지는 <code class=\"language-text\">오름차순</code>으로 <code class=\"language-text\">dp 테이블</code>을 갱신할 경우를 상정하고 물건 하나를 (무게 2, 가치 3) 용량이 4인 가방에 넣는 상황을 살펴보면 자연스럽게 이해할 수 있다.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">&lt;초기 상태>\ndp = [0,0,0,0,0]\n\n무게를 앞에서부터 돌면 range(w~W): 2~4\n\n1️⃣ w = 2\n→ dp[2] = dp[0] + 3 = 3\n\n2️⃣ w = 3\n→ dp[3] = dp[1] + 3 = 3\n\n3️⃣ w = 4\n→ dp[4] = dp[2] + 3 = 6\n</code></pre></div>\n<p>dp[4]를 업데이트할 때의 dp[2]는 같은 라운드에서 방금 만든 값이다. 즉, 같은 물건을 2번 쓴 결과가 되어버린다.\n결론적으로 <code class=\"language-text\">무한으로 물건을 선택할 수 있는 배낭</code>이 돼버린다.</p>\n<h3 id=\"호텔-문제에-적용\">호텔 문제에 적용</h3>\n<p>호텔 문제에서는 <code class=\"language-text\">무한으로 물건을 선택할 수 있는 가방</code>에서 확인한 그 효과를 그대로 적용할 수 있다.\n호텔 문제에서는,</p>\n<ul>\n<li>같은 도시에서 홍보를 <code class=\"language-text\">여러 번</code> 할 수 있고 ( 물건을 여러개 선택해서 가방에 넣는 것과 동일 )</li>\n<li>즉, (비용, 고객) 쌍을 무한히 선택 가능하기 때문이다.</li>\n</ul>\n<p>아래 표와 같이 대응되는 것을 참고하면 좀 더 이해가 쉬울 것이다.</p>\n<table>\n<thead>\n<tr>\n<th>배낭 문제</th>\n<th>호텔 문제</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>가방 용량 (W)</td>\n<td>목표 고객 수 (C)</td>\n</tr>\n<tr>\n<td>물건의 weight</td>\n<td>확보 고객 수 (gain)</td>\n</tr>\n<tr>\n<td>물건의 value</td>\n<td>홍보 비용 (cost)</td>\n</tr>\n<tr>\n<td>가치 최대화</td>\n<td>비용 최소화</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"dp-테이블과-점화식-설정\">DP 테이블과 점화식 설정</h3>\n<p>배낭 문제는 “가치 최대화” 를 목표로 하는데, 호텔은 “비용 최소화” 를 목표로 하는 점에서 차이가 있다.\n그래서 아래와 같이 <code class=\"language-text\">점화식</code> 과 <code class=\"language-text\">dp 테이블</code>을 정의할 수 있다.</p>\n<p><strong>점화식</strong></p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">dp[x] = min(dp[x], dp[x - gain] + cost)</code></pre></div>\n<p><strong>dp 테이블</strong></p>\n<div class=\"gatsby-highlight\" data-language=\"java\"><pre class=\"language-java\"><code class=\"language-java\"><span class=\"token keyword\">int</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> dp <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token keyword\">int</span><span class=\"token punctuation\">[</span>targetCustomers <span class=\"token operator\">+</span> <span class=\"token number\">1001</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// N명의 고객을 유치하는데 드는 최소 비용</span></code></pre></div>\n<p>목표 고객수에 1001을 더한 이유는, '적어도' 조건으로 인해 <code class=\"language-text\">targetCustomers</code> 값보다 큰 값들도 dp 테이블로 관리해야 되기 떄문이다.\n문제 조건에서 유치하는 고객의 수가 최대 1000명이므로, <code class=\"language-text\">targetCusomers</code>가 0일때를 고려하여 1001을 더했다.</p>\n<h3 id=\"dp-테이블-채우기\">DP 테이블 채우기</h3>\n<p>이제, 도시 정보를 순회하면서 무게를 오름차순으로 늘려가면서 dp 테이블을 채우면 된다.</p>\n<div class=\"gatsby-highlight\" data-language=\"java\"><pre class=\"language-java\"><code class=\"language-java\"><span class=\"token class-name\">Arrays</span><span class=\"token punctuation\">.</span><span class=\"token function\">fill</span><span class=\"token punctuation\">(</span>dp<span class=\"token punctuation\">,</span> <span class=\"token number\">100001</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// 최솟값 갱신을 위해 dp 테이블을 최대값으로 채움</span>\ndp<span class=\"token punctuation\">[</span><span class=\"token number\">0</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// 목표 고객 유치수가 0명--> 비용 0</span>\n\n<span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span>arr<span class=\"token operator\">:</span> info<span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span> <span class=\"token comment\">// 도시 정보를 순회하면서</span>\n    <span class=\"token keyword\">int</span> cost <span class=\"token operator\">=</span> arr<span class=\"token punctuation\">[</span><span class=\"token number\">0</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// 해당 도시의 비용</span>\n    <span class=\"token keyword\">int</span> customers <span class=\"token operator\">=</span> arr<span class=\"token punctuation\">[</span><span class=\"token number\">1</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// 해당 도시의 유치할 수 있는 고객 수</span>\n    <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> i<span class=\"token operator\">=</span>customers<span class=\"token punctuation\">;</span> i<span class=\"token operator\">&lt;=</span> targetCustomers<span class=\"token operator\">+</span><span class=\"token number\">1000</span><span class=\"token punctuation\">;</span> i<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n        dp<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> <span class=\"token class-name\">Math</span><span class=\"token punctuation\">.</span><span class=\"token function\">min</span><span class=\"token punctuation\">(</span>dp<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span> cost <span class=\"token operator\">+</span> dp<span class=\"token punctuation\">[</span>i<span class=\"token operator\">-</span>customers<span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>  <span class=\"token comment\">// ⭐️ dp 점화식</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<h3 id=\"출력\">출력</h3>\n<p>마지막에 출력할 때는, 목표 유치 고객수보다 더 많은 값까지 고려해서 제일 작은 값을 출력한다.</p>\n<div class=\"gatsby-highlight\" data-language=\"java\"><pre class=\"language-java\"><code class=\"language-java\"><span class=\"token keyword\">int</span> minCost <span class=\"token operator\">=</span> <span class=\"token number\">100001</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> i<span class=\"token operator\">=</span>targetCustomers<span class=\"token punctuation\">;</span> i<span class=\"token operator\">&lt;=</span>targetCustomers <span class=\"token operator\">+</span> <span class=\"token number\">1000</span><span class=\"token punctuation\">;</span> i<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n    minCost <span class=\"token operator\">=</span> <span class=\"token class-name\">Math</span><span class=\"token punctuation\">.</span><span class=\"token function\">min</span><span class=\"token punctuation\">(</span>minCost<span class=\"token punctuation\">,</span> dp<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token class-name\">System</span><span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">print</span><span class=\"token punctuation\">(</span>minCost<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre></div>\n<h2 id=\"til\">TIL</h2>\n<h3 id=\"그리디-vs-dp-판단-기준\">그리디 vs DP 판단 기준</h3>\n<p>문제를 처음 봤을 때 <code class=\"language-text\">가성비(고객/비용)</code> 기준으로 정렬하여 그리디하게 풀면 되지 않을까 생각했다. 하지만 그리디가 성립하려면 <strong>현재의 선택이 이후 선택에 의해 뒤집히지 않아야</strong> 한다는 조건을 만족해야 한다. 나의 뇌피셜로 그리디하게 접근하는 건 주의해야할 듯</p>\n<h3 id=\"배낭-문제를-이해하자\">배낭 문제를 이해하자</h3>\n<p>DP 문제의 근본인 knapsack problem을 이해하면 자연스럽게 문제가 풀리는 듯 하다.</p>\n<h3 id=\"적어도-조건-처리\">\"적어도\" 조건 처리</h3>\n<p>정확히 C명이 아니라 C명을 초과하는 경우도 고려해야 하므로 다음과 같은 처리가 필요하다.</p>\n<ul>\n<li>DP 테이블 크기를 <code class=\"language-text\">targetCustomers + 1001</code>로 설정</li>\n<li>최종 답을 구할 때 <code class=\"language-text\">targetCustomers</code> 이상의 모든 값을 확인</li>\n</ul>","fields":{"slug":"/boj-1106-hotel/"},"frontmatter":{"title":"[백준 JAVA] 호텔 1106 머릿속에 박아넣기","date":"2026-02-20","description":"DP 관점에서 호텔 1106 문제를 knapsack 0-1 배낭 문제와 함께 완전히 이해해봅니다.","pointColor":"#ffffff","tags":["알고리즘"],"keywords":"백준, 호텔 1106, 백준 JAVA, 다이나믹 프로그래밍, dp","thumbnail":{"publicURL":"/static/9215b4fc4ffdc61030f9d51c226dcf06/index.png","childImageSharp":{"gatsbyImageData":{"layout":"fixed","placeholder":{"fallback":"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAKCAYAAAC0VX7mAAAACXBIWXMAACE4AAAhOAFFljFgAAABGUlEQVR42pWRS2uDQBSF/fkRV64CunMnuHFVuwgBf4ALXYkNVWNKY6iv8VVpPPUONASJNA4cZubeme+euSMwxrCksixRVdVtT+t5bC7hUZAuNE2D6/WKYRjQti2Pd12Hvu/5/DSQYHQhCAJsNhuIogjLsuA4DkzThKIo0HX95nLudhHo+z5kWYYkSdjv9wjDELvdDpqmwTAMZFmGuq7/B95XpeG6Lnepqiq22y08z8M4jot9FJZ6QdXJ6eHwhlfrBbZtc4fknHpasxVA+snz+YxLmiLLc7DvHw4n8dznlMun314DjKIIpyTBexQj+LggSU6TEsRxjOPxiFP69Tzw78mkoiimAgUvQmsS5ZuarevhPZixerZfPv8LnTXsWaZvJ94AAAAASUVORK5CYII="},"backgroundColor":"transparent","images":{"fallback":{"src":"/static/9215b4fc4ffdc61030f9d51c226dcf06/a1758/index.png","srcSet":"/static/9215b4fc4ffdc61030f9d51c226dcf06/a1758/index.png 1200w","sizes":"1200px"},"sources":[{"srcSet":"/static/9215b4fc4ffdc61030f9d51c226dcf06/afc39/index.webp 1200w","type":"image/webp","sizes":"1200px"}]},"width":1200,"height":585},"fixed":{"src":"/static/9215b4fc4ffdc61030f9d51c226dcf06/f3583/index.png"}}}}},"previous":{"fields":{"slug":"/http-advanced-features/"},"frontmatter":{"title":"[네트워크] HTTP의 응용 - 쿠키, 캐시, 보안"}},"next":null},"pageContext":{"id":"5a4a3655-11d3-5058-b525-adbae1b8b163","previousPostId":"38e86be3-f40f-5f57-b738-57e086c6ffbb","nextPostId":null}},"staticQueryHashes":["736397157"],"slicesMap":{}}