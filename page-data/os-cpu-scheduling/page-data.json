{"componentChunkName":"component---src-templates-blog-post-js","path":"/os-cpu-scheduling/","result":{"data":{"site":{"siteMetadata":{"title":"메인","siteUrl":"https://inyoung.dev","author":{"name":"Inyoung Chung"}}},"allMarkdownRemark":{"nodes":[{"fields":{"slug":"/waterfall-agile/"},"frontmatter":{"title":"[소프트웨어공학] Waterfall과 Agile","date":"2026-02-03","tags":["소프트웨어공학"],"pointColor":"#ffffff"}},{"fields":{"slug":"/os-file-system/"},"frontmatter":{"title":"[운영체제] 파일 시스템","date":"2026-01-27","tags":["운영체제"],"pointColor":"#ffffff"}},{"fields":{"slug":"/os-virtual-memory/"},"frontmatter":{"title":"[운영체제] 5. 가상 메모리","date":"2026-01-26","tags":["운영체제"],"pointColor":"#ffffff"}},{"fields":{"slug":"/os-cpu-scheduling/"},"frontmatter":{"title":"[운영체제] 4. CPU 스케줄링","date":"2026-01-25","tags":["운영체제"],"pointColor":"#ffffff"}},{"fields":{"slug":"/os-synchronization-deadlock/"},"frontmatter":{"title":"[운영체제] 3. 동기화와 교착 상태","date":"2026-01-24","tags":["운영체제"],"pointColor":"#ffffff"}},{"fields":{"slug":"/os-process-thread/"},"frontmatter":{"title":"[운영체제] 2. 프로세스와 스레드","date":"2026-01-23","tags":["운영체제"],"pointColor":"#ffffff"}},{"fields":{"slug":"/os-big-picture/"},"frontmatter":{"title":"[운영체제] 1. 운영체제의 큰 그림","date":"2026-01-21","tags":["운영체제"],"pointColor":"#ffffff"}},{"fields":{"slug":"/computer-architecture-cpu/"},"frontmatter":{"title":"[컴퓨터구조] 3. CPU","date":"2026-01-18","tags":["컴퓨터구조"],"pointColor":"#ffffff"}},{"fields":{"slug":"/computer-architecture-computer-information/"},"frontmatter":{"title":"[컴퓨터구조] 2. 컴퓨터가 이해하는 정보","date":"2026-01-17","tags":["컴퓨터구조"],"pointColor":"#ffffff"}},{"fields":{"slug":"/computer-architecture-big-picture/"},"frontmatter":{"title":"[컴퓨터구조] 1. 컴퓨터구조의 큰 그림","date":"2026-01-15","tags":["컴퓨터구조"],"pointColor":"#ffffff"}},{"fields":{"slug":"/java-coding-test-grammer/"},"frontmatter":{"title":"Java 코딩테스트 문법 최종 정리","date":"2026-01-08","tags":["알고리즘"],"pointColor":"#ed8b00"}},{"fields":{"slug":"/lg-webos-tv-fullstack-appliaction/"},"frontmatter":{"title":"WebOS TV에 들어갈 풀스택 애플리케이션을 만들어보자 (LG전자 산학 프로젝트 후기)","date":"2025-12-22","tags":["회고"],"pointColor":"#ffffff"}},{"fields":{"slug":"/algorithm-maximum-flow/"},"frontmatter":{"title":"알고리즘설계와분석 - 최대 유량 문제 (Maximum Flow)","date":"2025-12-16","tags":["알고리즘"],"pointColor":"#ffffff"}},{"fields":{"slug":"/algorithm-shortest-path/"},"frontmatter":{"title":"알고리즘설계와분석 - 최단경로 (Shortest Path)","date":"2025-12-13","tags":["알고리즘"],"pointColor":"#ffffff"}},{"fields":{"slug":"/algorithm-minimum-spanning-tree/"},"frontmatter":{"title":"알고리즘설계와분석 - MST (최소신장트리)","date":"2025-12-12","tags":["알고리즘"],"pointColor":"#ffffff"}},{"fields":{"slug":"/algorithm-bfs-dfs/"},"frontmatter":{"title":"알고리즘설계와분석 - BFS/DFS와 Topological Sort","date":"2025-12-11","tags":["알고리즘"],"pointColor":"#ffffff"}},{"fields":{"slug":"/algorithm-greedy-algorithm/"},"frontmatter":{"title":"알고리즘설계와분석 - Greedy algorithm (그리디 알고리즘)","date":"2025-12-10","tags":["알고리즘"],"pointColor":"#ffffff"}},{"fields":{"slug":"/algorithm-dynamic-programming/"},"frontmatter":{"title":"알고리즘설계와분석 - Dynamic Programming (동적 계획법)","date":"2025-12-07","tags":["알고리즘"],"pointColor":"#ffffff"}},{"fields":{"slug":"/algorithm-binary-search-tree/"},"frontmatter":{"title":"알고리즘설계와분석 - Binary Search Tree (이진 탐색 트리)","date":"2025-12-05","tags":["알고리즘"],"pointColor":"#ffffff"}},{"fields":{"slug":"/database-system-erd/"},"frontmatter":{"title":"데이터베이스 시스템 개론 📚 - Chapter2. ERD로 데이터베이스 설계하기","date":"2025-10-05","tags":["DB"],"pointColor":"#ffffff"}},{"fields":{"slug":"/make-huggingface-pipeline/"},"frontmatter":{"title":"허깅페이스로 파이프라인을 만들어보자 - 트랜스포머 모델 활용 가이드","date":"2025-10-04","tags":["AI"],"pointColor":"#FF9A00"}},{"fields":{"slug":"/rag-core-concept/"},"frontmatter":{"title":"RAG의 핵심 개념과 실습","date":"2025-10-01","tags":["AI"],"pointColor":"#FF6B6B"}},{"fields":{"slug":"/prompt-engineering-basic/"},"frontmatter":{"title":"프롬프트 엔지니어링 기초 - AI와 효과적으로 소통하는 방법","date":"2025-09-28","tags":["AI"],"pointColor":"#ffffff"}},{"fields":{"slug":"/how-to-use-flutter-riverpod/"},"frontmatter":{"title":"초심자 입장에서 Flutter Riverpod을 '잘' 사용하는 방법 (장문)","date":"2025-09-20","tags":["Flutter"],"pointColor":"#0468d7"}},{"fields":{"slug":"/database-system-introduction/"},"frontmatter":{"title":"데이터베이스 시스템 개론 📚 – Chapter 1. Introduction of Database Systems","date":"2025-09-16","tags":["DB"],"pointColor":"#ffffff"}},{"fields":{"slug":"/kakaobank-devrel-internship-retrospect/"},"frontmatter":{"title":"서비스 개발부터 DevRel까지: 카카오뱅크 인턴쉽 회고","date":"2025-07-28","tags":["인턴","회고","카카오뱅크","네이버랩스"],"pointColor":"#ffe300"}},{"fields":{"slug":"/my-it-startup-internship-retrospect/"},"frontmatter":{"title":"나의 IT 스타트업 인턴쉽 회고","date":"2025-03-14","tags":["인턴","회고"],"pointColor":"#6FE7FF"}},{"fields":{"slug":"/sogang-likelion-management-retrospect/"},"frontmatter":{"title":"서강대학교 멋쟁이사자처럼 운영진 회고","date":"2025-02-27","tags":["멋쟁이사자처럼","회고"],"pointColor":"#FD7911"}}]},"markdownRemark":{"id":"9e765125-acd0-5406-b767-ae2e8bd61808","excerpt":"운영체제는 CPU 자원을 효율적으로 관리하기 위해 프로세스에 CPU 사용 시간을 배분한다. 이 글에서는 CPU 스케줄링의 기본 개념과 다양한 스케줄링 알고리즘을 다룬다. 1️⃣ CPU 스케줄링의 개념 은 운영체제가 프로세스에 CPU 사용 시간을 배분하는 방법을 말한다. CPU…","html":"<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 1000px; background: transparent;\"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/static/018d7db3eaa9b892020711f5bfbfb253/7c474/index.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 48.800000000000004%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAKCAYAAAC0VX7mAAAACXBIWXMAACE4AAAhOAFFljFgAAABYElEQVR42o1SS0sCURS+o/2FAntsekC7kCCCwpZRLYKoX9C6MkedyVaZj0ZFRGV8kDagBRHtWhRtemxrUZsCf8zXPUcnQzRdfJzHPfc73z33CHEURCcUCUdIgyJB1nGst/1Wvts9RtdkUIXwHUCo3ra1QXHANxghKROaivF4FGsXFSyaeaxbFayUi+x7ygWsVs8xm05x065K/wZOKpAKti9reGw0EHq4x933F9KvL7De35B4fsL15wd2b2+4ztmPkOZDz3HnMti5qmMuk2byBTPHyggbVhXz+SzX9VXI0AMQfi9DoVkd7jfnxlbCu9eeIdX2ImzOz4/ReAQjkRO4YhFWQmqHo2FMpwx4SgVs1WvYrFlYKpoYkr8v9P8Uyo6u2CkmjJgkDWMyeYYZSTQmm0wlDeknsFwymcydzbQIA32eLFUSbMX8m/YluQG8UgQ6G2QPFfv5HX4z1n5zSo89/AGjQpu7+ui03gAAAABJRU5ErkJggg=='); background-size: cover; display: block;\"\n  ></span>\n  <picture>\n          <source\n              srcset=\"/static/018d7db3eaa9b892020711f5bfbfb253/bc904/index.webp 250w,\n/static/018d7db3eaa9b892020711f5bfbfb253/4be29/index.webp 500w,\n/static/018d7db3eaa9b892020711f5bfbfb253/03f31/index.webp 1000w,\n/static/018d7db3eaa9b892020711f5bfbfb253/84f56/index.webp 1329w\"\n              sizes=\"(max-width: 1000px) 100vw, 1000px\"\n              type=\"image/webp\"\n            />\n          <source\n            srcset=\"/static/018d7db3eaa9b892020711f5bfbfb253/43fa5/index.png 250w,\n/static/018d7db3eaa9b892020711f5bfbfb253/c6e3d/index.png 500w,\n/static/018d7db3eaa9b892020711f5bfbfb253/da8b6/index.png 1000w,\n/static/018d7db3eaa9b892020711f5bfbfb253/7c474/index.png 1329w\"\n            sizes=\"(max-width: 1000px) 100vw, 1000px\"\n            type=\"image/png\"\n          />\n          <img\n            class=\"gatsby-resp-image-image\"\n            src=\"/static/018d7db3eaa9b892020711f5bfbfb253/da8b6/index.png\"\n            alt=\"index\"\n            title=\"\"\n            loading=\"lazy\"\n            decoding=\"async\"\n            style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n          />\n        </picture>\n  </a>\n    </span></p>\n<blockquote>\n<p>운영체제는 CPU 자원을 효율적으로 관리하기 위해 프로세스에 CPU 사용 시간을 배분한다. 이 글에서는 CPU 스케줄링의 기본 개념과 다양한 스케줄링 알고리즘을 다룬다.</p>\n</blockquote>\n<h2 id=\"1️-cpu-스케줄링의-개념\">1️⃣ CPU 스케줄링의 개념</h2>\n<p><code class=\"language-text\">CPU 스케줄링(CPU Scheduling)</code>은 운영체제가 프로세스에 CPU 사용 시간을 배분하는 방법을 말한다.</p>\n<h3 id=\"cpu-스케줄링의-구성-요소\">CPU 스케줄링의 구성 요소</h3>\n<ul>\n<li><strong>CPU 스케줄링 알고리즘</strong>: CPU 스케줄링의 절차를 정의한 알고리즘</li>\n<li><strong>CPU 스케줄러(CPU Scheduler)</strong>: 스케줄링 알고리즘을 결정하고 수행하는 운영체제의 구성 요소</li>\n</ul>\n<blockquote>\n<p>💡 <strong>스케줄링의 대상</strong></p>\n<p>프로세스뿐만 아니라 스레드도 CPU 스케줄링의 대상이다. 실행의 문맥을 가지고 있는 모든 것을 스케줄링할 수 있기 때문이다. 일반적으로 '프로세스를 스케줄링한다'는 표현은 실행의 문맥이 있는 모든 대상을 의미한다.</p>\n</blockquote>\n<h2 id=\"2️-우선순위-priority\">2️⃣ 우선순위 (Priority)</h2>\n<h3 id=\"우선순위의-필요성\">우선순위의 필요성</h3>\n<p>운영체제는 CPU 자원을 공정하고 합리적으로 프로세스에 할당해야 한다. 여기서 공정한 배분이란 단순히 돌아가면서 CPU를 할당하는 것이 아니라, <strong>프로세스의 우선순위</strong>를 고려한 배분을 의미한다.</p>\n<h4 id=\"2-1-우선순위의-특징\">2-1 우선순위의 특징</h4>\n<ul>\n<li>프로세스별로 다른 우선순위를 가짐</li>\n<li>PCB에 명시됨</li>\n<li>우선순위가 높은 프로세스는 CPU 자원을 더 빨리, 더 많이 할당받음</li>\n<li>사용자가 일부 프로세스의 우선순위를 직접 조정할 수 있음</li>\n</ul>\n<h4 id=\"2-2-우선순위-확인-방법\">2-2 우선순위 확인 방법</h4>\n<p><strong>유닉스/리눅스/맥OS에서 우선순위 확인</strong></p>\n<div class=\"gatsby-highlight\" data-language=\"bash\"><pre class=\"language-bash\"><code class=\"language-bash\">$ <span class=\"token function\">ps</span> <span class=\"token parameter variable\">-l</span>\nF S <span class=\"token environment constant\">UID</span>  PID  <span class=\"token environment constant\">PPID</span>  C PRI NI ADDR SZ WCHAN  TTY      TIME CMD\n<span class=\"token number\">0</span> S <span class=\"token number\">1000</span> <span class=\"token number\">4412</span> <span class=\"token number\">4409</span>  <span class=\"token number\">0</span>  <span class=\"token number\">80</span>  <span class=\"token number\">0</span>    - <span class=\"token number\">3210</span> do_wat pts/0 00:00:00 <span class=\"token function\">bash</span>\n<span class=\"token number\">0</span> R <span class=\"token number\">1000</span> <span class=\"token number\">5149</span> <span class=\"token number\">4412</span>  <span class=\"token number\">0</span>  <span class=\"token number\">80</span>  <span class=\"token number\">0</span>    - <span class=\"token number\">3495</span>        pts/0 00:00:00 <span class=\"token function\">ps</span></code></pre></div>\n<p><code class=\"language-text\">PRI</code> 열에서 프로세스의 우선순위를 확인할 수 있다.</p>\n<p><strong>Windows에서 우선순위 확인</strong></p>\n<p>Process Explorer의 'Priority' 항목을 통해 확인할 수 있다. 이 외에도 다음 정보를 확인할 수 있다:</p>\n<ul>\n<li>Threads: 스레드 수</li>\n<li>Context Switches: 문맥 교환 발생 횟수</li>\n</ul>\n<h3 id=\"cpu-활용률과-우선순위\">CPU 활용률과 우선순위</h3>\n<p>운영체제는 <code class=\"language-text\">CPU 활용률</code>을 높게 유지할 수 있도록 우선순위를 할당한다.</p>\n<p><code class=\"language-text\">CPU 활용률</code>: 전체 CPU 가동 시간 중 작업을 처리하는 시간의 비율을 의미한다.</p>\n<h4 id=\"2-3-cpu-버스트와-입출력-버스트\">2-3 CPU 버스트와 입출력 버스트</h4>\n<p>대부분의 프로세스는 CPU와 입출력장치를 번갈아 사용하며 실행된다:</p>\n<table>\n<thead>\n<tr>\n<th>개념</th>\n<th>설명</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>CPU 버스트(CPU Burst)</td>\n<td>프로세스가 CPU를 이용하는 작업</td>\n</tr>\n<tr>\n<td>입출력 버스트(I/O Burst)</td>\n<td>프로세스가 입출력장치를 기다리는 작업</td>\n</tr>\n</tbody>\n</table>\n<h4 id=\"2-4-프로세스의-분류\">2-4 프로세스의 분류</h4>\n<p>프로세스는 CPU와 입출력장치 사용 비율에 따라 분류된다:</p>\n<table>\n<thead>\n<tr>\n<th>분류</th>\n<th>설명</th>\n<th>예시</th>\n<th>주로 머무는 상태</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>입출력 집중 프로세스(I/O Bound Process)</td>\n<td>입출력 작업이 많은 프로세스</td>\n<td>비디오 재생, 디스크 백업</td>\n<td>대기 상태</td>\n</tr>\n<tr>\n<td>CPU 집중 프로세스(CPU Bound Process)</td>\n<td>CPU 작업이 많은 프로세스</td>\n<td>수학 연산, 그래픽 처리</td>\n<td>실행 상태</td>\n</tr>\n</tbody>\n</table>\n<p><strong>⚡ 입출력 집중 프로세스의 우선순위가 높은 이유</strong></p>\n<p>입출력 집중 프로세스를 먼저 실행하여 입출력장치를 작동시킨 후, CPU 집중 프로세스에 CPU를 할당하는 것이 CPU 활용률을 높이는 데 효율적이다:</p>\n<ol>\n<li>입출력 집중 프로세스 먼저 실행</li>\n<li>입출력 작업 시작 → 프로세스는 대기 상태로 전환</li>\n<li>CPU 집중 프로세스가 CPU 사용</li>\n<li>CPU 활용률 증가</li>\n</ol>\n<h2 id=\"3️-스케줄링-큐-scheduling-queue\">3️⃣ 스케줄링 큐 (Scheduling Queue)</h2>\n<p>운영체제는 프로세스에게 자원을 이용하려면 <strong>큐에 줄을 서서 기다릴 것</strong>을 요구한다.</p>\n<h3 id=\"스케줄링-큐의-종류\">스케줄링 큐의 종류</h3>\n<p><code class=\"language-text\">스케줄링 큐</code>는 프로세스들이 자원을 기다리는 줄을 구현한 자료구조다:</p>\n<ul>\n<li>CPU를 이용하고 싶은 프로세스의 PCB</li>\n<li>메모리에 적재되고 싶은 프로세스의 PCB</li>\n<li>특정 입출력장치를 이용하고 싶은 프로세스의 PCB</li>\n</ul>\n<blockquote>\n<p>💡 <strong>스케줄링 큐의 특징</strong></p>\n<p>자료구조 관점에서 큐는 선입선출(FIFO) 구조를 따르지만, 스케줄링에 사용되는 큐가 반드시 선입선출일 필요는 없다. 우선순위를 고려하여 순서를 조정할 수 있다.</p>\n</blockquote>\n<h4 id=\"3-1-대표적인-스케줄링-큐\">3-1 대표적인 스케줄링 큐</h4>\n<p><strong>준비 큐 (Ready Queue)</strong></p>\n<p>CPU를 이용하고 싶은 프로세스의 PCB가 대기하는 큐다.</p>\n<ul>\n<li>준비 상태인 프로세스의 PCB가 삽입됨</li>\n<li>우선순위가 높은 프로세스부터 먼저 실행됨</li>\n</ul>\n<p><strong>대기 큐 (Waiting Queue)</strong></p>\n<p>대기 상태에 접어든 프로세스의 PCB가 대기하는 큐다.</p>\n<ul>\n<li>주로 입출력 작업을 수행 중일 때 사용</li>\n<li>입출력 완료 인터럽트를 기다림</li>\n</ul>\n<h3 id=\"프로세스의-큐-이동\">프로세스의 큐 이동</h3>\n<p>프로세스는 상태에 따라 다양한 큐를 이동한다:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">[준비 큐] → [실행] → [대기 큐] → [준비 큐]\n            ↓\n         [종료]</code></pre></div>\n<h4 id=\"3-2-큐-이동의-조건\">3-2 큐 이동의 조건</h4>\n<table>\n<thead>\n<tr>\n<th>상태 전환</th>\n<th>발생 조건</th>\n<th>이동 방향</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>실행 → 준비</td>\n<td>타이머 인터럽트 발생 (시간 할당 완료)</td>\n<td>준비 큐로 이동</td>\n</tr>\n<tr>\n<td>실행 → 대기</td>\n<td>입출력 작업 수행</td>\n<td>대기 큐로 이동</td>\n</tr>\n<tr>\n<td>대기 → 준비</td>\n<td>입출력 완료 인터럽트 발생</td>\n<td>준비 큐로 이동</td>\n</tr>\n</tbody>\n</table>\n<p><strong>🔄 입출력 완료 처리 과정</strong></p>\n<ol>\n<li>입출력 완료 인터럽트 발생</li>\n<li>운영체제가 대기 큐에서 완료된 PCB 탐색</li>\n<li>해당 PCB를 준비 상태로 변경</li>\n<li>대기 큐에서 제거</li>\n<li>준비 큐로 이동</li>\n</ol>\n<h2 id=\"4️-선점형과-비선점형-스케줄링\">4️⃣ 선점형과 비선점형 스케줄링</h2>\n<p>스케줄링은 기본적으로 프로세스의 실행이 끝나면 이루어진다. 하지만 프로세스가 종료되지 않았음에도 스케줄링이 수행되는 경우가 있다.</p>\n<h3 id=\"스케줄링이-발생하는-시점\">스케줄링이 발생하는 시점</h3>\n<p>프로세스 실행 도중 스케줄링이 이루어지는 대표적인 두 시점:</p>\n<ol>\n<li><strong>실행 상태 → 대기 상태</strong>: 입출력 작업을 위해 대기 상태로 전환</li>\n<li><strong>실행 상태 → 준비 상태</strong>: 타이머 인터럽트 발생</li>\n</ol>\n<h4 id=\"4-1-선점형-스케줄링\">4-1 선점형 스케줄링</h4>\n<p><code class=\"language-text\">선점형 스케줄링</code>은 현재 프로세스가 CPU를 사용하고 있더라도 운영체제가 CPU 자원을 강제로 빼앗아 다른 프로세스에 할당할 수 있는 스케줄링 방식이다.</p>\n<p><strong>✅ 장점</strong></p>\n<ul>\n<li>더 급한 프로세스가 끼어들어 CPU를 사용할 수 있음</li>\n<li>한 프로세스의 CPU 독점을 방지</li>\n<li>여러 프로세스에 골고루 CPU 자원을 배분</li>\n</ul>\n<p><strong>⚠️ 단점</strong></p>\n<ul>\n<li>문맥 교환 과정에서 오버헤드 발생 가능</li>\n</ul>\n<h4 id=\"4-2-비선점형-스케줄링\">4-2 비선점형 스케줄링</h4>\n<p><code class=\"language-text\">비선점형 스케줄링</code>은 프로세스가 종료되거나 스스로 대기 상태에 접어들기 전까지 다른 프로세스가 끼어들 수 없는 스케줄링 방식이다.</p>\n<p><strong>✅ 장점</strong></p>\n<ul>\n<li>문맥 교환 횟수가 적어 오버헤드 발생이 적음</li>\n</ul>\n<p><strong>⚠️ 단점</strong></p>\n<ul>\n<li>CPU를 사용 중인 프로세스가 있으면 급한 프로세스도 무작정 기다려야 함</li>\n</ul>\n<h2 id=\"5️-전통적-cpu-스케줄링-알고리즘\">5️⃣ 전통적 CPU 스케줄링 알고리즘</h2>\n<p>전통적으로 많은 교재에서 소개되는 대표적인 CPU 스케줄링 알고리즘을 살펴본다.</p>\n<h3 id=\"fcfs-first-come-first-served\">FCFS (First Come First Served)</h3>\n<p><code class=\"language-text\">FCFS 스케줄링</code>은 준비 큐에 삽입된 순서대로 프로세스를 실행하는 <strong>비선점형</strong> 스케줄링 방식이다.</p>\n<h4 id=\"5-1-fcfs의-특징\">5-1 FCFS의 특징</h4>\n<ul>\n<li>가장 단순한 스케줄링 알고리즘</li>\n<li>먼저 CPU를 요청한 프로세스부터 CPU를 할당받음</li>\n</ul>\n<p><strong>⚠️ <code class=\"language-text\">호위 효과</code></strong></p>\n<p>먼저 삽입된 프로세스의 오랜 실행 시간으로 인해 나중에 삽입된 프로세스의 실행이 지연되는 문제를 말한다.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">준비 큐: [프로세스 A(20ms)] → [프로세스 B(10ms)] → [프로세스 C(5ms)]\n\n실행 순서: A(20ms) → B(10ms) → C(5ms)\n대기 시간: A(0ms), B(20ms), C(30ms) ← 호위 효과 발생</code></pre></div>\n<h3 id=\"sjf-shortest-job-first\">SJF (Shortest Job First)</h3>\n<p><code class=\"language-text\">SJF 스케줄링</code>은 CPU를 이용하는 시간의 길이가 가장 짧은 프로세스부터 실행하는 스케줄링 방식이다.</p>\n<h4 id=\"5-2-sjf의-특징\">5-2 SJF의 특징</h4>\n<ul>\n<li>기본적으로 <strong>비선점형</strong> 스케줄링</li>\n<li>평균 대기 시간을 최소화할 수 있음</li>\n</ul>\n<blockquote>\n<p>💡 <strong>SJF의 선점형 버전</strong></p>\n<p>SJF는 선점형으로도 구현될 수 있다. 이를 <strong>최소 잔여 시간 우선(SRT) 스케줄링</strong>이라고 한다.</p>\n</blockquote>\n<h3 id=\"round-robin\">Round Robin</h3>\n<p><code class=\"language-text\">라운드 로빈 스케줄링</code>은 FCFS에 타임 슬라이스 개념이 더해진 <strong>선점형</strong> 스케줄링 방식이다.</p>\n<h4 id=\"5-3-라운드-로빈의-구성-요소\">5-3 라운드 로빈의 구성 요소</h4>\n<p><strong>🕐 타임 슬라이스 (Time Slice)</strong></p>\n<p>프로세스가 CPU를 사용하도록 정해진 시간을 의미한다.</p>\n<ul>\n<li>프로세스는 정해진 타임 슬라이스만큼만 CPU를 이용</li>\n<li>타임 슬라이스를 모두 사용하면 문맥 교환 발생</li>\n<li>프로세스는 준비 큐의 맨 뒤에 재삽입</li>\n</ul>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">준비 큐: [P1(10ms)] → [P2(5ms)] → [P3(8ms)]\n타임 슬라이스: 4ms\n\n실행 순서:\nP1(4ms) → P2(4ms) → P3(4ms) → P1(4ms) → P3(4ms) → P1(2ms) → P2(1ms)</code></pre></div>\n<h3 id=\"srt-shortest-remaining-time\">SRT (Shortest Remaining Time)</h3>\n<p><code class=\"language-text\">SRT 스케줄링</code>은 SJF와 라운드 로빈을 합친 <strong>선점형</strong> 스케줄링 방식이다.</p>\n<h4 id=\"5-4-srt의-특징\">5-4 SRT의 특징</h4>\n<ul>\n<li>정해진 타임 슬라이스만큼 CPU를 이용</li>\n<li>남아 있는 작업 시간이 가장 적은 프로세스를 다음 실행 대상으로 선택</li>\n</ul>\n<h3 id=\"우선순위-스케줄링-priority-scheduling\">우선순위 스케줄링 (Priority Scheduling)</h3>\n<p><code class=\"language-text\">우선순위 스케줄링</code>은 프로세스에 우선순위를 부여하고, 가장 높은 우선순위를 가진 프로세스부터 실행하는 방식이다.</p>\n<h4 id=\"5-5-우선순위-스케줄링의-문제점\">5-5 우선순위 스케줄링의 문제점</h4>\n<p><strong>🚨 아사 현상 (Starvation)</strong></p>\n<p>우선순위가 낮은 프로세스는 우선순위가 높은 프로세스로 인해 계속해서 실행이 연기될 수 있다.</p>\n<p><strong>💊 에이징 (Aging)</strong></p>\n<p>아사 현상을 방지하기 위한 기법으로, 오랫동안 대기한 프로세스의 우선순위를 점차 높이는 방식이다.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">초기 우선순위: P1(10), P2(5), P3(3)\n에이징 적용 후: P1(10), P2(5→7), P3(3→6)</code></pre></div>\n<h3 id=\"다단계-큐-multilevel-queue\">다단계 큐 (Multilevel Queue)</h3>\n<p><code class=\"language-text\">다단계 큐 스케줄링</code>은 우선순위별로 여러 개의 준비 큐를 사용하는 스케줄링 방식이다.</p>\n<h4 id=\"5-6-다단계-큐의-동작-방식\">5-6 다단계 큐의 동작 방식</h4>\n<ol>\n<li>우선순위가 가장 높은 큐의 프로세스를 먼저 처리</li>\n<li>해당 큐가 비어 있으면 다음 우선순위 큐의 프로세스 처리</li>\n</ol>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">[우선순위 0 큐] → CPU 할당\n[우선순위 1 큐] → 우선순위 0이 비어 있을 때 CPU 할당\n[우선순위 2 큐] → 우선순위 0, 1이 비어 있을 때 CPU 할당</code></pre></div>\n<p><strong>⚠️ 문제점</strong></p>\n<p>프로세스들이 큐 사이를 이동할 수 없기 때문에 우선순위가 낮은 프로세스의 작업이 계속해서 연기될 수 있다 (아사 현상).</p>\n<h3 id=\"다단계-피드백-큐-multilevel-feedback-queue\">다단계 피드백 큐 (Multilevel Feedback Queue)</h3>\n<p><code class=\"language-text\">다단계 피드백 큐 스케줄링</code>은 다단계 큐와 비슷하지만, <strong>프로세스들이 큐 사이를 이동할 수 있다</strong>는 점에서 차이가 있다.</p>\n<h4 id=\"5-7-다단계-피드백-큐의-동작-방식\">5-7 다단계 피드백 큐의 동작 방식</h4>\n<ol>\n<li>새로운 프로세스는 우선순위가 가장 높은 큐에 삽입</li>\n<li>타임 슬라이스 동안 실행</li>\n<li>실행이 끝나지 않으면 다음 우선순위 큐로 이동</li>\n<li>오래 CPU를 사용해야 하는 프로세스의 우선순위가 점차 낮아짐</li>\n</ol>\n<p><strong>🎯 특징</strong></p>\n<ul>\n<li>CPU 집중 프로세스의 우선순위는 자연스럽게 낮아짐</li>\n<li>입출력 집중 프로세스는 높은 우선순위 큐에서 실행 완료</li>\n<li>에이징 기법 적용 가능 (낮은 우선순위 큐에서 오래 기다린 프로세스를 높은 우선순위 큐로 이동)</li>\n</ul>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">[우선순위 0 큐] 타임 슬라이스: 2ms\n       ↓ (완료되지 않으면)\n[우선순위 1 큐] 타임 슬라이스: 4ms\n       ↓ (완료되지 않으면)\n[우선순위 2 큐] 타임 슬라이스: 8ms</code></pre></div>\n<h2 id=\"6️-리눅스-cpu-스케줄링\">6️⃣ 리눅스 CPU 스케줄링</h2>\n<p>실제 리눅스 운영체제에서는 상황에 따라 다양한 스케줄링 알고리즘이 사용된다.</p>\n<h3 id=\"스케줄링-정책-scheduling-policy\">스케줄링 정책 (Scheduling Policy)</h3>\n<p><code class=\"language-text\">스케줄링 정책</code>은 새로운 프로세스를 언제 어떻게 선택하여 실행할지를 결정하기 위한 규칙의 집합이다.</p>\n<h4 id=\"6-1-리눅스의-스케줄링-정책\">6-1 리눅스의 스케줄링 정책</h4>\n<table>\n<thead>\n<tr>\n<th>스케줄링 정책</th>\n<th>적용 상황</th>\n<th>스케줄러</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>SCHED_FIFO</td>\n<td>실시간 프로세스 (매우 높은 우선순위)</td>\n<td>RT 스케줄러</td>\n</tr>\n<tr>\n<td>SCHED_RR</td>\n<td>실시간 프로세스 (매우 높은 우선순위)</td>\n<td>RT 스케줄러</td>\n</tr>\n<tr>\n<td>SCHED_NORMAL</td>\n<td>일반적인 프로세스</td>\n<td>CFS 스케줄러</td>\n</tr>\n<tr>\n<td>SCHED_BATCH</td>\n<td>배치 작업 (자주 선점하지 않음)</td>\n<td>CFS 스케줄러</td>\n</tr>\n<tr>\n<td>SCHED_IDLE</td>\n<td>우선순위가 매우 낮은 프로세스</td>\n<td>CFS 스케줄러</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"cfs-completely-fair-scheduler\">CFS (Completely Fair Scheduler)</h3>\n<p><code class=\"language-text\">CFS</code>는 SCHED_NORMAL 정책 하에서 일반적인 프로세스에 적용되는 CPU 스케줄러다.</p>\n<h4 id=\"6-2-cfs의-특징\">6-2 CFS의 특징</h4>\n<p><strong>🎯 완전히 공평한 CPU 시간 배분</strong></p>\n<p>CFS는 이름처럼 프로세스에 대해 <strong>완전히 공평한 CPU 시간 배분</strong>을 지향한다.</p>\n<h4 id=\"6-3-가상-실행-시간-vruntime\">6-3 가상 실행 시간 (vruntime)</h4>\n<p><code class=\"language-text\">vruntime(Virtual Runtime)</code>은 프로세스의 가중치를 고려한 가상의 실행 시간이다.</p>\n<p><strong>vruntime 계산 공식</strong></p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">vruntime = 실제 실행 시간 × (평균 가중치 / 프로세스의 가중치)</code></pre></div>\n<p><strong>vruntime의 특징</strong></p>\n<ul>\n<li>가중치가 높을수록 vruntime이 천천히 증가</li>\n<li>vruntime이 가장 작은 프로세스부터 스케줄링</li>\n<li>프로세스의 가중치가 높을수록 먼저 스케줄링될 확률이 높음</li>\n</ul>\n<blockquote>\n<p>💡 <strong>가중치 (Weight)</strong></p>\n<p>가중치는 프로세스의 우선순위와 연관된 값으로, 프로세스의 우선순위가 높아질수록 가중치도 높아진다.</p>\n</blockquote>\n<h4 id=\"6-4-타임-슬라이스-계산\">6-4 타임 슬라이스 계산</h4>\n<p>CFS에서 프로세스의 타임 슬라이스는 가중치에 따라 결정된다:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">타임 슬라이스 = (프로세스의 가중치 / 전체 가중치) × 전체 타임 슬라이스 합</code></pre></div>\n<p><strong>📊 특징</strong></p>\n<ul>\n<li>프로세스의 가중치가 높아지면 타임 슬라이스도 크게 할당받음</li>\n<li>우선순위가 높은 프로세스는 더 오래 CPU를 사용할 수 있음</li>\n</ul>\n<h4 id=\"6-5-vruntime과-가중치-확인\">6-5 vruntime과 가중치 확인</h4>\n<p>리눅스에서는 다음 명령어로 프로세스의 vruntime과 가중치를 확인할 수 있다:</p>\n<div class=\"gatsby-highlight\" data-language=\"bash\"><pre class=\"language-bash\"><code class=\"language-bash\">$ <span class=\"token function\">cat</span> /proc/<span class=\"token operator\">&lt;</span>PID<span class=\"token operator\">></span>/sched</code></pre></div>\n<p>예를 들어, PID가 34913인 프로세스의 정보를 확인:</p>\n<div class=\"gatsby-highlight\" data-language=\"bash\"><pre class=\"language-bash\"><code class=\"language-bash\">$ <span class=\"token function\">cat</span> /proc/34913/sched\nse.vruntime              <span class=\"token builtin class-name\">:</span> <span class=\"token number\">12345678.123456</span>\nse.sum_exec_runtime      <span class=\"token builtin class-name\">:</span> <span class=\"token number\">1234.567890</span>\nse.load.weight           <span class=\"token builtin class-name\">:</span> <span class=\"token number\">1024</span></code></pre></div>\n<h2 id=\"7️-정리\">7️⃣ 정리</h2>\n<p>CPU 스케줄링의 핵심 개념을 정리하면 다음과 같다:</p>\n<p><strong>스케줄링 기본 개념</strong></p>\n<ul>\n<li><strong>우선순위</strong>: CPU 활용률을 높이기 위해 입출력 집중 프로세스의 우선순위가 높음</li>\n<li><strong>스케줄링 큐</strong>: 준비 큐와 대기 큐를 통해 프로세스 관리</li>\n<li><strong>선점형/비선점형</strong>: 문맥 교환 빈도와 응답 시간의 트레이드오프</li>\n</ul>\n<p><strong>전통적 스케줄링 알고리즘</strong></p>\n<table>\n<thead>\n<tr>\n<th>알고리즘</th>\n<th>유형</th>\n<th>특징</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>FCFS</td>\n<td>비선점형</td>\n<td>단순하지만 호위 효과 발생</td>\n</tr>\n<tr>\n<td>SJF</td>\n<td>비선점형</td>\n<td>평균 대기 시간 최소화</td>\n</tr>\n<tr>\n<td>Round Robin</td>\n<td>선점형</td>\n<td>타임 슬라이스 기반 공평한 배분</td>\n</tr>\n<tr>\n<td>SRT</td>\n<td>선점형</td>\n<td>SJF + 타임 슬라이스</td>\n</tr>\n<tr>\n<td>우선순위</td>\n<td>선점형/비선점형</td>\n<td>아사 현상 발생 가능 (에이징으로 해결)</td>\n</tr>\n<tr>\n<td>다단계 큐</td>\n<td>선점형</td>\n<td>우선순위별 큐 분리</td>\n</tr>\n<tr>\n<td>다단계 피드백 큐</td>\n<td>선점형</td>\n<td>큐 간 이동 가능</td>\n</tr>\n</tbody>\n</table>\n<p><strong>리눅스 스케줄링</strong></p>\n<ul>\n<li><strong>RT 스케줄러</strong>: 실시간 프로세스 (FIFO, RR)</li>\n<li><strong>CFS 스케줄러</strong>: 일반 프로세스 (vruntime 기반 공평한 배분)</li>\n</ul>\n<p>이러한 스케줄링 기법들은 운영체제가 제한된 CPU 자원을 효율적으로 관리하고, 모든 프로세스에 공정한 실행 기회를 제공하는 핵심 메커니즘이다.</p>","fields":{"slug":"/os-cpu-scheduling/"},"frontmatter":{"title":"[운영체제] 4. CPU 스케줄링","date":"2026-01-25","description":"이것이 취업을 위한 컴퓨터 과학이다 + 혼자 공부하는 컴퓨터 구조/운영체제를 읽으면서 배운 내용을 정리합니다.","pointColor":"#ffffff","tags":["운영체제"],"keywords":"운영체제, OS, CPU스케줄링, 스케줄링알고리즘, FCFS, SJF, 라운드로빈, 우선순위스케줄링, CFS, 리눅스","thumbnail":{"publicURL":"/static/018d7db3eaa9b892020711f5bfbfb253/index.png","childImageSharp":{"gatsbyImageData":{"layout":"fixed","placeholder":{"fallback":"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAKCAYAAAC0VX7mAAAACXBIWXMAACE4AAAhOAFFljFgAAABYElEQVR42o1SS0tCURA+V/sLBfbY9IB2IUEEhS2jWgRRv6B1ZV713myV+eiqiKhcH6Rd0IKIdi2KNj22tahNgT/m68zoTTBNFx8z55yZb76ZM0IcBdENioQjpEGRIOs41tt+675rbi9CEVQhfAcQqrdtbdA54BuMkJQJTcV4PIq1iwoWzTzWrQpWykX2PeUCVqvnmE2nuOgfpZ2ETgqQCrYva3hsNBB6uMfd9xfSry+w3t+QeH7C9ecHdm9vOM7Zj5DmQ+24cxnsXNUxl0kz+YKZY2WEDauK+XyW4/oqZOgBCL+XodCsDvebc2Mr4d1rz5BiexE25+fHaDyCkcgJXLEIKyG1w9EwplMGPKUCtuo1bNYsLBVNDMnfF/p/CmVFV+wUE0ZMkoYxmTzDjCQak0Wmkob0E1gumUzmzmZahIE+LUuVBFsx/6adJDeAV4pAb4PsoWK33+E3z9rvndJFzA88Vpu7x0Oy6QAAAABJRU5ErkJggg=="},"backgroundColor":"transparent","images":{"fallback":{"src":"/static/018d7db3eaa9b892020711f5bfbfb253/a1758/index.png","srcSet":"/static/018d7db3eaa9b892020711f5bfbfb253/a1758/index.png 1200w","sizes":"1200px"},"sources":[{"srcSet":"/static/018d7db3eaa9b892020711f5bfbfb253/afc39/index.webp 1200w","type":"image/webp","sizes":"1200px"}]},"width":1200,"height":585},"fixed":{"src":"/static/018d7db3eaa9b892020711f5bfbfb253/f3583/index.png"}}}}},"previous":{"fields":{"slug":"/os-synchronization-deadlock/"},"frontmatter":{"title":"[운영체제] 3. 동기화와 교착 상태"}},"next":{"fields":{"slug":"/os-virtual-memory/"},"frontmatter":{"title":"[운영체제] 5. 가상 메모리"}}},"pageContext":{"id":"9e765125-acd0-5406-b767-ae2e8bd61808","previousPostId":"0077ac62-c74c-5450-9e62-16dc465e0ea3","nextPostId":"dc18f114-802b-5431-b431-81f1c9a487d3"}},"staticQueryHashes":["736397157"],"slicesMap":{}}