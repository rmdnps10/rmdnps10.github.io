{"componentChunkName":"component---src-templates-blog-post-js","path":"/algorithm-greedy-algorithm/","result":{"data":{"site":{"siteMetadata":{"title":"메인","siteUrl":"https://inyoung.dev","author":{"name":"Inyoung Chung"}}},"markdownRemark":{"id":"9f0a213a-1795-5f0a-bba8-6a25051310eb","excerpt":"학부 수업 \"알고리즘설계와분석\"에서 배운 내용을 정리합니다. Greedy Algorithm의 기본 개념과 Interval Scheduling, Huffman Coding 등 대표적인 문제를 학습해보자. 1️⃣ Greedy Algorithm 기본 개념 Greedy Algorithm…","html":"<blockquote>\n<p>학부 수업 \"알고리즘설계와분석\"에서 배운 내용을 정리합니다.</p>\n</blockquote>\n<p>Greedy Algorithm의 기본 개념과 Interval Scheduling, Huffman Coding 등 대표적인 문제를 학습해보자.</p>\n<h2 id=\"1️-greedy-algorithm-기본-개념\">1️⃣ Greedy Algorithm 기본 개념</h2>\n<p>Greedy Algorithm은 <strong>매 단계에서 지역적으로 최선의 선택(local optimum)</strong> 을 하는 알고리즘이다.</p>\n<h3 id=\"핵심-아이디어\">핵심 아이디어</h3>\n<p>전체 문제를 한꺼번에 고려하지 않고, <strong>현재 순간의 최선</strong>만 고른다. 이러한 지역적 선택이 전역 최적해(global optimum)를 보장하지는 않지만, 특정 문제에서는 최적해를 찾을 수 있으며 <strong>계산이 매우 효율적</strong>이다.</p>\n<h3 id=\"특징\">특징</h3>\n<table>\n<thead>\n<tr>\n<th>특징</th>\n<th>설명</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>지역적(local) 선택 기반</td>\n<td>매 단계에서 최선만 고려, 미래는 고려하지 않음</td>\n</tr>\n<tr>\n<td>전역적(global) 최적 해 보장 불확실</td>\n<td>문제에 따라 최적해를 찾을 수도, 못 찾을 수도 있음</td>\n</tr>\n<tr>\n<td>빠른 계산</td>\n<td>계산량이 작고 구현이 간단함</td>\n</tr>\n<tr>\n<td>일부 문제에서 최적</td>\n<td>Interval Scheduling, Huffman Coding 등</td>\n</tr>\n</tbody>\n</table>\n<h2 id=\"2️-interval-scheduling-problem\">2️⃣ Interval Scheduling Problem</h2>\n<h3 id=\"문제-정의\">문제 정의</h3>\n<p><code class=\"language-text\">n</code>개의 활동 <code class=\"language-text\">A₁, A₂, ..., Aₙ</code>이 주어지고, 각 활동은 시작시간 <code class=\"language-text\">sᵢ</code>와 종료시간 <code class=\"language-text\">fᵢ</code>를 가진다. <strong>활동들이 시간적으로 겹치지 않게 하면서</strong> 선택 가능한 <strong>최대 활동 개수</strong>를 찾는 문제다.</p>\n<blockquote>\n<p>💡 <strong>조건</strong></p>\n<p>어떤 두 활동도 시간적으로 겹치면 안 된다. 즉, <code class=\"language-text\">[sᵢ, fᵢ) ∩ [sⱼ, fⱼ) = ∅</code></p>\n</blockquote>\n<p>🔥 <strong>Brute-force 접근</strong></p>\n<p>모든 가능한 활동 조합을 고려하면 경우의 수가 <code class=\"language-text\">2ⁿ</code> 또는 <code class=\"language-text\">n!</code> 수준으로 폭발한다. 시간 복잡도가 지수적(exponential)이므로 비효율적이다.</p>\n<h3 id=\"greedy-전략-탐색\">Greedy 전략 탐색</h3>\n<h4 id=\"2-1-가장-빨리-시작하는-활동-선택\">2-1 가장 빨리 시작하는 활동 선택</h4>\n<p><strong>전략</strong>: 가장 일찍 시작하는 활동을 선택한다.</p>\n<p><strong>결과</strong>: ❌ 비최적. 가장 일찍 시작하는 활동이 다른 많은 활동들과 겹쳐서 최대 개수를 선택하지 못할 수 있다.</p>\n<h4 id=\"2-2-가장-짧은-활동-선택\">2-2 가장 짧은 활동 선택</h4>\n<p><strong>전략</strong>: 가장 짧은 활동을 선택한다.</p>\n<p><strong>결과</strong>: ❌ 비최적. 짧지만 중간에 위치해서 다른 활동들을 막을 수 있다.</p>\n<h4 id=\"2-3-충돌이-가장-적은-활동-선택\">2-3 충돌이 가장 적은 활동 선택</h4>\n<p><strong>전략</strong>: 다른 활동과 겹치는 횟수가 가장 적은 활동을 선택한다.</p>\n<p><strong>결과</strong>: ❌ 비최적. 각 활동마다 나머지 <code class=\"language-text\">n-1</code>개 활동과 비교해야 하므로 <code class=\"language-text\">O(n²)</code> 계산이 필요하고, 최적 해를 보장하지도 않는다.</p>\n<h4 id=\"2-4-가장-빨리-끝나는-활동-선택-earliest-finish-time\">2-4 가장 빨리 끝나는 활동 선택 (Earliest Finish Time)</h4>\n<p><strong>전략</strong>: 가장 일찍 끝나는 활동부터 차례로 선택한다.</p>\n<p><strong>결과</strong>: ✅ 최적. 가장 빨리 끝나는 활동을 선택하면 <strong>남은 시간 구간이 가장 넓게 남아</strong> 이후 활동을 가장 많이 배치할 수 있다.</p>\n<p>🔥 <strong>Stay-Ahead Argument</strong></p>\n<p>우리가 선택한 첫 번째 활동은 모든 다른 해의 첫 활동보다 일찍 끝난다. 따라서 다음 활동을 고를 때 항상 더 많은 후보를 가질 수 있으며, 이 성질이 계속 유지되므로 최종 해는 항상 최적이다.</p>\n<h3 id=\"최적-알고리즘\">최적 알고리즘</h3>\n<h4 id=\"알고리즘-절차\">알고리즘 절차</h4>\n<ol>\n<li>모든 활동을 <strong>종료시간 기준 오름차순으로 정렬</strong>한다.</li>\n<li>첫 번째 활동을 선택한다.</li>\n<li>이후 선택된 활동과 겹치지 않는 (즉, <code class=\"language-text\">start_time ≥ last_finish_time</code>) 활동 중 가장 빨리 끝나는 것을 고른다.</li>\n<li>남은 활동이 없을 때까지 반복한다.</li>\n</ol>\n<h4 id=\"의사코드\">의사코드</h4>\n<div class=\"gatsby-highlight\" data-language=\"python\"><pre class=\"language-python\"><code class=\"language-python\"><span class=\"token keyword\">def</span> <span class=\"token function\">GreedyIntervalScheduling</span><span class=\"token punctuation\">(</span>activities<span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span>\n    <span class=\"token comment\"># 활동들을 종료 시간 기준으로 정렬</span>\n    activities<span class=\"token punctuation\">.</span>sort<span class=\"token punctuation\">(</span>key<span class=\"token operator\">=</span><span class=\"token keyword\">lambda</span> a<span class=\"token punctuation\">:</span> a<span class=\"token punctuation\">.</span>finish<span class=\"token punctuation\">)</span>\n    R <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span>\n    last_finish <span class=\"token operator\">=</span> <span class=\"token number\">0</span>\n\n    <span class=\"token keyword\">for</span> a <span class=\"token keyword\">in</span> activities<span class=\"token punctuation\">:</span>\n        <span class=\"token keyword\">if</span> a<span class=\"token punctuation\">.</span>start <span class=\"token operator\">>=</span> last_finish<span class=\"token punctuation\">:</span>\n            R<span class=\"token punctuation\">.</span>append<span class=\"token punctuation\">(</span>a<span class=\"token punctuation\">)</span>\n            last_finish <span class=\"token operator\">=</span> a<span class=\"token punctuation\">.</span>finish\n\n    <span class=\"token keyword\">return</span> R</code></pre></div>\n<h4 id=\"시간-복잡도\">시간 복잡도</h4>\n<table>\n<thead>\n<tr>\n<th>단계</th>\n<th>내용</th>\n<th>시간</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>정렬</td>\n<td>종료시간 기준 정렬</td>\n<td><code class=\"language-text\">O(n log n)</code></td>\n</tr>\n<tr>\n<td>선택 반복</td>\n<td>겹치지 않는지 확인</td>\n<td><code class=\"language-text\">O(n)</code></td>\n</tr>\n<tr>\n<td><strong>총합</strong></td>\n<td></td>\n<td><strong><code class=\"language-text\">O(n log n)</code></strong></td>\n</tr>\n</tbody>\n</table>\n<p>Greedy임에도 불구하고 이 문제에서는 <strong>항상 최적해를 보장</strong>한다.</p>\n<h2 id=\"3️-huffman-coding\">3️⃣ Huffman Coding</h2>\n<h3 id=\"문제-배경\">문제 배경</h3>\n<p>파일을 비트로 표현할 때 <strong>필요한 비트 수를 최소화</strong>하는 것이 목표다. 문자가 4개라면 각 문자를 <code class=\"language-text\">log₂(4) = 2비트</code>로 표현할 수 있다.</p>\n<blockquote>\n<p>💡 <strong>고정 길이 인코딩의 한계</strong></p>\n<p>예: <code class=\"language-text\">A = 00, B = 01, C = 10, D = 11</code></p>\n<p>모든 문자를 2비트로 표현하지만, 실제 파일에서 문자의 등장 빈도는 다르다. 자주 등장하는 문자를 짧은 비트로, 드물게 등장하는 문자를 긴 비트로 표현하면 더 효율적이다.</p>\n</blockquote>\n<h3 id=\"가변-길이-인코딩의-문제점\">가변 길이 인코딩의 문제점</h3>\n<p>만약 <code class=\"language-text\">A = 0, B = 01, C = 10, D = 11</code>로 설정하면 겉보기엔 압축이 성공한 것처럼 보이지만 <strong>디코딩이 불가능</strong>하다.</p>\n<p>예를 들어 <code class=\"language-text\">01</code>을 받았을 때, 첫 <code class=\"language-text\">0</code>이 <code class=\"language-text\">A</code>일 수도 있고 전체 <code class=\"language-text\">01</code>이 <code class=\"language-text\">B</code>일 수도 있다. 이런 코드는 <strong>모호하며(ambiguous)</strong> uniquely decodable하지 않다.</p>\n<h3 id=\"prefix-free-code\">Prefix-Free Code</h3>\n<p><strong>Prefix-free code</strong>는 어떤 코드워드도 다른 코드워드의 접두사가 되지 않는 코드다.</p>\n<p>예시:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">A = 0\nB = 100\nC = 101\nD = 11</code></pre></div>\n<p>여기서 <code class=\"language-text\">0</code>, <code class=\"language-text\">100</code>, <code class=\"language-text\">101</code>, <code class=\"language-text\">11</code>은 서로 접두사 관계가 없으므로 <strong>유일하게 해독 가능</strong>하다.</p>\n<p>🔥 <strong>Binary Tree 표현</strong></p>\n<p>Prefix-free code는 이진 트리로 나타낼 수 있다.</p>\n<ul>\n<li>왼쪽 가지 = <code class=\"language-text\">0</code>, 오른쪽 가지 = <code class=\"language-text\">1</code></li>\n<li><strong>모든 문자는 리프(leaf)에 위치</strong></li>\n<li>리프까지 내려가면 해당 문자를 출력하고 다시 루트로 돌아감</li>\n</ul>\n<p>예를 들어 비트열 <code class=\"language-text\">010011101...</code>을 해독하면:</p>\n<ul>\n<li><code class=\"language-text\">0</code> → <code class=\"language-text\">A</code></li>\n<li><code class=\"language-text\">100</code> → <code class=\"language-text\">B</code></li>\n<li><code class=\"language-text\">11</code> → <code class=\"language-text\">D</code></li>\n<li><code class=\"language-text\">101</code> → <code class=\"language-text\">C</code></li>\n</ul>\n<h3 id=\"huffman-tree-구성\">Huffman Tree 구성</h3>\n<h4 id=\"알고리즘-원리\">알고리즘 원리</h4>\n<p><strong>빈도가 낮은 두 문자를 합쳐서 새 노드로 만든다.</strong> 그 합친 노드를 다시 힙에 넣고 반복한다.</p>\n<h4 id=\"알고리즘-절차-1\">알고리즘 절차</h4>\n<ol>\n<li>문자들과 그 빈도를 <strong>최소 힙(min heap)</strong> 에 넣는다.</li>\n<li>가장 작은 두 빈도 <code class=\"language-text\">x, y</code>를 꺼내 새 노드 <code class=\"language-text\">z</code>를 생성한다. <code class=\"language-text\">f(z) = f(x) + f(y)</code></li>\n<li>새 <code class=\"language-text\">z</code>를 힙에 다시 삽입한다.</li>\n<li>힙에 하나만 남을 때까지 반복한다.</li>\n</ol>\n<p>남은 트리가 바로 <strong>Huffman Tree</strong>다.</p>\n<h4 id=\"시간-복잡도-1\">시간 복잡도</h4>\n<ul>\n<li><code class=\"language-text\">make-heap</code>: <code class=\"language-text\">O(n)</code></li>\n<li><code class=\"language-text\">extract-min</code> × <code class=\"language-text\">2(n-1)</code>회 + <code class=\"language-text\">insert</code>: <code class=\"language-text\">O(n log n)</code></li>\n</ul>\n<p><strong>전체 <code class=\"language-text\">O(n log n)</code></strong></p>\n<h3 id=\"full-binary-tree-구조\">Full Binary Tree 구조</h3>\n<p>Huffman Tree는 반드시 다음을 만족한다:</p>\n<ul>\n<li>모든 <strong>내부 노드는 자식 2개</strong>를 가진다.</li>\n<li>리프 노드는 문자 1개를 가진다.</li>\n<li>전체 노드 수 = <code class=\"language-text\">2n - 1</code> (리프 <code class=\"language-text\">n</code>개일 때)</li>\n</ul>\n<p>🔥 <strong>코드 생성 방식</strong></p>\n<p>루트에서 리프까지의 경로가 그 문자의 코드워드가 된다. 왼쪽 간선은 <code class=\"language-text\">0</code>, 오른쪽 간선은 <code class=\"language-text\">1</code>이다.</p>\n<h3 id=\"최적성-증명\">최적성 증명</h3>\n<p>가장 빈도 낮은 두 문자를 먼저 결합하는 것이 항상 최적이다. 두 최소빈도 <code class=\"language-text\">f₁, f₂</code>가 트리의 가장 깊은 곳에 배치되어야 최적이며, 만약 더 큰 빈도의 문자가 더 깊게 들어가면 <code class=\"language-text\">f × depth</code> 합이 커져 비효율적이다.</p>\n<p>따라서 <strong>Greedy하게 최소 2개씩 결합하는 Huffman 알고리즘이 전역적으로 최적</strong>이다.</p>\n<h3 id=\"huffman-tree-전송\">Huffman Tree 전송</h3>\n<p>문자열을 인코딩해서 전송할 때, 수신자가 디코딩하려면 <strong>동일한 Huffman Tree를 알아야 한다.</strong> 따라서 전송해야 할 정보는 두 가지다.</p>\n<h4 id=\"트리-구조-전송\">트리 구조 전송</h4>\n<p>Full binary tree이므로 preorder 순회하면서 내부 노드는 <code class=\"language-text\">0</code>, 리프 노드는 <code class=\"language-text\">1</code>로 표시하면 구조 복원이 가능하다.</p>\n<p>트리의 노드 수 = <code class=\"language-text\">2n - 1</code>이므로 구조 전송 비용은 <strong><code class=\"language-text\">2n - 1</code> 비트</strong>다.</p>\n<h4 id=\"리프-문자-목록-전송\">리프 문자 목록 전송</h4>\n<p>리프 수 = <code class=\"language-text\">n</code>, 각 문자를 표현하는 데 <code class=\"language-text\">log₂ n</code> 비트가 필요하므로 총 <strong><code class=\"language-text\">n log n</code> 비트</strong>가 필요하다.</p>\n<p>🔥 <strong>전체 Huffman Tree 전송 비용</strong></p>\n<p><code class=\"language-text\">(2n - 1) + n log n</code> 비트</p>\n<h3 id=\"ascii-환경에서의-효율성\">ASCII 환경에서의 효율성</h3>\n<p>문자 256개가 있고 최대 빈도와 최소 빈도의 차이가 2배 미만이라면, 빈도 차이가 너무 작아 깊이 차이가 거의 없다. Huffman Tree가 사실상 완전 이진 트리처럼 되어 각 문자 코드 길이가 약 8비트가 되므로, <strong>Huffman Coding이 고정 8비트 ASCII보다 전혀 이득이 없다.</strong></p>\n<h2 id=\"4️-greedy-algorithm의-한계\">4️⃣ Greedy Algorithm의 한계</h2>\n<h3 id=\"0-1-knapsack-problem\">0-1 Knapsack Problem</h3>\n<p><strong>문제</strong>: 배낭의 용량 <code class=\"language-text\">W</code>가 주어지고, 각 물건은 무게 <code class=\"language-text\">wᵢ</code>와 가치 <code class=\"language-text\">vᵢ</code>를 가진다. 가치를 최대화하면서 무게 합이 <code class=\"language-text\">W</code> 이하가 되도록 물건을 선택해야 한다.</p>\n<p><strong>Greedy 전략</strong>: 가치/무게 비율(<code class=\"language-text\">vᵢ / wᵢ</code>)이 가장 큰 순서로 담는다.</p>\n<p><strong>결과</strong>: ❌ 0-1 버전에서는 부분적으로 담을 수 없기 때문에 Greedy가 실패한다. <strong>Dynamic Programming</strong>으로 풀어야 한다.</p>\n<blockquote>\n<p>💡 <strong>Fractional Knapsack</strong></p>\n<p>물건을 부분적으로 담을 수 있는 Fractional Knapsack에서는 Greedy가 최적해를 찾는다. 비율순 정렬 후 담으면 <code class=\"language-text\">O(n log n)</code>에 해결 가능하다.</p>\n</blockquote>\n<h3 id=\"정리\">정리</h3>\n<table>\n<thead>\n<tr>\n<th>개념</th>\n<th>핵심 아이디어</th>\n<th>복잡도</th>\n<th>비고</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>Interval Scheduling</td>\n<td>가장 빨리 끝나는 활동 선택</td>\n<td><code class=\"language-text\">O(n log n)</code></td>\n<td>Greedy로 최적</td>\n</tr>\n<tr>\n<td>Huffman Coding</td>\n<td>가장 빈도 낮은 두 기호 병합</td>\n<td><code class=\"language-text\">O(n log n)</code></td>\n<td>Greedy로 최적</td>\n</tr>\n<tr>\n<td>Prefix-Free Code</td>\n<td>어떤 코드도 다른 코드의 접두사 아님</td>\n<td>–</td>\n<td>Unique decoding 가능</td>\n</tr>\n<tr>\n<td>Full Binary Tree</td>\n<td>각 노드는 자식 0개 또는 2개</td>\n<td>–</td>\n<td>최적 prefix code는 항상 full tree</td>\n</tr>\n<tr>\n<td>Fractional Knapsack</td>\n<td>비율순 정렬 후 담기</td>\n<td><code class=\"language-text\">O(n log n)</code></td>\n<td>Greedy로 최적</td>\n</tr>\n<tr>\n<td>0-1 Knapsack</td>\n<td>Greedy 실패</td>\n<td>NP-Hard</td>\n<td>Dynamic Programming 필요</td>\n</tr>\n</tbody>\n</table>","fields":{"slug":"/algorithm-greedy-algorithm/"},"frontmatter":{"title":"알고리즘설계와분석 - Greedy algorithm (그리디 알고리즘)","date":"2025-12-10","description":"매 순간 최선의 선택을 하는 Greedy Algorithm의 원리와 대표 문제들을 정리한다.","pointColor":"#ffffff","tags":["알고리즘"],"keywords":"알고리즘, 그리디, Greedy Algorithm, 탐욕 알고리즘, 최적화, Interval Scheduling, Huffman Coding, 알고리즘 설계","thumbnail":{"publicURL":"/static/fa3ecd56bbab38cc6f07c72d5501f06b/index.png","childImageSharp":{"gatsbyImageData":{"layout":"fixed","placeholder":{"fallback":"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAJCAIAAAC9o5sfAAAACXBIWXMAAAsTAAALEwEAmpwYAAABeUlEQVR42k1RTW/TQBD1/z/1B3BAQgpFuZRbVUoRafiQaOPYThMnbp0gkw2xd+drd8uVsStQrKfZtzOa2TfPCSESKf5/eBJ7gghe5DkEVkrIRK3rPpVzQJecduLpFH5pBR/4prp6/eVVDY+BAw7jjrbVYkJa9hJjiDH64BFAMziAmXwQFDepby4W401XetJcr/RlcqKX9bosijzP52W50gnDe04jHIx5qsyvXfDyJ0YH3eG4B7AKLSoSLdxOJqPRaDwen5+/LfKsa49aEOF6Or08OzNZxl7AdsLYND8fHgpwlmloFqFVufx4/WE+T9PZ/Wx2dzB7ZgyR0RrbbAl/KyfS5Z91DRJPIYqP2BuGqDsrVEIMXpfn3iws0+r+a2YN/ZimVbFlaHfLy6flVdtkm/z9vv42GNa75xQAbiCABNr/eNcsbiu7pezzqk6NwKFdv2s3F2K+7xdv7O6ah2ZV73oDlNA/0v8CCkGYQaMq1aQeCib2qlO3RfgLcaTnjd8h56QAAAAASUVORK5CYII="},"backgroundColor":"transparent","images":{"fallback":{"src":"/static/fa3ecd56bbab38cc6f07c72d5501f06b/c595a/index.png","srcSet":"/static/fa3ecd56bbab38cc6f07c72d5501f06b/c595a/index.png 1200w,\n/static/fa3ecd56bbab38cc6f07c72d5501f06b/20b37/index.png 2400w","sizes":"1200px"},"sources":[{"srcSet":"/static/fa3ecd56bbab38cc6f07c72d5501f06b/3bd2c/index.webp 1200w,\n/static/fa3ecd56bbab38cc6f07c72d5501f06b/dbf43/index.webp 2400w","type":"image/webp","sizes":"1200px"}]},"width":1200,"height":562},"fixed":{"src":"/static/fa3ecd56bbab38cc6f07c72d5501f06b/f3583/index.png"}}}}},"previous":{"fields":{"slug":"/algorithm-dynamic-programming/"},"frontmatter":{"title":"알고리즘설계와분석 - Dynamic Programming (동적 계획법)"}},"next":{"fields":{"slug":"/algorithm-bfs-dfs/"},"frontmatter":{"title":"알고리즘설계와분석 - BFS/DFS와 Topological Sort"}}},"pageContext":{"id":"9f0a213a-1795-5f0a-bba8-6a25051310eb","previousPostId":"07c66631-bd36-5fcc-9838-55c5cf3500de","nextPostId":"9f8b784b-94e7-539f-b56b-b4111e80b5e3"}},"staticQueryHashes":["736397157"],"slicesMap":{}}