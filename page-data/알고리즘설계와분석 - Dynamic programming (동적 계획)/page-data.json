{"componentChunkName":"component---src-templates-blog-post-js","path":"/알고리즘설계와분석 - Dynamic programming (동적 계획)/","result":{"data":{"site":{"siteMetadata":{"title":"메인","siteUrl":"https://rmdnps10.github.io","author":{"name":"Inyoung Chung"}}},"markdownRemark":{"id":"07c66631-bd36-5fcc-9838-55c5cf3500de","excerpt":"학부 수업 \"알고리즘설계와분석\"에서 배운 내용을 정리합니다. 1️⃣ Dynamic Programming의 핵심 개념 DP는 언제 사용하는가? Dynamic Programming은 다음 두 가지 조건을 만족할 때 적용할 수 있다. 최적 부분 구조(Optimal Substructure…","html":"<blockquote>\n<p>학부 수업 \"알고리즘설계와분석\"에서 배운 내용을 정리합니다.</p>\n</blockquote>\n<h2 id=\"1️-dynamic-programming의-핵심-개념\">1️⃣ Dynamic Programming의 핵심 개념</h2>\n<h3 id=\"dp는-언제-사용하는가\">DP는 언제 사용하는가?</h3>\n<p>Dynamic Programming은 다음 두 가지 조건을 만족할 때 적용할 수 있다.</p>\n<ul>\n<li><strong>최적 부분 구조(Optimal Substructure)</strong>: 전체 문제의 최적해가 부분문제의 최적해로 구성된다</li>\n<li><strong>중복되는 부분문제(Overlapping Subproblems)</strong>: 동일한 부분문제가 반복적으로 계산된다</li>\n</ul>\n<p>이 두 조건이 만족되면, <strong>부분문제의 결과를 저장(메모이제이션)하여 재사용</strong>함으로써 지수시간 알고리즘을 <code class=\"language-text\">다항시간</code>으로 개선할 수 있다.</p>\n<hr>\n<h3 id=\"dp-vs-divide--conquer\">DP vs Divide &#x26; Conquer</h3>\n<table>\n<thead>\n<tr>\n<th>구분</th>\n<th>Divide &#x26; Conquer</th>\n<th>Dynamic Programming</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><strong>하위문제 관계</strong></td>\n<td>독립적 (disjoint)</td>\n<td>겹침 (overlapping)</td>\n</tr>\n<tr>\n<td><strong>결과 재사용</strong></td>\n<td>불필요</td>\n<td>필수</td>\n</tr>\n<tr>\n<td><strong>대표 예시</strong></td>\n<td>MergeSort, QuickSort</td>\n<td>Rod Cutting, LCS, Optimal BST</td>\n</tr>\n<tr>\n<td><strong>접근 방식</strong></td>\n<td>재귀적으로 분할</td>\n<td>테이블로 누적 계산</td>\n</tr>\n</tbody>\n</table>\n<hr>\n<h3 id=\"dp의-두-가지-접근-방식\">DP의 두 가지 접근 방식</h3>\n<h4 id=\"-top-down-memoization\">🔹 Top-down (Memoization)</h4>\n<ul>\n<li>재귀적으로 문제를 풀되, 이미 계산한 결과는 배열에 저장하여 재사용한다</li>\n<li>필요한 부분문제만 계산한다</li>\n<li>재귀 호출의 오버헤드가 있을 수 있다</li>\n</ul>\n<h4 id=\"-bottom-up-tabulation\">🔹 Bottom-up (Tabulation)</h4>\n<ul>\n<li>작은 문제부터 순서대로 테이블을 채워나간다</li>\n<li>모든 부분문제를 계산한다</li>\n<li>반복문 기반으로 구현이 간결하고 빠르다</li>\n</ul>\n<hr>\n<h3 id=\"간단한-예시-fibonacci\">간단한 예시: Fibonacci</h3>\n<p><strong>🔥 Naive 재귀 방식</strong></p>\n<ul>\n<li><code class=\"language-text\">F(n) = F(n-1) + F(n-2)</code>를 그대로 구현</li>\n<li>동일한 부분문제를 반복 계산</li>\n<li>시간복잡도: <strong>Θ(2ⁿ)</strong></li>\n</ul>\n<p><strong>🔥 Bottom-up DP</strong></p>\n<div class=\"gatsby-highlight\" data-language=\"python\"><pre class=\"language-python\"><code class=\"language-python\"><span class=\"token keyword\">def</span> <span class=\"token function\">fibonacci</span><span class=\"token punctuation\">(</span>n<span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span>\n    F <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span><span class=\"token number\">0</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">*</span> <span class=\"token punctuation\">(</span>n <span class=\"token operator\">+</span> <span class=\"token number\">1</span><span class=\"token punctuation\">)</span>\n    F<span class=\"token punctuation\">[</span><span class=\"token number\">1</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> <span class=\"token number\">1</span>\n    F<span class=\"token punctuation\">[</span><span class=\"token number\">2</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> <span class=\"token number\">1</span>\n\n    <span class=\"token keyword\">for</span> i <span class=\"token keyword\">in</span> <span class=\"token builtin\">range</span><span class=\"token punctuation\">(</span><span class=\"token number\">3</span><span class=\"token punctuation\">,</span> n <span class=\"token operator\">+</span> <span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span>\n        F<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> F<span class=\"token punctuation\">[</span>i<span class=\"token operator\">-</span><span class=\"token number\">1</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">+</span> F<span class=\"token punctuation\">[</span>i<span class=\"token operator\">-</span><span class=\"token number\">2</span><span class=\"token punctuation\">]</span>  <span class=\"token comment\"># 이미 계산된 값 재사용</span>\n\n    <span class=\"token keyword\">return</span> F<span class=\"token punctuation\">[</span>n<span class=\"token punctuation\">]</span></code></pre></div>\n<ul>\n<li>각 <code class=\"language-text\">F[i]</code>를 한 번씩만 계산</li>\n<li>시간복잡도: <strong>O(n)</strong></li>\n<li><strong>지수시간 → 선형시간</strong>으로 극적인 개선</li>\n</ul>\n<hr>\n<h2 id=\"2️-rod-cutting-막대-자르기\">2️⃣ Rod Cutting (막대 자르기)</h2>\n<h3 id=\"문제-정의\">문제 정의</h3>\n<p>길이 <code class=\"language-text\">n</code>인 막대를 여러 조각으로 잘라서 팔 때, <strong>총 수익을 최대화</strong>하는 절단 방법을 찾는 문제이다.</p>\n<ul>\n<li>입력: 길이 <code class=\"language-text\">i</code>의 막대 가격 <code class=\"language-text\">p[i]</code> (i = 1, 2, ..., n)</li>\n<li>출력: 최대 수익 <code class=\"language-text\">r[n]</code></li>\n</ul>\n<p><strong>🔥 예시</strong></p>\n<p>가격표: <code class=\"language-text\">p[1]=1, p[2]=5, p[3]=8, p[4]=9</code></p>\n<ul>\n<li>길이 4를 안 자르면: <code class=\"language-text\">p[4] = 9</code></li>\n<li>길이 4를 2+2로 자르면: <code class=\"language-text\">p[2] + p[2] = 5 + 5 = 10</code></li>\n<li><strong>최적 수익: 10</strong> (2+2로 자르는 것이 유리)</li>\n</ul>\n<hr>\n<h3 id=\"완전-탐색의-비효율성\">완전 탐색의 비효율성</h3>\n<p>막대를 자를 수 있는 위치는 <code class=\"language-text\">n-1</code>곳이고, 각 위치마다 \"자르기/안 자르기\" 2가지 선택이 있다.</p>\n<p>→ 가능한 경우의 수: <strong>2^(n-1)</strong> (지수시간)</p>\n<hr>\n<h3 id=\"최적-부분-구조와-점화식\">최적 부분 구조와 점화식</h3>\n<p>첫 번째 조각의 길이를 <code class=\"language-text\">i</code>로 정하면:</p>\n<ul>\n<li>첫 조각에서 얻는 수익: <code class=\"language-text\">p[i]</code></li>\n<li>남은 길이 <code class=\"language-text\">n-i</code>에서 얻을 수 있는 최대 수익: <code class=\"language-text\">r[n-i]</code></li>\n</ul>\n<p>따라서 다음과 같은 점화식이 성립한다:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">r[n] = max(p[i] + r[n-i])  (i = 1, 2, ..., n)\nr[0] = 0</code></pre></div>\n<p>이는 <strong>최적 부분 구조</strong>를 가지며, <code class=\"language-text\">r[n-1]</code>, <code class=\"language-text\">r[n-2]</code> 등의 부분문제가 <strong>반복적으로 등장</strong>한다.</p>\n<hr>\n<h3 id=\"naive-재귀-구현\">Naive 재귀 구현</h3>\n<div class=\"gatsby-highlight\" data-language=\"python\"><pre class=\"language-python\"><code class=\"language-python\"><span class=\"token keyword\">def</span> <span class=\"token function\">CutRod</span><span class=\"token punctuation\">(</span>p<span class=\"token punctuation\">,</span> n<span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span>\n    <span class=\"token keyword\">if</span> n <span class=\"token operator\">==</span> <span class=\"token number\">0</span><span class=\"token punctuation\">:</span>\n        <span class=\"token keyword\">return</span> <span class=\"token number\">0</span>\n\n    q <span class=\"token operator\">=</span> <span class=\"token operator\">-</span>∞\n    <span class=\"token keyword\">for</span> i <span class=\"token keyword\">in</span> <span class=\"token builtin\">range</span><span class=\"token punctuation\">(</span><span class=\"token number\">1</span><span class=\"token punctuation\">,</span> n <span class=\"token operator\">+</span> <span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span>\n        q <span class=\"token operator\">=</span> <span class=\"token builtin\">max</span><span class=\"token punctuation\">(</span>q<span class=\"token punctuation\">,</span> p<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span> <span class=\"token operator\">+</span> CutRod<span class=\"token punctuation\">(</span>p<span class=\"token punctuation\">,</span> n <span class=\"token operator\">-</span> i<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>  <span class=\"token comment\"># 중복 호출 발생</span>\n\n    <span class=\"token keyword\">return</span> q</code></pre></div>\n<ul>\n<li>시간복잡도: <strong>O(2ⁿ)</strong> (부분문제가 지수적으로 증가)</li>\n</ul>\n<hr>\n<h3 id=\"top-down-memoization\">Top-down (Memoization)</h3>\n<div class=\"gatsby-highlight\" data-language=\"python\"><pre class=\"language-python\"><code class=\"language-python\"><span class=\"token keyword\">def</span> <span class=\"token function\">MemoizedCutRod</span><span class=\"token punctuation\">(</span>p<span class=\"token punctuation\">,</span> n<span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span>\n    r <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span><span class=\"token operator\">-</span>∞ <span class=\"token keyword\">for</span> _ <span class=\"token keyword\">in</span> <span class=\"token builtin\">range</span><span class=\"token punctuation\">(</span>n <span class=\"token operator\">+</span> <span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">]</span>\n    <span class=\"token keyword\">return</span> MemoizedCutRodAux<span class=\"token punctuation\">(</span>p<span class=\"token punctuation\">,</span> n<span class=\"token punctuation\">,</span> r<span class=\"token punctuation\">)</span>\n\n<span class=\"token keyword\">def</span> <span class=\"token function\">MemoizedCutRodAux</span><span class=\"token punctuation\">(</span>p<span class=\"token punctuation\">,</span> n<span class=\"token punctuation\">,</span> r<span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span>\n    <span class=\"token keyword\">if</span> r<span class=\"token punctuation\">[</span>n<span class=\"token punctuation\">]</span> <span class=\"token operator\">>=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">:</span>  <span class=\"token comment\"># 이미 계산된 경우</span>\n        <span class=\"token keyword\">return</span> r<span class=\"token punctuation\">[</span>n<span class=\"token punctuation\">]</span>\n\n    <span class=\"token keyword\">if</span> n <span class=\"token operator\">==</span> <span class=\"token number\">0</span><span class=\"token punctuation\">:</span>\n        q <span class=\"token operator\">=</span> <span class=\"token number\">0</span>\n    <span class=\"token keyword\">else</span><span class=\"token punctuation\">:</span>\n        q <span class=\"token operator\">=</span> <span class=\"token operator\">-</span>∞\n        <span class=\"token keyword\">for</span> i <span class=\"token keyword\">in</span> <span class=\"token builtin\">range</span><span class=\"token punctuation\">(</span><span class=\"token number\">1</span><span class=\"token punctuation\">,</span> n <span class=\"token operator\">+</span> <span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span>\n            q <span class=\"token operator\">=</span> <span class=\"token builtin\">max</span><span class=\"token punctuation\">(</span>q<span class=\"token punctuation\">,</span> p<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span> <span class=\"token operator\">+</span> MemoizedCutRodAux<span class=\"token punctuation\">(</span>p<span class=\"token punctuation\">,</span> n <span class=\"token operator\">-</span> i<span class=\"token punctuation\">,</span> r<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n\n    r<span class=\"token punctuation\">[</span>n<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> q\n    <span class=\"token keyword\">return</span> q</code></pre></div>\n<ul>\n<li>단 한 줄 <code class=\"language-text\">if r[n] >= 0: return r[n]</code>으로 <strong>지수시간 → 다항시간</strong> 개선</li>\n<li>시간복잡도: <strong>O(n²)</strong></li>\n</ul>\n<hr>\n<h3 id=\"bottom-up-구현\">Bottom-up 구현</h3>\n<div class=\"gatsby-highlight\" data-language=\"python\"><pre class=\"language-python\"><code class=\"language-python\"><span class=\"token keyword\">def</span> <span class=\"token function\">BottomUpCutRod</span><span class=\"token punctuation\">(</span>p<span class=\"token punctuation\">,</span> n<span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span>\n    r <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span><span class=\"token number\">0</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">*</span> <span class=\"token punctuation\">(</span>n <span class=\"token operator\">+</span> <span class=\"token number\">1</span><span class=\"token punctuation\">)</span>\n\n    <span class=\"token keyword\">for</span> j <span class=\"token keyword\">in</span> <span class=\"token builtin\">range</span><span class=\"token punctuation\">(</span><span class=\"token number\">1</span><span class=\"token punctuation\">,</span> n <span class=\"token operator\">+</span> <span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span>\n        q <span class=\"token operator\">=</span> <span class=\"token operator\">-</span>∞\n        <span class=\"token keyword\">for</span> i <span class=\"token keyword\">in</span> <span class=\"token builtin\">range</span><span class=\"token punctuation\">(</span><span class=\"token number\">1</span><span class=\"token punctuation\">,</span> j <span class=\"token operator\">+</span> <span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span>\n            q <span class=\"token operator\">=</span> <span class=\"token builtin\">max</span><span class=\"token punctuation\">(</span>q<span class=\"token punctuation\">,</span> p<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span> <span class=\"token operator\">+</span> r<span class=\"token punctuation\">[</span>j <span class=\"token operator\">-</span> i<span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span>\n        r<span class=\"token punctuation\">[</span>j<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> q\n\n    <span class=\"token keyword\">return</span> r<span class=\"token punctuation\">[</span>n<span class=\"token punctuation\">]</span></code></pre></div>\n<ul>\n<li>작은 문제부터 순서대로 계산</li>\n<li>시간복잡도: <strong>O(n²)</strong></li>\n<li>메모이제이션보다 구현이 간결하고 빠르다</li>\n</ul>\n<hr>\n<h3 id=\"절단-위치-복원\">절단 위치 복원</h3>\n<p>최대 수익뿐만 아니라 <strong>실제 어디서 잘라야 하는지</strong>도 알아내야 한다.</p>\n<div class=\"gatsby-highlight\" data-language=\"python\"><pre class=\"language-python\"><code class=\"language-python\"><span class=\"token keyword\">def</span> <span class=\"token function\">ExtendedBottomUpCutRod</span><span class=\"token punctuation\">(</span>p<span class=\"token punctuation\">,</span> n<span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span>\n    r <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span><span class=\"token number\">0</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">*</span> <span class=\"token punctuation\">(</span>n <span class=\"token operator\">+</span> <span class=\"token number\">1</span><span class=\"token punctuation\">)</span>\n    s <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span><span class=\"token number\">0</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">*</span> <span class=\"token punctuation\">(</span>n <span class=\"token operator\">+</span> <span class=\"token number\">1</span><span class=\"token punctuation\">)</span>  <span class=\"token comment\"># s[j]: 길이 j에서 첫 번째 절단 길이</span>\n\n    <span class=\"token keyword\">for</span> j <span class=\"token keyword\">in</span> <span class=\"token builtin\">range</span><span class=\"token punctuation\">(</span><span class=\"token number\">1</span><span class=\"token punctuation\">,</span> n <span class=\"token operator\">+</span> <span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span>\n        q <span class=\"token operator\">=</span> <span class=\"token operator\">-</span>∞\n        <span class=\"token keyword\">for</span> i <span class=\"token keyword\">in</span> <span class=\"token builtin\">range</span><span class=\"token punctuation\">(</span><span class=\"token number\">1</span><span class=\"token punctuation\">,</span> j <span class=\"token operator\">+</span> <span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span>\n            <span class=\"token keyword\">if</span> q <span class=\"token operator\">&lt;</span> p<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span> <span class=\"token operator\">+</span> r<span class=\"token punctuation\">[</span>j <span class=\"token operator\">-</span> i<span class=\"token punctuation\">]</span><span class=\"token punctuation\">:</span>\n                q <span class=\"token operator\">=</span> p<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span> <span class=\"token operator\">+</span> r<span class=\"token punctuation\">[</span>j <span class=\"token operator\">-</span> i<span class=\"token punctuation\">]</span>\n                s<span class=\"token punctuation\">[</span>j<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> i  <span class=\"token comment\"># 최적 절단 길이 저장</span>\n        r<span class=\"token punctuation\">[</span>j<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> q\n\n    <span class=\"token keyword\">return</span> r<span class=\"token punctuation\">,</span> s\n\n<span class=\"token keyword\">def</span> <span class=\"token function\">PrintCutRodSolution</span><span class=\"token punctuation\">(</span>p<span class=\"token punctuation\">,</span> n<span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span>\n    r<span class=\"token punctuation\">,</span> s <span class=\"token operator\">=</span> ExtendedBottomUpCutRod<span class=\"token punctuation\">(</span>p<span class=\"token punctuation\">,</span> n<span class=\"token punctuation\">)</span>\n    <span class=\"token keyword\">while</span> n <span class=\"token operator\">></span> <span class=\"token number\">0</span><span class=\"token punctuation\">:</span>\n        <span class=\"token keyword\">print</span><span class=\"token punctuation\">(</span>s<span class=\"token punctuation\">[</span>n<span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span>  <span class=\"token comment\"># 절단 길이 출력</span>\n        n <span class=\"token operator\">=</span> n <span class=\"token operator\">-</span> s<span class=\"token punctuation\">[</span>n<span class=\"token punctuation\">]</span></code></pre></div>\n<p><strong>🔥 예시</strong></p>\n<p>길이 9인 막대의 경우:</p>\n<table>\n<thead>\n<tr>\n<th>i</th>\n<th>s[i] (첫 절단)</th>\n<th>r[i] (최대 수익)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>1</td>\n<td>1</td>\n<td>1</td>\n</tr>\n<tr>\n<td>2</td>\n<td>2</td>\n<td>5</td>\n</tr>\n<tr>\n<td>3</td>\n<td>3</td>\n<td>8</td>\n</tr>\n<tr>\n<td>4</td>\n<td>2</td>\n<td>10</td>\n</tr>\n<tr>\n<td>5</td>\n<td>2</td>\n<td>13</td>\n</tr>\n<tr>\n<td>6</td>\n<td>6</td>\n<td>17</td>\n</tr>\n<tr>\n<td>7</td>\n<td>1</td>\n<td>18</td>\n</tr>\n<tr>\n<td>8</td>\n<td>2</td>\n<td>22</td>\n</tr>\n<tr>\n<td>9</td>\n<td>3</td>\n<td>25</td>\n</tr>\n</tbody>\n</table>\n<p>→ 최적 절단: <code class=\"language-text\">[3, 6]</code>, 총 수익: <code class=\"language-text\">25</code></p>\n<hr>\n<h2 id=\"3️-optimal-binary-search-tree\">3️⃣ Optimal Binary Search Tree</h2>\n<h3 id=\"문제-설정\">문제 설정</h3>\n<p>단어(키) <code class=\"language-text\">k₁, k₂, ..., kₙ</code>을 BST에 저장할 때, <strong>평균 검색 비용을 최소화</strong>하는 트리 구조를 찾는 문제이다.</p>\n<ul>\n<li>각 키 <code class=\"language-text\">kᵢ</code>의 검색 확률: <code class=\"language-text\">pᵢ</code></li>\n<li>존재하지 않는 키(dummy key) <code class=\"language-text\">dᵢ</code>의 검색 확률: <code class=\"language-text\">qᵢ</code></li>\n<li>제약: <code class=\"language-text\">Σpᵢ + Σqᵢ = 1</code></li>\n</ul>\n<hr>\n<h3 id=\"비용-모델\">비용 모델</h3>\n<p>각 노드의 검색 비용은 <strong>깊이(depth) + 1</strong>이다.</p>\n<p>기대 검색 비용:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">E[search cost] = Σ pᵢ × (depth(kᵢ) + 1) + Σ qᵢ × (depth(dᵢ) + 1)</code></pre></div>\n<p>이 값을 최소화하는 BST가 <strong>Optimal BST</strong>이다.</p>\n<hr>\n<h3 id=\"직관과-함정\">직관과 함정</h3>\n<p><strong>🔹 기본 직관</strong></p>\n<ul>\n<li>자주 검색되는 키는 루트 가까이에 배치</li>\n<li>드물게 검색되는 키는 잎 쪽에 배치</li>\n</ul>\n<p><strong>🔹 주의할 점</strong></p>\n<blockquote>\n<p>\"확률이 가장 높은 키를 루트에 둔다고 항상 최적은 아니다\"\n\"트리 높이가 최소라고 해서 최적 BST는 아니다\"</p>\n</blockquote>\n<hr>\n<h3 id=\"예시\">예시</h3>\n<table>\n<thead>\n<tr>\n<th>키</th>\n<th>확률</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>k₁</td>\n<td>0.15</td>\n</tr>\n<tr>\n<td>k₂</td>\n<td>0.10</td>\n</tr>\n<tr>\n<td>k₃</td>\n<td>0.05</td>\n</tr>\n<tr>\n<td>k₄</td>\n<td>0.10</td>\n</tr>\n<tr>\n<td>k₅</td>\n<td>0.20</td>\n</tr>\n</tbody>\n</table>\n<ul>\n<li>트리 1의 평균 비용: 2.8</li>\n<li>트리 2의 평균 비용: <strong>2.75</strong> (더 낮음)</li>\n</ul>\n<p>→ 루트가 <code class=\"language-text\">k₂</code> (확률 0.10)이더라도 전체 평균 비용이 최소일 수 있다</p>\n<hr>\n<h3 id=\"탐색-공간의-크기\">탐색 공간의 크기</h3>\n<p><code class=\"language-text\">n</code>개의 노드로 만들 수 있는 BST의 개수:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">4ⁿ / n^(3/2) (지수적으로 증가)</code></pre></div>\n<p>완전 탐색은 불가능하지만, DP를 사용하면 <strong>O(n³)</strong> 시간에 최적 BST를 구할 수 있다.</p>\n<hr>\n<h2 id=\"4️-lcs-longest-common-subsequence\">4️⃣ LCS (Longest Common Subsequence)</h2>\n<h3 id=\"문제-정의-1\">문제 정의</h3>\n<p>두 문자열 <code class=\"language-text\">X</code>와 <code class=\"language-text\">Y</code>에서 <strong>둘 다에 등장하며 순서가 유지되는 가장 긴 부분수열</strong>을 찾는 문제이다.</p>\n<p><strong>🔥 예시</strong></p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">X = ABCBDAB\nY = BDCABA\n\nLCS = BDAB (길이 4)</code></pre></div>\n<hr>\n<h3 id=\"brute-force의-한계\">Brute Force의 한계</h3>\n<ul>\n<li><code class=\"language-text\">X</code>의 부분수열 개수: <code class=\"language-text\">2ⁿ</code></li>\n<li><code class=\"language-text\">Y</code>의 부분수열 개수: <code class=\"language-text\">2ᵐ</code></li>\n<li>모든 쌍을 비교: <strong>O(2^(n+m))</strong> (지수시간)</li>\n</ul>\n<hr>\n<h3 id=\"dp-점화식\">DP 점화식</h3>\n<p><code class=\"language-text\">L[i][j]</code>: <code class=\"language-text\">X[1..i]</code>와 <code class=\"language-text\">Y[1..j]</code>의 LCS 길이</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">L[i][j] = {\n    0                           if i = 0 or j = 0\n    L[i-1][j-1] + 1            if X[i] = Y[j]\n    max(L[i-1][j], L[i][j-1])  if X[i] ≠ Y[j]\n}</code></pre></div>\n<p><strong>🔹 점화식 해석</strong></p>\n<ul>\n<li>마지막 문자가 같으면: 이전 LCS에 1을 더한다</li>\n<li>마지막 문자가 다르면: 한쪽 문자를 제외한 두 경우 중 최댓값을 선택한다</li>\n</ul>\n<hr>\n<h3 id=\"bottom-up-구현-1\">Bottom-up 구현</h3>\n<div class=\"gatsby-highlight\" data-language=\"python\"><pre class=\"language-python\"><code class=\"language-python\"><span class=\"token keyword\">def</span> <span class=\"token function\">LCS</span><span class=\"token punctuation\">(</span>X<span class=\"token punctuation\">,</span> Y<span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span>\n    m <span class=\"token operator\">=</span> <span class=\"token builtin\">len</span><span class=\"token punctuation\">(</span>X<span class=\"token punctuation\">)</span>\n    n <span class=\"token operator\">=</span> <span class=\"token builtin\">len</span><span class=\"token punctuation\">(</span>Y<span class=\"token punctuation\">)</span>\n    L <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span><span class=\"token punctuation\">[</span><span class=\"token number\">0</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">*</span> <span class=\"token punctuation\">(</span>n <span class=\"token operator\">+</span> <span class=\"token number\">1</span><span class=\"token punctuation\">)</span> <span class=\"token keyword\">for</span> _ <span class=\"token keyword\">in</span> <span class=\"token builtin\">range</span><span class=\"token punctuation\">(</span>m <span class=\"token operator\">+</span> <span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">]</span>\n\n    <span class=\"token keyword\">for</span> i <span class=\"token keyword\">in</span> <span class=\"token builtin\">range</span><span class=\"token punctuation\">(</span><span class=\"token number\">1</span><span class=\"token punctuation\">,</span> m <span class=\"token operator\">+</span> <span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span>\n        <span class=\"token keyword\">for</span> j <span class=\"token keyword\">in</span> <span class=\"token builtin\">range</span><span class=\"token punctuation\">(</span><span class=\"token number\">1</span><span class=\"token punctuation\">,</span> n <span class=\"token operator\">+</span> <span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span>\n            <span class=\"token keyword\">if</span> X<span class=\"token punctuation\">[</span>i<span class=\"token operator\">-</span><span class=\"token number\">1</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">==</span> Y<span class=\"token punctuation\">[</span>j<span class=\"token operator\">-</span><span class=\"token number\">1</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">:</span>\n                L<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span><span class=\"token punctuation\">[</span>j<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> L<span class=\"token punctuation\">[</span>i<span class=\"token operator\">-</span><span class=\"token number\">1</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">[</span>j<span class=\"token operator\">-</span><span class=\"token number\">1</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">+</span> <span class=\"token number\">1</span>\n            <span class=\"token keyword\">else</span><span class=\"token punctuation\">:</span>\n                L<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span><span class=\"token punctuation\">[</span>j<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> <span class=\"token builtin\">max</span><span class=\"token punctuation\">(</span>L<span class=\"token punctuation\">[</span>i<span class=\"token operator\">-</span><span class=\"token number\">1</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">[</span>j<span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span> L<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span><span class=\"token punctuation\">[</span>j<span class=\"token operator\">-</span><span class=\"token number\">1</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span>\n\n    <span class=\"token keyword\">return</span> L<span class=\"token punctuation\">[</span>m<span class=\"token punctuation\">]</span><span class=\"token punctuation\">[</span>n<span class=\"token punctuation\">]</span></code></pre></div>\n<ul>\n<li>시간복잡도: <strong>O(nm)</strong> (이중 루프)</li>\n<li>공간복잡도: <strong>O(nm)</strong></li>\n</ul>\n<hr>\n<h3 id=\"lcs-문자열-복원\">LCS 문자열 복원</h3>\n<p>테이블 <code class=\"language-text\">L</code>을 채운 후, 역추적하여 실제 LCS를 구할 수 있다.</p>\n<p><strong>🔹 역추적 규칙</strong></p>\n<ul>\n<li><code class=\"language-text\">X[i] = Y[j]</code>이면: 이 문자를 포함하고 대각선(↖)으로 이동</li>\n<li><code class=\"language-text\">L[i-1][j] > L[i][j-1]</code>이면: 위(↑)로 이동</li>\n<li><code class=\"language-text\">L[i-1][j] ≤ L[i][j-1]</code>이면: 왼쪽(←)으로 이동</li>\n</ul>\n<blockquote>\n<p>💡 <strong>LCS는 유일하지 않을 수 있다</strong></p>\n<p>동일한 길이의 LCS가 여러 개 존재할 수 있다. 예를 들어 <code class=\"language-text\">BCAB</code>, <code class=\"language-text\">BDAB</code> 모두 가능할 수 있다.</p>\n</blockquote>\n<hr>\n<h2 id=\"5️-bst-개수-세기-catalan-numbers\">5️⃣ BST 개수 세기 (Catalan Numbers)</h2>\n<h3 id=\"문제-정의-2\">문제 정의</h3>\n<p><code class=\"language-text\">n</code>개의 노드로 만들 수 있는 <strong>서로 다른 BST의 개수</strong>를 구하는 문제이다.</p>\n<hr>\n<h3 id=\"점화식-유도\">점화식 유도</h3>\n<p>루트를 <code class=\"language-text\">i</code>번째 노드로 고정하면:</p>\n<ul>\n<li>왼쪽 서브트리: <code class=\"language-text\">i-1</code>개의 노드 → <code class=\"language-text\">T[i-1]</code>가지</li>\n<li>오른쪽 서브트리: <code class=\"language-text\">n-i</code>개의 노드 → <code class=\"language-text\">T[n-i]</code>가지</li>\n</ul>\n<p>따라서 다음 점화식이 성립한다:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">T[n] = Σ T[i-1] × T[n-i]  (i = 1, 2, ..., n)\n\n초기조건: T[0] = 1, T[1] = 1</code></pre></div>\n<hr>\n<h3 id=\"catalan-수열\">Catalan 수열</h3>\n<p>이 수열은 유명한 <strong>Catalan Numbers</strong>이다:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">T[0] = 1\nT[1] = 1\nT[2] = 2\nT[3] = 5\nT[4] = 14\nT[5] = 42\nT[6] = 132\n...</code></pre></div>\n<hr>\n<h3 id=\"bottom-up-구현-2\">Bottom-up 구현</h3>\n<div class=\"gatsby-highlight\" data-language=\"python\"><pre class=\"language-python\"><code class=\"language-python\"><span class=\"token keyword\">def</span> <span class=\"token function\">CountBST</span><span class=\"token punctuation\">(</span>n<span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span>\n    T <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span><span class=\"token number\">0</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">*</span> <span class=\"token punctuation\">(</span>n <span class=\"token operator\">+</span> <span class=\"token number\">1</span><span class=\"token punctuation\">)</span>\n    T<span class=\"token punctuation\">[</span><span class=\"token number\">0</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> <span class=\"token number\">1</span>\n    T<span class=\"token punctuation\">[</span><span class=\"token number\">1</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> <span class=\"token number\">1</span>\n\n    <span class=\"token keyword\">for</span> k <span class=\"token keyword\">in</span> <span class=\"token builtin\">range</span><span class=\"token punctuation\">(</span><span class=\"token number\">2</span><span class=\"token punctuation\">,</span> n <span class=\"token operator\">+</span> <span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span>\n        <span class=\"token keyword\">for</span> i <span class=\"token keyword\">in</span> <span class=\"token builtin\">range</span><span class=\"token punctuation\">(</span><span class=\"token number\">1</span><span class=\"token punctuation\">,</span> k <span class=\"token operator\">+</span> <span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span>\n            T<span class=\"token punctuation\">[</span>k<span class=\"token punctuation\">]</span> <span class=\"token operator\">+=</span> T<span class=\"token punctuation\">[</span>i<span class=\"token operator\">-</span><span class=\"token number\">1</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">*</span> T<span class=\"token punctuation\">[</span>k<span class=\"token operator\">-</span>i<span class=\"token punctuation\">]</span>\n\n    <span class=\"token keyword\">return</span> T<span class=\"token punctuation\">[</span>n<span class=\"token punctuation\">]</span></code></pre></div>\n<ul>\n<li>시간복잡도: <strong>O(n²)</strong></li>\n<li>완전 탐색(지수시간) 대비 큰 개선</li>\n</ul>\n<hr>\n<h2 id=\"6️-dp-핵심-정리\">6️⃣ DP 핵심 정리</h2>\n<h3 id=\"dp의-본질\">DP의 본질</h3>\n<table>\n<thead>\n<tr>\n<th>구분</th>\n<th>내용</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><strong>핵심 원리</strong></td>\n<td>중복되는 부분문제의 해를 저장하여 재활용</td>\n</tr>\n<tr>\n<td><strong>공간-시간 트레이드오프</strong></td>\n<td>약간의 메모리를 사용해 계산 시간을 절감</td>\n</tr>\n<tr>\n<td><strong>적용 조건</strong></td>\n<td>(1) 최적 부분구조 (2) 부분문제 중복 발생</td>\n</tr>\n</tbody>\n</table>\n<hr>\n<h3 id=\"대표-문제별-시간복잡도\">대표 문제별 시간복잡도</h3>\n<table>\n<thead>\n<tr>\n<th>문제</th>\n<th>Naive</th>\n<th>DP</th>\n<th>개선 비율</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><strong>Fibonacci</strong></td>\n<td>O(2ⁿ)</td>\n<td>O(n)</td>\n<td>지수 → 선형</td>\n</tr>\n<tr>\n<td><strong>Rod Cutting</strong></td>\n<td>O(2ⁿ)</td>\n<td>O(n²)</td>\n<td>지수 → 이차</td>\n</tr>\n<tr>\n<td><strong>Optimal BST</strong></td>\n<td>지수적</td>\n<td>O(n³)</td>\n<td>지수 → 삼차</td>\n</tr>\n<tr>\n<td><strong>LCS</strong></td>\n<td>O(2^(n+m))</td>\n<td>O(nm)</td>\n<td>지수 → 이차</td>\n</tr>\n<tr>\n<td><strong>BST 개수</strong></td>\n<td>지수적</td>\n<td>O(n²)</td>\n<td>지수 → 이차</td>\n</tr>\n</tbody>\n</table>\n<hr>\n<h3 id=\"dp-적용-전략\">DP 적용 전략</h3>\n<p><strong>🔥 Bottom-up vs Top-down 선택 기준</strong></p>\n<ul>\n<li><strong>Bottom-up</strong>: 부분문제 간 의존 관계가 명확하고 모든 부분문제를 풀어야 할 때</li>\n<li><strong>Top-down</strong>: 일부 부분문제만 필요하거나 재귀 구조가 자연스러울 때</li>\n</ul>\n<blockquote>\n<p>💡 <strong>Fibonacci의 특수성</strong></p>\n<p>Fibonacci는 각 단계에서 완전히 새로운 부분문제만 생성되므로, Top-down 메모이제이션이 비효율적이다. 반면 Rod Cutting은 작은 부분문제가 반복 등장하므로 Top-down이 효과적이다.</p>\n</blockquote>\n<hr>\n<h3 id=\"공간-최적화\">공간 최적화</h3>\n<p>대부분의 DP 문제는 테이블 전체를 저장하지 않고 <strong>일부만 유지</strong>하여 공간복잡도를 줄일 수 있다.</p>\n<ul>\n<li>Fibonacci: <code class=\"language-text\">O(n)</code> → <code class=\"language-text\">O(1)</code> (직전 두 값만 저장)</li>\n<li>LCS: <code class=\"language-text\">O(nm)</code> → <code class=\"language-text\">O(min(n, m))</code> (한 행만 저장)</li>\n</ul>","fields":{"slug":"/알고리즘설계와분석 - Dynamic programming (동적 계획)/"},"frontmatter":{"title":"알고리즘설계와분석 - Dynamic Programming (동적 계획법)","date":"2025-12-07","description":"Dynamic Programming의 개념부터 Rod Cutting, Optimal BST, LCS, BST 개수 세기 등 구체적인 예제와 함께 정리한다.","pointColor":"#ffffff","thumbnail":{"publicURL":"/static/76e810187743c1907281e4b392e4c5db/index.png","childImageSharp":{"gatsbyImageData":{"layout":"fixed","placeholder":{"fallback":"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAJCAIAAAC9o5sfAAAACXBIWXMAAAsTAAALEwEAmpwYAAABT0lEQVR42o1RTU+DQBTk//8CT148ejOmWsX0hCEkQrW0BVp2G0vLUlpY9oMFGqOP0taYmOgcNu/tZt68mdX4XxBcZDxbFyvK6bEt6GDuUsY06NlPfPOgLuW+/him9uXrxWKHlaxYe8vTPIP3lqyUqk6QUhZF0TGFkFkUIdvapNGWp8mO0JyKw1gppBBCAymEkOd5vu+Px2NCSNM0pSyBrPY1mYymt/cgVDWfm+2OpImsay5gAmvJMMYwjF6vp+t6v9+3LCsIArzAnPHwbblaJCwZrtEgDh838Sh/XyLzWdC8s9UqY4wdxzFNE5Rd17VtG+qCMteYLYM4Rk8r7yZyr7fkJZ0F/oPOCjBUHT2XJ6gDOuddFhLMlWBClarGk2gxJ0oQPL1jWSRE+Uva58zPJyQMfzQ1QzSKRRZi54qmcxDX+L+hKlgONhKqaiBvzvkX1QTu3YmvcrwAAAAASUVORK5CYII="},"backgroundColor":"transparent","images":{"fallback":{"src":"/static/76e810187743c1907281e4b392e4c5db/56215/index.png","srcSet":"/static/76e810187743c1907281e4b392e4c5db/56215/index.png 1001w","sizes":"1001px"},"sources":[{"srcSet":"/static/76e810187743c1907281e4b392e4c5db/8bb83/index.webp 1001w","type":"image/webp","sizes":"1001px"}]},"width":1200,"height":565},"fixed":{"src":"/static/76e810187743c1907281e4b392e4c5db/2f01b/index.png"}}}}},"previous":{"fields":{"slug":"/알고리즘설계와분석 - Binary Search Tree (이진 트리)/"},"frontmatter":{"title":"알고리즘설계와분석 - Binary Search Tree (이진 탐색 트리)"}},"next":{"fields":{"slug":"/알고리즘설계와분석 - Greedy algorithm (그리디 알고리즘)/"},"frontmatter":{"title":"알고리즘설계와분석 - Greedy algorithm (그리디 알고리즘)"}}},"pageContext":{"id":"07c66631-bd36-5fcc-9838-55c5cf3500de","previousPostId":"3b2a4823-d65b-55e7-9e0e-883fc6fa5365","nextPostId":"9f0a213a-1795-5f0a-bba8-6a25051310eb"}},"staticQueryHashes":["736397157"],"slicesMap":{}}