{"componentChunkName":"component---src-templates-blog-post-js","path":"/http-fundamentals/","result":{"data":{"site":{"siteMetadata":{"title":"홈","siteUrl":"https://inyoung.dev","author":{"name":"Inyoung Chung"}}},"allMarkdownRemark":{"nodes":[{"fields":{"slug":"/boj-1106-hotel/"},"frontmatter":{"title":"[백준 JAVA] 호텔 1106 머릿속에 박아넣기","date":"2026-02-20","tags":["알고리즘"],"pointColor":"#ffffff"}},{"fields":{"slug":"/http-advanced-features/"},"frontmatter":{"title":"[네트워크] HTTP의 응용 - 쿠키, 캐시, 보안","date":"2026-02-17","tags":["네트워크"],"pointColor":"#ffffff"}},{"fields":{"slug":"/http-fundamentals/"},"frontmatter":{"title":"[네트워크] HTTP의 기초 - DNS와 HTTP Message, Method, Status (스압 주의) ","date":"2026-02-16","tags":["네트워크"],"pointColor":"#ffffff"}},{"fields":{"slug":"/transport-layer-tcp-udp/"},"frontmatter":{"title":"[네트워크] 전송 계층 - TCP와 UDP","date":"2026-02-15","tags":["네트워크"],"pointColor":"#ffffff"}},{"fields":{"slug":"/network-layer-ip-protocol/"},"frontmatter":{"title":"[네트워크] 네트워크 계층과 IP 프로토콜","date":"2026-02-14","tags":["네트워크"],"pointColor":"#ffffff"}},{"fields":{"slug":"/physical-and-data-link-layer/"},"frontmatter":{"title":"[네트워크] 물리 계층과 데이터 링크 계층 - 이더넷과 네트워크 장비","date":"2026-02-13","tags":["네트워크"],"pointColor":"#ffffff"}},{"fields":{"slug":"/network-big-picture/"},"frontmatter":{"title":"[네트워크] 네트워크의 큰 그림","date":"2026-02-12","tags":["네트워크"],"pointColor":"#ffffff"}},{"fields":{"slug":"/troubleshooting-supabase-auth/"},"frontmatter":{"title":"[트러블슈팅] Supabase Auth를 활용한 다양한 환경에서의 세션 유지","date":"2026-02-10","tags":["Web","회고"],"pointColor":"#3ECF8D"}},{"fields":{"slug":"/waterfall-agile/"},"frontmatter":{"title":"[소프트웨어공학] Waterfall과 Agile","date":"2026-02-03","tags":["소프트웨어공학"],"pointColor":"#ffffff"}},{"fields":{"slug":"/os-file-system/"},"frontmatter":{"title":"[운영체제] 파일 시스템","date":"2026-01-27","tags":["운영체제"],"pointColor":"#ffffff"}},{"fields":{"slug":"/os-virtual-memory/"},"frontmatter":{"title":"[운영체제] 5. 가상 메모리","date":"2026-01-26","tags":["운영체제"],"pointColor":"#ffffff"}},{"fields":{"slug":"/os-cpu-scheduling/"},"frontmatter":{"title":"[운영체제] 4. CPU 스케줄링","date":"2026-01-25","tags":["운영체제"],"pointColor":"#ffffff"}},{"fields":{"slug":"/os-synchronization-deadlock/"},"frontmatter":{"title":"[운영체제] 3. 동기화와 교착 상태","date":"2026-01-24","tags":["운영체제"],"pointColor":"#ffffff"}},{"fields":{"slug":"/os-process-thread/"},"frontmatter":{"title":"[운영체제] 2. 프로세스와 스레드","date":"2026-01-23","tags":["운영체제"],"pointColor":"#ffffff"}},{"fields":{"slug":"/os-big-picture/"},"frontmatter":{"title":"[운영체제] 1. 운영체제의 큰 그림","date":"2026-01-21","tags":["운영체제"],"pointColor":"#ffffff"}},{"fields":{"slug":"/computer-architecture-cpu/"},"frontmatter":{"title":"[컴퓨터구조] 3. CPU","date":"2026-01-18","tags":["컴퓨터구조"],"pointColor":"#ffffff"}},{"fields":{"slug":"/computer-architecture-computer-information/"},"frontmatter":{"title":"[컴퓨터구조] 2. 컴퓨터가 이해하는 정보","date":"2026-01-17","tags":["컴퓨터구조"],"pointColor":"#ffffff"}},{"fields":{"slug":"/computer-architecture-big-picture/"},"frontmatter":{"title":"[컴퓨터구조] 1. 컴퓨터구조의 큰 그림","date":"2026-01-15","tags":["컴퓨터구조"],"pointColor":"#ffffff"}},{"fields":{"slug":"/java-coding-test-grammer/"},"frontmatter":{"title":"Java 코딩테스트 문법 최종 정리","date":"2026-01-08","tags":["알고리즘"],"pointColor":"#ed8b00"}},{"fields":{"slug":"/lg-webos-tv-fullstack-appliaction/"},"frontmatter":{"title":"WebOS TV에 들어갈 풀스택 애플리케이션을 만들어보자 (LG전자 산학 프로젝트 후기)","date":"2025-12-22","tags":["회고"],"pointColor":"#ffffff"}},{"fields":{"slug":"/algorithm-maximum-flow/"},"frontmatter":{"title":"알고리즘설계와분석 - 최대 유량 문제 (Maximum Flow)","date":"2025-12-16","tags":["알고리즘"],"pointColor":"#ffffff"}},{"fields":{"slug":"/algorithm-shortest-path/"},"frontmatter":{"title":"알고리즘설계와분석 - 최단경로 (Shortest Path)","date":"2025-12-13","tags":["알고리즘"],"pointColor":"#ffffff"}},{"fields":{"slug":"/algorithm-minimum-spanning-tree/"},"frontmatter":{"title":"알고리즘설계와분석 - MST (최소신장트리)","date":"2025-12-12","tags":["알고리즘"],"pointColor":"#ffffff"}},{"fields":{"slug":"/algorithm-bfs-dfs/"},"frontmatter":{"title":"BFS/DFS와 Topological Sort","date":"2025-12-11","tags":["알고리즘"],"pointColor":"#ffffff"}},{"fields":{"slug":"/algorithm-greedy-algorithm/"},"frontmatter":{"title":"알고리즘설계와분석 - Greedy algorithm (그리디 알고리즘)","date":"2025-12-10","tags":["알고리즘"],"pointColor":"#ffffff"}},{"fields":{"slug":"/algorithm-dynamic-programming/"},"frontmatter":{"title":"알고리즘설계와분석 - Dynamic Programming (동적 계획법)","date":"2025-12-07","tags":["알고리즘"],"pointColor":"#ffffff"}},{"fields":{"slug":"/algorithm-binary-search-tree/"},"frontmatter":{"title":"알고리즘설계와분석 - Binary Search Tree (이진 탐색 트리)","date":"2025-12-05","tags":["알고리즘"],"pointColor":"#ffffff"}},{"fields":{"slug":"/database-system-erd/"},"frontmatter":{"title":"데이터베이스 시스템 개론 📚 - Chapter2. ERD로 데이터베이스 설계하기","date":"2025-10-05","tags":["DB"],"pointColor":"#ffffff"}},{"fields":{"slug":"/make-huggingface-pipeline/"},"frontmatter":{"title":"허깅페이스로 파이프라인을 만들어보자","date":"2025-10-04","tags":["AI"],"pointColor":"#FF9A00"}},{"fields":{"slug":"/rag-core-concept/"},"frontmatter":{"title":"RAG의 핵심 개념과 원리를 실습과 함께 알아봅니다.","date":"2025-10-01","tags":["AI"],"pointColor":"#FF6B6B"}},{"fields":{"slug":"/prompt-engineering-basic/"},"frontmatter":{"title":"프롬프트 엔지니어링의 기초 개념과 기법을 python 코드와 함께 알아보자","date":"2025-09-28","tags":["AI"],"pointColor":"#ffffff"}},{"fields":{"slug":"/how-to-use-flutter-riverpod/"},"frontmatter":{"title":"초심자 입장에서 Flutter Riverpod을 '잘' 사용하는 방법 (장문)","date":"2025-09-20","tags":["Flutter"],"pointColor":"#0468d7"}},{"fields":{"slug":"/database-system-introduction/"},"frontmatter":{"title":"데이터베이스 시스템 개론 📚 – Chapter 1. Introduction of Database Systems","date":"2025-09-16","tags":["DB"],"pointColor":"#ffffff"}},{"fields":{"slug":"/kakaobank-devrel-internship-retrospect/"},"frontmatter":{"title":"서비스 개발부터 DevRel까지: 카카오뱅크 인턴쉽 회고","date":"2025-07-28","tags":["인턴","회고","카카오뱅크","네이버랩스"],"pointColor":"#ffe300"}},{"fields":{"slug":"/my-it-startup-internship-retrospect/"},"frontmatter":{"title":"나의 IT 스타트업 인턴쉽 회고","date":"2025-03-14","tags":["인턴","회고"],"pointColor":"#6FE7FF"}},{"fields":{"slug":"/sogang-likelion-management-retrospect/"},"frontmatter":{"title":"서강대학교 멋쟁이사자처럼 운영진 회고","date":"2025-02-27","tags":["멋쟁이사자처럼","회고"],"pointColor":"#FD7911"}}]},"markdownRemark":{"id":"e653a78d-eff6-5ea5-ba4f-6d3c9121632f","excerpt":"책을 읽으면서 배운 점을 정리합니다. 응용 계층의 핵심은 HTTP이다. 개발자가 가장 자주 접하고 다루게 될 프로토콜로, 웹의 근간을 이루는 프로토콜이다. HTTP를 이해하기 위해서는 DNS와 URI/URL에 대한 배경지식이 필요하며, HTTP…","html":"<blockquote>\n<p><code class=\"language-text\">혼자 공부하는 네트워크</code> 책을 읽으면서 배운 점을 정리합니다.</p>\n<p>응용 계층의 핵심은 HTTP이다. 개발자가 가장 자주 접하고 다루게 될 프로토콜로, 웹의 근간을 이루는 프로토콜이다. HTTP를 이해하기 위해서는 DNS와 URI/URL에 대한 배경지식이 필요하며, HTTP의 특징과 메시지 구조, 메서드와 상태 코드에 대한 이해가 필수적이다.</p>\n</blockquote>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 1000px; background: transparent;\"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/static/207c8b7097ff2de1790c0289a5f6716c/7c474/index.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 48.800000000000004%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAKCAYAAAC0VX7mAAAACXBIWXMAACE4AAAhOAFFljFgAAABVElEQVR42o1Sy07CUBDlqxVFrImPjQ984CMmuHBliG50wTOQgNCWgrS9hUbFSCQxYsI3HGemSUVSgovJnTtz7pk5cyfWWi8h0rTyjE3F570hi0UFzbUijNUCjJU89Hg+9M1EQXzO/58wWURnpwo7VYc6M+BfteEcNqDSOuyDOnqXLXR3a3NJY7MyuZPn6yeMzRG+rREmaoyPwgsm3hfe73181ocYZF3pPEr+L6EWGEvyLgwMH3y83jgY3LrS5dudCu5ZJXmD5IdzjSI0E0WRK3Oi6vpSDvpyTnyTisg9ng+NJTOWc5GETuoRne0q+tSNn7HgHjVEuko30d6qwD1uwjs34J3q6NMcbcK76cC3Nsp/CU3qjAfNn8FyevSwu1eTD1AnRLhZgU15m2J8cjHG2/s1KWhp5WjJ4brwaoQrQpKSJTlFJmNYquADzMI9nP2ohZgpwh8Xn2VNjiNOowAAAABJRU5ErkJggg=='); background-size: cover; display: block;\"\n  ></span>\n  <picture>\n          <source\n              srcset=\"/static/207c8b7097ff2de1790c0289a5f6716c/bc904/index.webp 250w,\n/static/207c8b7097ff2de1790c0289a5f6716c/4be29/index.webp 500w,\n/static/207c8b7097ff2de1790c0289a5f6716c/03f31/index.webp 1000w,\n/static/207c8b7097ff2de1790c0289a5f6716c/84f56/index.webp 1329w\"\n              sizes=\"(max-width: 1000px) 100vw, 1000px\"\n              type=\"image/webp\"\n            />\n          <source\n            srcset=\"/static/207c8b7097ff2de1790c0289a5f6716c/43fa5/index.png 250w,\n/static/207c8b7097ff2de1790c0289a5f6716c/c6e3d/index.png 500w,\n/static/207c8b7097ff2de1790c0289a5f6716c/da8b6/index.png 1000w,\n/static/207c8b7097ff2de1790c0289a5f6716c/7c474/index.png 1329w\"\n            sizes=\"(max-width: 1000px) 100vw, 1000px\"\n            type=\"image/png\"\n          />\n          <img\n            class=\"gatsby-resp-image-image\"\n            src=\"/static/207c8b7097ff2de1790c0289a5f6716c/da8b6/index.png\"\n            alt=\"index\"\n            title=\"\"\n            loading=\"lazy\"\n            decoding=\"async\"\n            style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n          />\n        </picture>\n  </a>\n    </span></p>\n<h2 id=\"1️-dns와-uriurl\">1️⃣ DNS와 URI/URL</h2>\n<h3 id=\"도메인-네임과-dns\">도메인 네임과 DNS</h3>\n<h4 id=\"1-1-도메인-네임의-필요성\">1-1 도메인 네임의 필요성</h4>\n<p>네트워크 상의 호스트를 식별하기 위해 기본적으로 사용되는 정보는 <code class=\"language-text\">IP 주소</code>이다. 하지만 IP 주소만을 사용하기에는 다소 번거롭다. IP 주소로는 특정 호스트의 특징을 나타내기 어렵고, 호스트의 IP 주소는 언제든 바뀔 수 있기 때문이다.</p>\n<p><code class=\"language-text\">도메인 네임(Domain Name)</code>은 이러한 문제를 해결하기 위한 문자열 형태의 호스트 식별 정보로, 호스트의 IP 주소와 대응된다.</p>\n<div class=\"gatsby-highlight\" data-language=\"txt\"><pre class=\"language-txt\"><code class=\"language-txt\">이런 것들이 다 도메인 네임이다.\nwww.example.com\ndevelopers.naver.com\ngit.kernel.org</code></pre></div>\n<p>도메인 네임은 IP 주소에 비해 <strong>기억이 쉽다</strong>. 또한 IP 주소가 바뀌더라도 바뀐 IP 주소에 도메인 네임을 다시 대응하면 되므로 IP 주소만으로 호스트를 특정하는 것보다 더 간편하다.</p>\n<blockquote>\n<p>💡 <strong>도메인 네임의 리졸빙(Resolving)</strong></p>\n<p>도메인 네임과 그에 대응하는 IP 주소는 <code class=\"language-text\">네임 서버(Name Server)</code> 또는 <code class=\"language-text\">DNS 서버</code>에서 관리된다. IP 주소를 모르는 상태에서 도메인 네임에 대응되는 IP 주소를 알아내는 과정을 <strong>리졸빙(Resolving)</strong> 한다고 표현한다.</p>\n<div class=\"gatsby-highlight\" data-language=\"java\"><pre class=\"language-java\"><code class=\"language-java\"><span class=\"token comment\">// 도메인 네임 리졸빙 개념</span>\n<span class=\"token class-name\">String</span> domainName <span class=\"token operator\">=</span> <span class=\"token string\">\"www.example.com\"</span><span class=\"token punctuation\">;</span>\n<span class=\"token class-name\">InetAddress</span> ipAddress <span class=\"token operator\">=</span> <span class=\"token class-name\">InetAddress</span><span class=\"token punctuation\">.</span><span class=\"token function\">getByName</span><span class=\"token punctuation\">(</span>domainName<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token comment\">// DNS 서버에 질의하여 IP 주소 획득</span></code></pre></div>\n</blockquote>\n<h4 id=\"1-2-도메인-네임의-계층-구조\">1-2 도메인 네임의 계층 구조</h4>\n<p>하나의 도메인 네임은 점(.)을 기준으로 <strong>계층적으로 분류</strong>되어 있다.</p>\n<p><figure class=\"gatsby-resp-image-figure\" style=\"background: transparent;\">\n    <span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 361px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/static/9448e03dc20e616e8c1b2ab752de0b0b/d0bd4/dns-hierarchy.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 50%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAKCAIAAAA7N+mxAAAACXBIWXMAAAsTAAALEwEAmpwYAAABGUlEQVR42mWR2W6FMAxE+f+PQ4IHQCCB2PetLaVQlh7FcFXaebCcxDMeO5rv+7quG4ZhmmaWZdM0jeP4/sTHjbcntG3b9n0nHscBzbZt+PM8E79uiBw32xPaeQMyz5Zl0aFt277vkfhUCMMQU3VdU3P+wkUWAs+YaZqm6zqYy7LA/L4hR7nHzkVe19XzvKIooMEn0gqreZ5HUYRh2pLHccw9saoqIi40NHhAEhryOC/LkiNeOMo6ZgUaSkKN+NfI6EkF8lRjmJ2R8wuMPSngiyPdgiAgd133Ip//MAwDXuDTiv60Ei12yRQy4LWwQ0G2TaQUJiMgwUT4R4IcpuM4SZIw8N9tv8hsO1EgwTDbQo5WaZqywleZkH8ALHc3PZgpoboAAAAASUVORK5CYII='); background-size: cover; display: block;\"\n  ></span>\n  <picture>\n          <source\n              srcset=\"/static/9448e03dc20e616e8c1b2ab752de0b0b/bc904/dns-hierarchy.webp 250w,\n/static/9448e03dc20e616e8c1b2ab752de0b0b/94667/dns-hierarchy.webp 361w\"\n              sizes=\"(max-width: 361px) 100vw, 361px\"\n              type=\"image/webp\"\n            />\n          <source\n            srcset=\"/static/9448e03dc20e616e8c1b2ab752de0b0b/43fa5/dns-hierarchy.png 250w,\n/static/9448e03dc20e616e8c1b2ab752de0b0b/d0bd4/dns-hierarchy.png 361w\"\n            sizes=\"(max-width: 361px) 100vw, 361px\"\n            type=\"image/png\"\n          />\n          <img\n            class=\"gatsby-resp-image-image\"\n            src=\"/static/9448e03dc20e616e8c1b2ab752de0b0b/d0bd4/dns-hierarchy.png\"\n            alt=\"도메인 계층 구조\u001b\"\n            title=\"\"\n            loading=\"lazy\"\n            decoding=\"async\"\n            style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n          />\n        </picture>\n  </a>\n    </span>\n    <figcaption class=\"gatsby-resp-image-figcaption\">도메인 계층 구조\u001b</figcaption>\n  </figure></p>\n<table>\n<thead>\n<tr>\n<th>계층</th>\n<th>명칭</th>\n<th>예시</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>루트 도메인</td>\n<td>Root Domain</td>\n<td><code class=\"language-text\">.</code> (생략 가능)</td>\n</tr>\n<tr>\n<td>최상위 도메인</td>\n<td>TLD (Top-Level Domain)</td>\n<td>com, net, org, kr, jp</td>\n</tr>\n<tr>\n<td>2단계 도메인</td>\n<td>Second-Level Domain</td>\n<td>example</td>\n</tr>\n<tr>\n<td>3단계 도메인</td>\n<td>Third-Level Domain</td>\n<td>www, mail, developer</td>\n</tr>\n</tbody>\n</table>\n<p><code class=\"language-text\">FQDN(Fully Qualified Domain Name)</code>은 도메인 네임을 모두 포함하는 전체 주소 도메인 네임을 의미하며, 이를 통해 호스트를 식별할 수 있다.</p>\n<blockquote>\n<p>💡 <strong>서브 도메인(Subdomain)</strong></p>\n<p>다른 도메인이 포함된 도메인을 서브 도메인이라고 부른다. 예를 들어 다음은 모두 <code class=\"language-text\">example.com</code>의 서브 도메인이다.</p>\n<ul>\n<li><code class=\"language-text\">mail.example.com</code></li>\n<li><code class=\"language-text\">www.example.com</code></li>\n<li><code class=\"language-text\">developer.example.com</code></li>\n</ul>\n</blockquote>\n<h4 id=\"1-3-dns의-계층-구조\">1-3 DNS의 계층 구조</h4>\n<p>계층적 형태로 이뤄진 도메인 네임을 관리하는 네임 서버 또한 계층적 형태를 이룬다. 네임 서버는 여러 개가 존재하며 전 세계 여러 곳에 분산되어 있다. 이렇게 계층적으로 분산되어 있는 도메인 네임에 대한 관리 체계를 <code class=\"language-text\">DNS(Domain Name System)</code>라고 부른다.</p>\n<h5>DNS 리졸빙 과정</h5>\n<p>호스트가 <code class=\"language-text\">minchul.net</code>이라는 도메인 네임을 통해 IP 주소를 알아내고자 하는 경우를 가정해보자.</p>\n<p><strong>1. 로컬 네임 서버에 질의</strong></p>\n<ul>\n<li><code class=\"language-text\">로컬 네임 서버(Local Name Server)</code>는 클라이언트와 맞닿아 있는 네임 서버</li>\n<li>클라이언트가 도메인 네임을 통해 IP 주소를 알아내고자 할 때 가장 먼저 찾는 서버</li>\n<li>ISP가 자동으로 할당하거나 공개 DNS 서버(구글의 <code class=\"language-text\">8.8.8.8</code>, 클라우드플레어의 <code class=\"language-text\">1.1.1.1</code>) 사용</li>\n</ul>\n<p><strong>2. 계층적 질의</strong></p>\n<ul>\n<li>로컬 네임 서버가 IP 주소를 알고 있다면 즉시 반환</li>\n<li>모른다면 <code class=\"language-text\">루트 네임 서버</code> → <code class=\"language-text\">TLD 네임 서버</code> → 하위 네임 서버 순으로 질의</li>\n<li>최종적으로 IP 주소를 찾아 클라이언트에게 전달</li>\n</ul>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">클라이언트\n    ↓ ① 도메인 질의\n로컬 네임 서버\n    ↓ ② 루트 네임 서버 질의\n루트 네임 서버\n    ↓ ③ TLD 네임 서버 정보 응답\n로컬 네임 서버\n    ↓ ④ TLD 네임 서버 질의\nTLD 네임 서버\n    ↓ ⑤ 권한 네임 서버 정보 응답\n로컬 네임 서버\n    ↓ ⑥ 권한 네임 서버 질의\n권한 네임 서버\n    ↓ ⑦ IP 주소 응답\n로컬 네임 서버\n    ↓ ⑧ IP 주소 전달\n클라이언트</code></pre></div>\n<blockquote>\n<p>💡 <strong>DNS 캐시(DNS Cache)</strong></p>\n<p>질의 과정이 반복되면 네트워크 트래픽이 증가하고 리졸빙에 오랜 시간이 걸린다. 따라서 실제로는 네임 서버들이 기존에 응답받은 결과를 임시로 저장했다가 추후 같은 질의에 활용한다.</p>\n<ul>\n<li><strong>DNS 캐시</strong>: 이전 질의 결과를 임시 저장</li>\n<li><strong>TTL(Time To Live)</strong>: 캐시될 수 있는 시간 (IP 헤더의 TTL과는 무관)</li>\n<li>자주 접속하는 웹사이트는 대부분 로컬 네임 서버 선에서 캐시되어 있음</li>\n</ul>\n</blockquote>\n<h4 id=\"1-4-dns-레코드-타입\">1-4 DNS 레코드 타입</h4>\n<p>도메인 네임을 IP 주소에 대응하기 위해서는 네임 서버에 <code class=\"language-text\">DNS 자원 레코드(DNS Resource Record)</code> 또는 <code class=\"language-text\">DNS 레코드</code>를 추가해야 한다.</p>\n<h5>DNS 레코드의 구성</h5>\n<p>모든 DNS 레코드는 기본적으로 다음 정보를 포함한다.</p>\n<ul>\n<li><strong>이름(Record Name)</strong>: 도메인 네임</li>\n<li><strong>값(Value)</strong>: 이름에 대응하는 값</li>\n<li><strong>레코드 타입(Record Type)</strong>: &#x3C;이름, 값> 쌍의 유형</li>\n<li><strong>TTL</strong>: 레코드가 캐시될 수 있는 시간</li>\n</ul>\n<h5>주요 레코드 타입</h5>\n<table>\n<thead>\n<tr>\n<th>레코드 유형</th>\n<th>설명</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>A</td>\n<td>도메인 네임과 IPv4 주소의 대응 관계</td>\n</tr>\n<tr>\n<td>AAAA</td>\n<td>도메인 네임과 IPv6 주소의 대응 관계</td>\n</tr>\n<tr>\n<td>CNAME</td>\n<td>호스트 네임에 대한 별칭 지정</td>\n</tr>\n<tr>\n<td>NS</td>\n<td>특정 호스트의 IP 주소를 찾을 수 있는 네임 서버</td>\n</tr>\n<tr>\n<td>MX</td>\n<td>해당 도메인과 연동되어 있는 메일 서버</td>\n</tr>\n</tbody>\n</table>\n<p><strong>레코드 예시</strong></p>\n<table>\n<thead>\n<tr>\n<th>레코드 유형</th>\n<th>이름</th>\n<th>값</th>\n<th>TTL</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>A</td>\n<td>example.com.</td>\n<td>1.2.3.4</td>\n<td>300</td>\n</tr>\n<tr>\n<td>CNAME</td>\n<td><a href=\"http://www.example.com\">www.example.com</a></td>\n<td>example.com.</td>\n<td>300</td>\n</tr>\n</tbody>\n</table>\n<p>첫 번째 레코드는 <code class=\"language-text\">example.com.</code>이 <code class=\"language-text\">1.2.3.4</code>에 대응됨을 의미한다. 두 번째 레코드는 <code class=\"language-text\">www.example.com.</code>을 <code class=\"language-text\">example.com.</code>의 별칭으로 사용하므로, <code class=\"language-text\">www.example.com.</code>을 질의하면 <code class=\"language-text\">1.2.3.4</code>를 응답받게 된다.</p>\n<h3 id=\"자원과-uriurl\">자원과 URI/URL</h3>\n<h4 id=\"1-5-자원의-개념\">1-5 자원의 개념</h4>\n<p><code class=\"language-text\">자원(Resource)</code>이란 네트워크 상의 메시지를 통해 주고받는 최종 대상을 의미한다. HTML 파일, 이미지, 동영상 파일, 텍스트 파일 등이 모두 자원이 될 수 있다. 두 호스트가 네트워크를 통해 서로 정보를 주고받을 때 송수신하는 대상이 바로 자원이다.</p>\n<h4 id=\"1-6-uri와-url\">1-6 URI와 URL</h4>\n<p><code class=\"language-text\">URI(Uniform Resource Identifier)</code>는 웹 상에서의 자원을 식별하기 위한 정보를 의미한다. 자원을 <strong>통일된 방식(Uniform)</strong> 으로 <strong>식별(Identifier)</strong> 하는 것이 URI이다.</p>\n<p>자원을 식별할 때는 <strong>이름</strong>을 기반으로 식별하기도 하고, <strong>위치</strong>를 기반으로 식별하기도 한다.</p>\n<ul>\n<li><strong>URN(Uniform Resource Name)</strong>: 이름으로 자원을 식별</li>\n<li><strong>URL(Uniform Resource Locator)</strong>: 위치로 자원을 식별</li>\n</ul>\n<p>오늘날 인터넷 환경에서는 <strong>위치 기반의 식별자인 URL</strong>이 더 많이 사용된다.</p>\n<h4 id=\"1-7-url의-구조\">1-7 URL의 구조</h4>\n<p>일반적인 URL의 구조는 다음과 같다.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">http://www.example.com:8042/over/there?name=ferret#nose\n└─┬─┘ └──────┬──────┘└─┬─┘└────┬────┘└────┬────┘└─┬─┘\nscheme    authority   port   path      query    fragment</code></pre></div>\n<h5>① scheme</h5>\n<p><code class=\"language-text\">scheme</code>는 자원에 접근하는 방법을 나타낸다. 일반적으로 <strong>사용할 프로토콜</strong>이 명시된다.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">http://   → HTTP 프로토콜 사용\nhttps://  → HTTPS 프로토콜 사용</code></pre></div>\n<h5>② authority</h5>\n<p><code class=\"language-text\">authority</code>에는 호스트를 특정할 수 있는 <strong>IP 주소나 도메인 네임</strong>이 명시된다. 콜론(<code class=\"language-text\">:</code>) 뒤에 포트 번호를 명시할 수도 있다.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">www.example.com:8042</code></pre></div>\n<h5>③ path</h5>\n<p><code class=\"language-text\">path</code>에는 자원이 위치하고 있는 <strong>경로</strong>가 명시된다. 슬래시(<code class=\"language-text\">/</code>)를 기준으로 계층적으로 표현된다.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">http://example.com/home/images/a.png\n                   └─────┬─────────┘\n                       path</code></pre></div>\n<h5>④ query</h5>\n<p><code class=\"language-text\">query</code>는 URL에 대한 <strong>매개변수</strong> 역할을 하는 문자열이다. <code class=\"language-text\">쿼리 문자열(Query String)</code> 또는 <code class=\"language-text\">쿼리 파라미터(Query Parameter)</code>라고도 부른다.</p>\n<p>쿼리 문자열은 <strong>물음표(<code class=\"language-text\">?</code>)로 시작</strong>되는 <code class=\"language-text\">&lt;키=값></code> 형태의 데이터로, **앰퍼샌드(<code class=\"language-text\">&amp;</code>)**를 사용하여 여러 쿼리 문자열을 연결할 수 있다.</p>\n<p><strong>쿼리 문자열 예시 1: 부동산 검색</strong></p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">http://example.com/search?location=seoul&amp;rooms=2&amp;size=100&amp;min_price=200000\n\n지역: seoul\n침실 수: 2개\n면적: 100\n최소 가격: 200000</code></pre></div>\n<p><strong>쿼리 문자열 예시 2: 상품 검색</strong></p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">http://example.com/search?category=books&amp;brand=hanbit&amp;discounted=true&amp;sorted=price_desc\n\n카테고리: 도서\n브랜드: 한빛\n할인: 진행 중\n정렬: 가격별 내림차순</code></pre></div>\n<h5>⑤ fragment</h5>\n<p><code class=\"language-text\">fragment</code>는 자원의 일부분, 자원의 한 조각을 가리키기 위한 정보이다. 일반적으로 HTML 파일에서 <strong>특정 부분을 가리키는 데</strong> 사용된다.</p>\n<div class=\"gatsby-highlight\" data-language=\"java\"><pre class=\"language-java\"><code class=\"language-java\"><span class=\"token comment\">// URL 비교</span>\n<span class=\"token class-name\">String</span> url1 <span class=\"token operator\">=</span> <span class=\"token string\">\"https://datatracker.ietf.org/doc/html/rfc3986\"</span><span class=\"token punctuation\">;</span>\n<span class=\"token comment\">// → HTML 파일의 첫 부분으로 이동</span>\n\n<span class=\"token class-name\">String</span> url2 <span class=\"token operator\">=</span> <span class=\"token string\">\"https://datatracker.ietf.org/doc/html/rfc3986#section-1.1.2\"</span><span class=\"token punctuation\">;</span>\n<span class=\"token comment\">// → HTML 파일의 특정 섹션(section-1.1.2)으로 이동</span></code></pre></div>\n<blockquote>\n<p>💡 <strong>URN의 특징</strong></p>\n<p><code class=\"language-text\">URN</code>은 자원에 고유한 이름을 붙이는 이름 기반의 식별자이다. <strong>자원의 위치와 무관</strong>하게 자원을 식별할 수 있다는 장점이 있다.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">urn:isbn:0451450523</code></pre></div>\n<p>위는 ISBN이 <code class=\"language-text\">0451450523</code>인 도서를 나타내는 URN이다. 위치나 프로토콜과 무관하게 자원을 식별할 수 있다. 다만 URN은 아직 URL만큼 널리 채택된 방식은 아니다.</p>\n</blockquote>\n<h2 id=\"2️-http의-특징과-메시지-구조\">2️⃣ HTTP의 특징과 메시지 구조</h2>\n<h3 id=\"http의-목적과-특징\">HTTP의 목적과 특징</h3>\n<p>HTTP의 목적은 애플리케이션의 다양한 자원을 네트워크를 통해 송수신하는 것이다. <strong>데이터의 형식에 구애받지 않고</strong> 다양한 애플리케이션 데이터의 송수신을 가능하게 하는 것이 HTTP의 주된 목적이다.</p>\n<h4 id=\"2-1-http의-4가지-특징\">2-1 HTTP의 4가지 특징</h4>\n<p>HTTP에는 주요한 특징 4가지가 있으며, 이는 프로그래밍에 큰 영향을 끼친다.</p>\n<table>\n<thead>\n<tr>\n<th>특징</th>\n<th>설명</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>요청-응답 기반 프로토콜</td>\n<td>요청 메시지와 응답 메시지를 주고받는 구조</td>\n</tr>\n<tr>\n<td>미디어 독립적 프로토콜</td>\n<td>다양한 종류의 자원을 주고받을 수 있음</td>\n</tr>\n<tr>\n<td>스테이트리스 프로토콜</td>\n<td>상태를 유지하지 않음</td>\n</tr>\n<tr>\n<td>지속 연결 프로토콜</td>\n<td>하나의 TCP 연결로 여러 요청-응답 처리 가능</td>\n</tr>\n</tbody>\n</table>\n<h5>요청-응답 기반 프로토콜</h5>\n<p>HTTP는 기본적으로 요청 메시지를 보내는 <strong>클라이언트</strong>와 이에 대한 응답 메시지를 보내는 <strong>서버</strong>가 서로 HTTP 요청 메시지와 HTTP 응답 메시지를 주고받는 구조로 작동한다.</p>\n<h5>미디어 독립적 프로토콜</h5>\n<p>HTTP 메시지를 통해 HTML, JPEG, PNG, JSON, XML, PDF 등 <strong>다양한 종류의 자원</strong>을 주고받을 수 있다. HTTP는 주고받을 자원의 특성과 무관하게 자원을 주고받는 수단의 역할만 수행한다.</p>\n<p>HTTP에서 메시지로 주고받는 자원의 종류를 <code class=\"language-text\">미디어 타입(Media Type)</code> 또는 <code class=\"language-text\">MIME 타입(Multipurpose Internet Mail Extensions Type)</code>이라고 부른다.</p>\n<p><strong>미디어 타입 구조</strong></p>\n<p>미디어 타입은 슬래시를 기준으로 하는 <code class=\"language-text\">타입/서브타입(type/subtype)</code> 형식으로 구성된다.</p>\n<table>\n<thead>\n<tr>\n<th>타입</th>\n<th>설명</th>\n<th>서브타입 예시</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>text</td>\n<td>텍스트 형식 데이터</td>\n<td>plain, html, css, javascript</td>\n</tr>\n<tr>\n<td>image</td>\n<td>이미지 형식 데이터</td>\n<td>png, jpeg, webp, gif</td>\n</tr>\n<tr>\n<td>video</td>\n<td>비디오 형식 데이터</td>\n<td>mp4, ogg, webm</td>\n</tr>\n<tr>\n<td>audio</td>\n<td>오디오 형식 데이터</td>\n<td>midi, wav</td>\n</tr>\n<tr>\n<td>application</td>\n<td>바이너리 형식 데이터</td>\n<td>octet-stream, pdf, xml, json, x-www-form-urlencoded</td>\n</tr>\n<tr>\n<td>multipart</td>\n<td>여러 요소로 구성된 데이터</td>\n<td>form-data, encrypted</td>\n</tr>\n</tbody>\n</table>\n<blockquote>\n<p>💡 <strong>미디어 타입의 추가 표기</strong></p>\n<ul>\n<li><strong>별표(<code class=\"language-text\">*</code>)</strong>: 여러 미디어 타입을 통칭 (<code class=\"language-text\">text/*</code>, <code class=\"language-text\">*/*</code>)</li>\n<li><strong>매개변수</strong>: 부가 설명 추가 가능 (<code class=\"language-text\">text/html;charset=UTF-8</code>)</li>\n</ul>\n</blockquote>\n<h5>스테이트리스 프로토콜</h5>\n<p>HTTP는 <strong>상태를 유지하지 않는</strong> <code class=\"language-text\">스테이트리스(Stateless)</code> 프로토콜이다. 서버는 HTTP 요청을 보낸 클라이언트 관련 상태를 기억하지 않는다. 클라이언트의 모든 HTTP 요청은 기본적으로 <strong>독립적인 요청</strong>으로 간주된다.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">1. Introduction\n1.1. Purpose\nThe Hypertext Transfer Protocol (HTTP) is a family of stateless,\napplication-level, request/response protocols...</code></pre></div>\n<p><strong>스테이트리스의 이유와 장점</strong></p>\n<p>HTTP 서버는 많은 클라이언트와 동시에 상호작용한다. 모든 클라이언트의 상태 정보를 유지하는 것은 서버에 큰 부담이 된다.</p>\n<ul>\n<li><strong>확장성(Scalability)</strong>: 서버의 추가나 대체가 쉬움</li>\n<li><strong>견고성(Robustness)</strong>: 서버 하나에 문제가 생기더라도 다른 서버로 쉽게 대체 가능</li>\n<li>특정 클라이언트가 특정 서버에 종속되지 않음</li>\n</ul>\n<h5>지속 연결 프로토콜</h5>\n<p>오늘날 많이 사용되는 HTTP 버전(HTTP 1.1 이상)에서는 <code class=\"language-text\">지속 연결(Persistent Connection)</code> 또는 <code class=\"language-text\">킵 얼라이브(Keep-Alive)</code> 기술을 제공한다.</p>\n<ul>\n<li><strong>비지속 연결(HTTP 1.0 이하)</strong>: 요청-응답마다 TCP 연결 수립 및 종료 반복</li>\n<li><strong>지속 연결(HTTP 1.1 이상)</strong>: 하나의 TCP 연결 상에서 여러 요청-응답 처리</li>\n</ul>\n<p><figure class=\"gatsby-resp-image-figure\" style=\"background: transparent;\">\n    <span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 742px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/static/5eff72a8a19eec5ccae538a3ae155975/14945/keep-alive.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 28.4%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAGCAIAAABM9SnKAAAACXBIWXMAAAsTAAALEwEAmpwYAAAA8ElEQVR42k2QXW6FIBCF3f8a+txN9LndQZ/aVCuot3hhdPhRwIFyJTWdTCYnZ+YLJzQ5ZwA13m4/YubjqACKk86q4nGgYJimeZ57xu5SXn7D+eCMDnAPIOMKCPDVtlJK733btkKI4Ky31mv0++YNBmd2oxljnPHmoEQOSfRJTSSnFEPBYghEFGOglI5VkjNUpt8IJVksHY7D774pr/v93QxP3fdz138cIZ+pcoFzLp03/XIE5sUrmk6YN72UlFhvHnDOcV1Gxj9XxPxXJ1yFSyniMvOBaQtEqYStqwpnrc0CuLntguuXXBpRKwXObv/9X895WMPAqtdhAAAAAElFTkSuQmCC'); background-size: cover; display: block;\"\n  ></span>\n  <picture>\n          <source\n              srcset=\"/static/5eff72a8a19eec5ccae538a3ae155975/bc904/keep-alive.webp 250w,\n/static/5eff72a8a19eec5ccae538a3ae155975/4be29/keep-alive.webp 500w,\n/static/5eff72a8a19eec5ccae538a3ae155975/e40a6/keep-alive.webp 742w\"\n              sizes=\"(max-width: 742px) 100vw, 742px\"\n              type=\"image/webp\"\n            />\n          <source\n            srcset=\"/static/5eff72a8a19eec5ccae538a3ae155975/43fa5/keep-alive.png 250w,\n/static/5eff72a8a19eec5ccae538a3ae155975/c6e3d/keep-alive.png 500w,\n/static/5eff72a8a19eec5ccae538a3ae155975/14945/keep-alive.png 742w\"\n            sizes=\"(max-width: 742px) 100vw, 742px\"\n            type=\"image/png\"\n          />\n          <img\n            class=\"gatsby-resp-image-image\"\n            src=\"/static/5eff72a8a19eec5ccae538a3ae155975/14945/keep-alive.png\"\n            alt=\"keep-alive OFF/ON\"\n            title=\"\"\n            loading=\"lazy\"\n            decoding=\"async\"\n            style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n          />\n        </picture>\n  </a>\n    </span>\n    <figcaption class=\"gatsby-resp-image-figcaption\">keep-alive OFF/ON</figcaption>\n  </figure></p>\n<blockquote>\n<p>💡 <strong>HTTP 버전별 특징</strong></p>\n<p><strong>HTTP 1.1</strong></p>\n<ul>\n<li><code class=\"language-text\">지속 연결 기능</code> 공식 지원</li>\n<li>평문으로 메시지 송수신</li>\n<li>콘텐츠 협상 기능 추가</li>\n</ul>\n<p><strong>HTTP 2.0</strong></p>\n<ul>\n<li>바이너리 데이터 기반 송수신</li>\n<li>헤더 압축으로 네트워크 효율 향상</li>\n<li>서버 푸시(Server Push): 미래에 필요할 자원을 미리 전송</li>\n<li>HTTP <code class=\"language-text\">멀티플렉싱</code>: 여러 독립적인 스트림으로 요청-응답 병렬 처리</li>\n<li>HOL 블로킹(Head-Of-Line blocking) 문제 완화</li>\n</ul>\n<p><strong>HTTP 3.0</strong></p>\n<ul>\n<li><code class=\"language-text\">UDP</code> 기반의 QUIC(Quick UDP Internet Connections) 프로토콜 사용</li>\n<li>송수신 속도 개선</li>\n</ul>\n</blockquote>\n<h3 id=\"http-메시지-구조\">HTTP 메시지 구조</h3>\n<h4 id=\"2-2-http-메시지의-기본-구조\">2-2 HTTP 메시지의 기본 구조</h4>\n<p>HTTP 메시지는 <strong>시작 라인</strong>, <strong>필드 라인</strong>, <strong>메시지 본문</strong>으로 이루어져 있다.</p>\n<div class=\"gatsby-highlight\" data-language=\"txt\"><pre class=\"language-txt\"><code class=\"language-txt\">시작 라인 (줄바꿈)\n필드 라인* (줄바꿈)\n(줄바꿈)\n메시지 본문**\n\n* 0개 이상\n** 선택적</code></pre></div>\n<p>HTTP는 요청-응답 기반의 프로토콜로, 시작 라인으로 메시지가 <strong>요청 메시지</strong>인지 <strong>응답 메시지</strong>인지를 구분할 수 있다.</p>\n<ul>\n<li><strong>HTTP 요청 메시지</strong>: 시작 라인 = 요청 라인</li>\n<li><strong>HTTP 응답 메시지</strong>: 시작 라인 = 상태 라인</li>\n</ul>\n<h4 id=\"2-3-요청-라인과-상태-라인\">2-3 요청 라인과 상태 라인</h4>\n<p><strong>요청 라인 구조</strong></p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">메서드 (공백) 요청 대상 (공백) HTTP 버전 (줄바꿈)</code></pre></div>\n<table>\n<thead>\n<tr>\n<th>필드</th>\n<th>설명</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>메서드</td>\n<td>클라이언트가 서버의 자원에 대해 수행할 작업의 종류</td>\n</tr>\n<tr>\n<td>요청 대상</td>\n<td>요청을 보낼 서버의 자원 (일반적으로 URL의 path)</td>\n</tr>\n<tr>\n<td>HTTP 버전</td>\n<td>사용된 HTTP 버전 (예: HTTP/1.1)</td>\n</tr>\n</tbody>\n</table>\n<p><strong>상태 라인 구조</strong></p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">HTTP 버전 (공백) 상태 코드 (공백) 이유 구문 (줄바꿈)</code></pre></div>\n<table>\n<thead>\n<tr>\n<th>필드</th>\n<th>설명</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>HTTP 버전</td>\n<td>사용된 HTTP 버전</td>\n</tr>\n<tr>\n<td>상태 코드</td>\n<td>요청에 대한 결과를 나타내는 3자리 정수</td>\n</tr>\n<tr>\n<td>이유 구문</td>\n<td>상태 코드에 대한 문자열 형태의 설명</td>\n</tr>\n</tbody>\n</table>\n<p><strong>상태 라인 예시</strong></p>\n<div class=\"gatsby-highlight\" data-language=\"txt\"><pre class=\"language-txt\"><code class=\"language-txt\">HTTP/1.1 200 OK\nHTTP/1.1 404 Not Found</code></pre></div>\n<h4 id=\"2-4-http-헤더\">2-4 HTTP 헤더</h4>\n<p>HTTP 메시지의 필드 라인에는 <code class=\"language-text\">HTTP 헤더(HTTP Header)</code>가 명시된다. HTTP 헤더는 <strong>HTTP 메시지 전송과 관련한 부가 정보이자 제어 정보</strong>이다.</p>\n<p>HTTP 헤더는 콜론(<code class=\"language-text\">:</code>)을 기준으로 <strong>헤더 이름</strong>과 <strong>헤더 값</strong>으로 구성된다.</p>\n<div class=\"gatsby-highlight\" data-language=\"txt\"><pre class=\"language-txt\"><code class=\"language-txt\">HTTP/1.1 200 OK // 시작 라인 (상태 라인)\nContent-Type: text/html // 필드 라인 , name: value 형태\nContent-Length: 648\n\n&lt;!DOCTYPE html>\n&lt;html태>\n...\n&lt;/html태></code></pre></div>\n<p>HTTP 메시지는 웹 브라우저의 <strong>개발자 도구</strong>에서 쉽게 조회할 수 있다. 크롬 브라우저의 경우 <strong>[개발자 도구] → [네트워크]</strong> 탭에서 확인할 수 있다.</p>\n<h2 id=\"3️-http-메서드와-상태-코드\">3️⃣ HTTP 메서드와 상태 코드</h2>\n<h3 id=\"http-메서드\">HTTP 메서드</h3>\n<h4 id=\"3-1-주요-http-메서드\">3-1 주요 HTTP 메서드</h4>\n<p>HTTP 메서드 중 자주 사용되는 중요 메서드는 <strong>GET, HEAD, POST, PUT, PATCH, DELETE</strong>이다.</p>\n<table>\n<thead>\n<tr>\n<th>HTTP 메서드</th>\n<th>설명</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>GET</td>\n<td>자원을 조회하기 위한 메서드</td>\n</tr>\n<tr>\n<td>HEAD</td>\n<td>GET과 동일하나 헤더만을 응답받는 메서드</td>\n</tr>\n<tr>\n<td>POST</td>\n<td>서버로 하여금 특정 작업을 처리하게끔 하는 메서드</td>\n</tr>\n<tr>\n<td>PUT</td>\n<td>자원을 대체하기 위한 메서드 (덮어쓰기)</td>\n</tr>\n<tr>\n<td>PATCH</td>\n<td>자원에 대한 부분적 수정을 위한 메서드</td>\n</tr>\n<tr>\n<td>DELETE</td>\n<td>자원을 삭제하기 위한 메서드</td>\n</tr>\n<tr>\n<td>CONNECT</td>\n<td>자원에 대한 양방향 연결을 시작하는 메서드</td>\n</tr>\n<tr>\n<td>OPTIONS</td>\n<td>사용 가능한 메서드 등 통신 옵션을 확인하는 메서드</td>\n</tr>\n<tr>\n<td>TRACE</td>\n<td>자원에 대한 루프백 테스트를 수행하는 메서드</td>\n</tr>\n</tbody>\n</table>\n<h4 id=\"3-2-get과-head\">3-2 GET과 HEAD</h4>\n<p><code class=\"language-text\">GET</code>은 가장 흔히 사용되는 메서드로, <strong>자원을 조회</strong>하는 용도의 메서드이다. 웹 브라우저를 통해 웹사이트의 자원을 조회하는 것은 모두 해당 웹사이트에 GET 요청을 보내는 것과 같다.</p>\n<p><strong>GET 요청 메시지 예시</strong></p>\n<div class=\"gatsby-highlight\" data-language=\"txt\"><pre class=\"language-txt\"><code class=\"language-txt\">GET /example-page HTTP/1.1\nHost: www.example.com\nAccept: */*</code></pre></div>\n<p><strong>GET 응답 메시지 예시</strong></p>\n<div class=\"gatsby-highlight\" data-language=\"txt\"><pre class=\"language-txt\"><code class=\"language-txt\">HTTP/1.1 200 OK\nContent-Type: text/html\nContent-Length: 648\n\n&lt;!DOCTYPE html>\n&lt;html>\n&lt;head>\n    &lt;title>Example Page&lt;/title>\n&lt;/head>\n&lt;body>\n    &lt;h1>Hello, World!&lt;/h1>\n&lt;/body>\n&lt;/html></code></pre></div>\n<p><code class=\"language-text\">HEAD</code> 메서드는 응답 메시지에 <strong>메시지 본문이 포함되지 않는다</strong>는 점을 제외하면 GET 메서드와 동일하다.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">HEAD /example-page HTTP/1.1\nHost: www.example.com\nAccept: */*\n\n───────────────────────────\n\nHTTP/1.1 200 OK\nContent-Type: text/html\nContent-Length: 648\n(메시지 본문 없음)</code></pre></div>\n<blockquote>\n<p>💡 <strong>Host 헤더</strong></p>\n<p><code class=\"language-text\">Host</code> 헤더에는 요청을 보낼 호스트가 명시된다. Host 헤더와 요청 라인의 요청 대상을 조합하면 요청을 보내는 전체 URL을 알 수 있다.</p>\n</blockquote>\n<h4 id=\"3-3-post\">3-3 POST</h4>\n<p><code class=\"language-text\">POST</code>는 서버로 하여금 <strong>특정 작업을 처리</strong>하도록 요청하는 용도로 사용되는 메서드이다. 많은 경우 <strong>새로운 자원을 생성</strong>할 때 사용된다.</p>\n<p><strong>POST 요청 메시지 예시</strong></p>\n<div class=\"gatsby-highlight\" data-language=\"txt\"><pre class=\"language-txt\"><code class=\"language-txt\">POST /posting HTTP/1.1\nHost: example.com\nContent-Type: application/json\nContent-Length: 123\n\n{\n    \"id\": 1,\n    \"title\": \"컴퓨터 네트워크\",\n    \"contents\": \"너무 중요한 과목이니 힘들어도 끝까지 화이팅해서 읽어 주세요!!!!!\"\n}</code></pre></div>\n<p><strong>POST 응답 메시지 예시 (자원 생성 성공)</strong></p>\n<div class=\"gatsby-highlight\" data-language=\"txt\"><pre class=\"language-txt\"><code class=\"language-txt\">HTTP/1.1 201 Created\nContent-Type: application/json\nContent-Length: 100\nDate: Mon, 14 Oct 2024 16:35:00 PST\nLocation: /posting/1\n\n{\n    \"id\": 1,\n    \"title\": \"컴퓨터 네트워크\",\n    \"contents\": \"너무 중요한 과목이니 힘들어도 끝까지 화이팅해서 읽어 주세요!!!!!\"\n}</code></pre></div>\n<p>일반적으로 <code class=\"language-text\">Location</code> 헤더를 통해 생성된 자원의 위치를 응답하고, 메시지 본문으로 생성된 자원을 응답한다.</p>\n<h4 id=\"3-4-put과-patch\">3-4 PUT과 PATCH</h4>\n<p><code class=\"language-text\">PUT</code>과 <code class=\"language-text\">PATCH</code>는 둘의 차이점에 유의해야 한다.</p>\n<ul>\n<li><strong>PUT</strong>: 덮어쓰기 (자원 전체를 대체)</li>\n<li><strong>PATCH</strong>: 부분적 수정 (요청한 부분만 수정)</li>\n</ul>\n<p><strong>서버에 존재하는 자원</strong></p>\n<div class=\"gatsby-highlight\" data-language=\"json\"><pre class=\"language-json\"><code class=\"language-json\"><span class=\"token punctuation\">{</span>\n  <span class=\"token property\">\"id\"</span><span class=\"token operator\">:</span> <span class=\"token number\">1</span><span class=\"token punctuation\">,</span>\n  <span class=\"token property\">\"title\"</span><span class=\"token operator\">:</span> <span class=\"token string\">\"오늘도 즐거운 날입니다\"</span><span class=\"token punctuation\">,</span>\n  <span class=\"token property\">\"contents\"</span><span class=\"token operator\">:</span> <span class=\"token string\">\"재미있는 글 보고 가세요\"</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p><strong>PUT 요청</strong></p>\n<div class=\"gatsby-highlight\" data-language=\"txt\"><pre class=\"language-txt\"><code class=\"language-txt\">PUT /posting HTTP/1.1\nHost: example.com\nContent-Type: application/json\n\n{\n    \"id\": 1,\n    \"title\": \"수정된 제목입니다\"\n}</code></pre></div>\n<p><strong>PUT 결과 (전체 대체)</strong></p>\n<div class=\"gatsby-highlight\" data-language=\"json\"><pre class=\"language-json\"><code class=\"language-json\"><span class=\"token punctuation\">{</span>\n  <span class=\"token property\">\"id\"</span><span class=\"token operator\">:</span> <span class=\"token number\">1</span><span class=\"token punctuation\">,</span>\n  <span class=\"token property\">\"title\"</span><span class=\"token operator\">:</span> <span class=\"token string\">\"수정된 제목입니다\"</span>\n  <span class=\"token comment\">// contents 필드가 사라짐</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p><strong>PATCH 요청</strong></p>\n<div class=\"gatsby-highlight\" data-language=\"txt\"><pre class=\"language-txt\"><code class=\"language-txt\">PATCH /posting HTTP/1.1\nHost: example.com\nContent-Type: application/json\n\n{\n    \"id\": 1,\n    \"title\": \"수정된 제목입니다\"\n}</code></pre></div>\n<p><strong>PATCH 결과 (부분 수정)</strong></p>\n<div class=\"gatsby-highlight\" data-language=\"json\"><pre class=\"language-json\"><code class=\"language-json\"><span class=\"token punctuation\">{</span>\n  <span class=\"token property\">\"id\"</span><span class=\"token operator\">:</span> <span class=\"token number\">1</span><span class=\"token punctuation\">,</span>\n  <span class=\"token property\">\"title\"</span><span class=\"token operator\">:</span> <span class=\"token string\">\"수정된 제목입니다\"</span><span class=\"token punctuation\">,</span>\n  <span class=\"token property\">\"contents\"</span><span class=\"token operator\">:</span> <span class=\"token string\">\"재미있는 글 보고 가세요\"</span>\n  <span class=\"token comment\">// contents 필드가 유지됨</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<h4 id=\"3-5-delete\">3-5 DELETE</h4>\n<p><code class=\"language-text\">DELETE</code> 메서드는 <strong>특정 자원의 삭제</strong>를 요청할 때 사용되는 메서드이다.</p>\n<div class=\"gatsby-highlight\" data-language=\"txt\"><pre class=\"language-txt\"><code class=\"language-txt\">DELETE /texts/a.txt HTTP/1.1\nHost: example.com</code></pre></div>\n<p>서버가 어떤 URI(URL)에 어떤 메서드로 요청을 받았을 때 어떻게 행동해야 하는지를 설계하는 것은 <strong>개발자의 몫</strong>이다. 같은 URL에 대한 요청이라고 하더라도 여러 메서드에 대한 동작을 구현할 수도 있고, 어떤 메서드에 대한 동작은 구현하지 않을 수도 있다.</p>\n<h3 id=\"http-상태-코드\">HTTP 상태 코드</h3>\n<h4 id=\"3-6-상태-코드의-분류\">3-6 상태 코드의 분류</h4>\n<p>상태 코드는 요청의 결과를 나타내는 <strong>3자리 정수</strong>이다. <strong>백의 자릿수</strong>를 기준으로 요청 결과의 유형을 구분할 수 있다.</p>\n<table>\n<thead>\n<tr>\n<th>상태 코드</th>\n<th>설명</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>100번대 (100~199)</td>\n<td>정보성 상태 코드</td>\n</tr>\n<tr>\n<td>200번대 (200~299)</td>\n<td>성공 상태 코드</td>\n</tr>\n<tr>\n<td>300번대 (300~399)</td>\n<td>리다이렉션 상태 코드</td>\n</tr>\n<tr>\n<td>400번대 (400~499)</td>\n<td>클라이언트 에러 상태 코드</td>\n</tr>\n<tr>\n<td>500번대 (500~599)</td>\n<td>서버 에러 상태 코드</td>\n</tr>\n</tbody>\n</table>\n<h4 id=\"3-7-200번대-성공-상태-코드\">3-7 200번대: 성공 상태 코드</h4>\n<p>200번대 상태 코드는 <strong>요청이 성공했음</strong>을 의미한다.</p>\n<table>\n<thead>\n<tr>\n<th>상태 코드</th>\n<th>이유 구문</th>\n<th>설명</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>200</td>\n<td>OK</td>\n<td>요청이 성공했음</td>\n</tr>\n<tr>\n<td>201</td>\n<td>Created</td>\n<td>요청이 성공했으며 새로운 자원이 생성되었음</td>\n</tr>\n<tr>\n<td>202</td>\n<td>Accepted</td>\n<td>요청을 잘 받았으나 아직 작업을 끝내지 않았음</td>\n</tr>\n<tr>\n<td>204</td>\n<td>No Content</td>\n<td>요청이 성공했지만 메시지 본문으로 표시할 데이터가 없음</td>\n</tr>\n</tbody>\n</table>\n<h4 id=\"3-8-300번대-리다이렉션-상태-코드\">3-8 300번대: 리다이렉션 상태 코드</h4>\n<p>300번대 상태 코드는 <strong>리다이렉션</strong>과 관련된 상태 코드이다. <code class=\"language-text\">리다이렉션(Redirection)</code>이란 클라이언트가 요청한 자원이 다른 곳에 있을 때 <strong>다른 곳으로 요청을 이동</strong>시키는 것을 의미한다.</p>\n<table>\n<thead>\n<tr>\n<th>상태 코드</th>\n<th>이유 구문</th>\n<th>설명</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>301</td>\n<td>Moved Permanently</td>\n<td>영구적 리다이렉션 - 재요청 메서드가 변경될 수 있음</td>\n</tr>\n<tr>\n<td>308</td>\n<td>Permanent Redirect</td>\n<td>영구적 리다이렉션 - 재요청 메서드가 변경되지 않음</td>\n</tr>\n<tr>\n<td>302</td>\n<td>Found</td>\n<td>일시적 리다이렉션 - 재요청 메서드가 변경될 수 있음</td>\n</tr>\n<tr>\n<td>303</td>\n<td>See Other</td>\n<td>일시적 리다이렉션 - 재요청 메서드가 GET으로 변경됨</td>\n</tr>\n<tr>\n<td>307</td>\n<td>Temporary Redirect</td>\n<td>일시적 리다이렉션 - 재요청 메서드가 변경되지 않음</td>\n</tr>\n<tr>\n<td>304</td>\n<td>Not Modified</td>\n<td>캐시 - 자원이 변경되지 않음</td>\n</tr>\n</tbody>\n</table>\n<h5>영구적 리다이렉션 vs 일시적 리다이렉션</h5>\n<ul>\n<li><strong>영구적 리다이렉션(Permanent Redirection)</strong>: 자원이 완전히 새로운 곳으로 이동하여 경로가 영구적으로 재지정됨. 기존 URL은 기억할 필요가 없음</li>\n<li><strong>일시적 리다이렉션(Temporary Redirection)</strong>: 자원의 위치가 임시로 변경되었거나 임시로 사용할 URL이 필요한 경우. 기존 URL을 기억해야 함</li>\n</ul>\n<h5>재요청 메서드 변경 여부</h5>\n<ul>\n<li><strong>301, 302</strong>: 재요청 메서드가 GET으로 변경될 <strong>가능성</strong>이 있음 (애매모호)</li>\n<li><strong>308, 307</strong>: 재요청 메서드가 <strong>변경되지 않음</strong></li>\n<li><strong>303</strong>: 재요청 메서드가 <strong>반드시 GET</strong>으로 변경됨</li>\n</ul>\n<h4 id=\"3-9-400번대-클라이언트-에러-상태-코드\">3-9 400번대: 클라이언트 에러 상태 코드</h4>\n<p>400번대 상태 코드는 <strong>클라이언트에게 잘못이 있음</strong>을 나타낸다.</p>\n<table>\n<thead>\n<tr>\n<th>상태 코드</th>\n<th>이유 구문</th>\n<th>설명</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>400</td>\n<td>Bad Request</td>\n<td>요청 메시지의 내용이나 형식 자체에 문제가 있음</td>\n</tr>\n<tr>\n<td>401</td>\n<td>Unauthorized</td>\n<td>요청한 자원에 대한 유효한 <strong>인증(Authentication)</strong> 이 없음</td>\n</tr>\n<tr>\n<td>403</td>\n<td>Forbidden</td>\n<td>요청이 서버에 의해 거부됨. 자원에 대한 접근 <strong>권한(Authorization)</strong> 이 충분하지 않음</td>\n</tr>\n<tr>\n<td>404</td>\n<td>Not Found</td>\n<td>요청받은 자원을 찾을 수 없음</td>\n</tr>\n<tr>\n<td>405</td>\n<td>Method Not Allowed</td>\n<td>요청한 메서드를 지원하지 않음</td>\n</tr>\n</tbody>\n</table>\n<blockquote>\n<p>💡 <strong>401 vs 403: 인증과 권한</strong></p>\n<ul>\n<li><strong>인증(Authentication)</strong>: 자신이 누구인지를 증명하는 작업 (예: 로그인)</li>\n<li><strong>권한(Authorization)</strong>: 인증된 주체에게 허용된 작업 (예: 관리자 권한)</li>\n</ul>\n<p>로그인된 모든 유저는 인증된 유저지만, 로그인된 모든 유저가 관리자 페이지에 들어갈 수는 없다. <strong>인증이 되었더라도 권한은 충분하지 않을 수 있다.</strong></p>\n</blockquote>\n<h4 id=\"3-10-500번대-서버-에러-상태-코드\">3-10 500번대: 서버 에러 상태 코드</h4>\n<p>500번대 상태 코드는 <strong>서버에게 잘못이 있음</strong>을 나타낸다.</p>\n<table>\n<thead>\n<tr>\n<th>상태 코드</th>\n<th>이유 구문</th>\n<th>설명</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>500</td>\n<td>Internal Server Error</td>\n<td>요청을 처리할 수 없음</td>\n</tr>\n<tr>\n<td>502</td>\n<td>Bad Gateway</td>\n<td>중간 서버의 통신 오류</td>\n</tr>\n</tbody>\n</table>\n<p>대부분의 500번대 상태 코드는 <code class=\"language-text\">500 (Internal Server Error)</code>이다. 서버에 어떤 문제가 발생했을 때, 익명의 다수 사용자에게 문제의 발생 원인을 상세히 공개하는 것은 <strong>보안상 좋지 않기</strong> 때문에 서버 문제를 가리키는 상태 코드는 500으로 통칭하는 경우가 많다.</p>\n<p><code class=\"language-text\">502 (Bad Gateway)</code>는 클라이언트와 서버 사이에 위치한 중간 서버에서 <strong>통신 오류</strong>가 있었음을 나타낸다.</p>\n<h3 id=\"http-주요-헤더\">HTTP 주요 헤더</h3>\n<h4 id=\"3-11-요청-메시지에서-주로-활용되는-헤더\">3-11 요청 메시지에서 주로 활용되는 헤더</h4>\n<h5>Host</h5>\n<p>요청을 보낼 호스트가 명시되는 헤더이다. 도메인 네임이나 IP 주소로 표현되며, 포트 번호가 포함될 수도 있다.</p>\n<div class=\"gatsby-highlight\" data-language=\"txt\"><pre class=\"language-txt\"><code class=\"language-txt\">GET /hypertext/WWW/TheProject.html HTTP/1.1\nHost: info.cern.ch</code></pre></div>\n<p>Host 헤더와 요청 라인을 조합하면 요청을 보낸 URL을 짐작할 수 있다.\n→ <code class=\"language-text\">http://info.cern.ch/hypertext/WWW/TheProject.html</code></p>\n<h5>User-Agent</h5>\n<p>요청 메시지를 보낸 <strong>클라이언트의 프로그램</strong>과 관련한 정보가 명시된다. 사용된 브라우저의 종류, 운영체제 및 아키텍처 정보, 렌더링 엔진의 종류 등이 포함된다.</p>\n<div class=\"gatsby-highlight\" data-language=\"txt\"><pre class=\"language-txt\"><code class=\"language-txt\">User-Agent: Mozilla/5.0 (&lt;system-information>) &lt;platform> (&lt;platform-details>) &lt;extensions></code></pre></div>\n<p>User-Agent 헤더를 통해 HTTP 요청 메시지를 보낸 클라이언트의 접속 수단을 유추할 수 있다.</p>\n<h5>Referer</h5>\n<p>클라이언트가 요청을 보낼 때 <strong>머무르던 URL</strong>이 명시된다. 이를 통해 <strong>클라이언트의 유입 경로</strong>를 파악할 수 있다.</p>\n<div class=\"gatsby-highlight\" data-language=\"txt\"><pre class=\"language-txt\"><code class=\"language-txt\">Referer: https://minchul.net</code></pre></div>\n<blockquote>\n<p>💡 <strong>Referer는 오타가 아니다</strong></p>\n<p>개발 초기 당시 오타로 표기됐던 'Referer'라는 단어가 오늘날까지 헤더의 이름으로 사용되고 있다. (올바른 철자는 'Referrer')</p>\n</blockquote>\n<h4 id=\"3-12-응답-메시지에서-주로-활용되는-헤더\">3-12 응답 메시지에서 주로 활용되는 헤더</h4>\n<h5>Server</h5>\n<p>HTTP 응답 메시지를 보내는 <strong>서버 호스트와 관련된 정보</strong>가 명시된다.</p>\n<div class=\"gatsby-highlight\" data-language=\"txt\"><pre class=\"language-txt\"><code class=\"language-txt\">Server: Apache/2.4.1 (Unix)</code></pre></div>\n<h5>Allow</h5>\n<p><strong>처리 가능한 HTTP 메서드 목록</strong>을 알리기 위해 사용된다. 주로 <code class=\"language-text\">405 (Method Not Allowed)</code> 상태 코드와 함께 사용된다.</p>\n<div class=\"gatsby-highlight\" data-language=\"txt\"><pre class=\"language-txt\"><code class=\"language-txt\">HTTP/1.1 405 Method Not Allowed\nAllow: POST, OPTIONS</code></pre></div>\n<h5>Location</h5>\n<p>클라이언트에게 <strong>자원의 위치</strong>를 알려 주기 위해 사용된다. 주로 리다이렉션이 발생했을 때나 새로운 자원이 생성되었을 때 사용된다.</p>\n<div class=\"gatsby-highlight\" data-language=\"txt\"><pre class=\"language-txt\"><code class=\"language-txt\">HTTP/1.1 301 Moved Permanently\nLocation: /new\n\n또는\n\nHTTP/1.1 201 Created\nLocation: /posting/1</code></pre></div>\n<h4 id=\"3-13-요청과-응답-모두에서-활용되는-헤더\">3-13 요청과 응답 모두에서 활용되는 헤더</h4>\n<h5>Date</h5>\n<p>메시지가 생성된 <strong>날짜와 시각</strong>에 관련된 정보를 담은 헤더이다.</p>\n<div class=\"gatsby-highlight\" data-language=\"txt\"><pre class=\"language-txt\"><code class=\"language-txt\">Date: Tue, 15 Nov 1994 08:12:31 GMT</code></pre></div>\n<h5>Content-Length</h5>\n<p>메시지 본문의 <strong>바이트 단위 크기(길이)</strong> 를 표현한다.</p>\n<div class=\"gatsby-highlight\" data-language=\"txt\"><pre class=\"language-txt\"><code class=\"language-txt\">Content-Length: 123</code></pre></div>\n<h5>Content-Type, Content-Language, Content-Encoding</h5>\n<p>메시지 본문이 어떻게 <strong>표현</strong>되었는지와 관련된 헤더로 <code class=\"language-text\">표현 헤더(Representation Header)</code>라고도 부른다.</p>\n<p><strong>Content-Type</strong></p>\n<p>메시지 본문에서 사용된 <strong>미디어 타입</strong>을 의미한다.</p>\n<div class=\"gatsby-highlight\" data-language=\"txt\"><pre class=\"language-txt\"><code class=\"language-txt\">Content-Type: text/html;charset=UTF-8</code></pre></div>\n<p><strong>Content-Language</strong></p>\n<p>메시지 본문에 어떤 <strong>자연어</strong>가 사용되었는지를 나타낸다. 언어 태그는 하이픈(-)으로 여러 서브 태그가 구분된다.</p>\n<div class=\"gatsby-highlight\" data-language=\"txt\"><pre class=\"language-txt\"><code class=\"language-txt\">&lt;언어 코드>-&lt;국가 코드>\n\n예시:\nko-KR  → 한국에서 사용하는 한국어\nen-US  → 미국에서 사용하는 영어\nen-GB  → 영국에서 사용하는 영어</code></pre></div>\n<table>\n<thead>\n<tr>\n<th>언어 코드</th>\n<th>언어</th>\n<th>국가 코드</th>\n<th>국가</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>ko</td>\n<td>한국어</td>\n<td>KR</td>\n<td>대한민국</td>\n</tr>\n<tr>\n<td>en</td>\n<td>영어</td>\n<td>US</td>\n<td>미국</td>\n</tr>\n<tr>\n<td>ja</td>\n<td>일본어</td>\n<td>GB</td>\n<td>영국</td>\n</tr>\n<tr>\n<td>zh</td>\n<td>중국어</td>\n<td>JP</td>\n<td>일본</td>\n</tr>\n<tr>\n<td>fr</td>\n<td>프랑스어</td>\n<td>FR</td>\n<td>프랑스</td>\n</tr>\n</tbody>\n</table>\n<p><strong>Content-Encoding</strong></p>\n<p>메시지 본문을 <strong>압축하거나 변환한 방식</strong>이 명시된다. 메시지 본문이 압축/변환될 수 있으며, 수신지 측에서 압축을 해제하고 재변환하기 위해 필요한 정보이다.</p>\n<div class=\"gatsby-highlight\" data-language=\"txt\"><pre class=\"language-txt\"><code class=\"language-txt\">Content-Encoding: gzip\nContent-Encoding: br\nContent-Encoding: deflate, gzip  // 여러 인코딩이 사용된 경우 순서대로 명시</code></pre></div>\n<p>대표적인 인코딩 방식: <code class=\"language-text\">gzip</code>, <code class=\"language-text\">compress</code>, <code class=\"language-text\">deflate</code>, <code class=\"language-text\">br</code></p>\n<h5>Connection</h5>\n<p>HTTP 메시지를 송신하는 호스트가 어떠한 방식의 <strong>연결을 원하는지</strong> 명시하는 헤더이다.</p>\n<div class=\"gatsby-highlight\" data-language=\"txt\"><pre class=\"language-txt\"><code class=\"language-txt\">Connection: keep-alive  // 지속 연결 희망\nConnection: close       // 연결 종료 희망</code></pre></div>\n<h2 id=\"4️-정리\">4️⃣ 정리</h2>\n<ol>\n<li>\n<p><code class=\"language-text\">HTTP</code>는 응용 계층의 핵심 프로토콜로, 웹의 근간을 이루는 프로토콜이다. HTTP를 이해하기 위해서는 <code class=\"language-text\">DNS</code>를 통한 <code class=\"language-text\">도메인 네임 리졸빙</code> 과정과 <code class=\"language-text\">URI/URL</code>을 통한 자원 식별 방법에 대한 배경지식이 필요하다.</p>\n</li>\n<li>\n<p>HTTP는 <code class=\"language-text\">요청-응답 기반</code>, <code class=\"language-text\">미디어 독립적</code>, <code class=\"language-text\">스테이트리스</code>, <code class=\"language-text\">지속 연결</code>이라는 4가지 핵심 특징을 가진다. HTTP 메시지는 <code class=\"language-text\">시작 라인</code>, <code class=\"language-text\">필드 라인</code>, <code class=\"language-text\">메시지 본문</code>으로 구성되며, 요청 메시지와 응답 메시지의 구조가 다르다.</p>\n</li>\n<li>\n<p><code class=\"language-text\">HTTP 메서드</code>는 클라이언트가 서버의 자원에 대해<code class=\"language-text\">수행할 작업</code>의 종류를 나타내며, <code class=\"language-text\">GET</code>, <code class=\"language-text\">POST</code>, <code class=\"language-text\">PUT</code>, <code class=\"language-text\">PATCH</code>, <code class=\"language-text\">DELETE</code> 등이 대표적이다. HTTP 상태 코드는 요청의 결과를 나타내는 3자리 정수로, <code class=\"language-text\">2xx(성공)</code>, <code class=\"language-text\">3xx(리다이렉션)</code>, <code class=\"language-text\">4xx(클라이언트 에러)</code>, <code class=\"language-text\">5xx(서버 에러)</code>로 분류된다.</p>\n</li>\n<li>\n<p><code class=\"language-text\">HTTP 헤더</code>는 메시지 전송과 관련한 <code class=\"language-text\">부가 정보</code>를 제공하며, <code class=\"language-text\">Host</code>, <code class=\"language-text\">User-Agent</code>, <code class=\"language-text\">Content-Type</code>, <code class=\"language-text\">Content-Length</code> 등 다양한 헤더가 존재한다.</p>\n</li>\n</ol>","fields":{"slug":"/http-fundamentals/"},"frontmatter":{"title":"[네트워크] HTTP의 기초 - DNS와 HTTP Message, Method, Status (스압 주의) ","date":"2026-02-16","description":"응용 계층의 핵심 프로토콜 HTTP의 기초 개념과 동작 원리를 정리합니다.","pointColor":"#ffffff","tags":["네트워크"],"keywords":"HTTP, DNS, URI, URL, 도메인 네임, HTTP 메서드, 상태 코드, HTTP 헤더, 요청-응답, REST API, HTTP status","thumbnail":{"publicURL":"/static/207c8b7097ff2de1790c0289a5f6716c/index.png","childImageSharp":{"gatsbyImageData":{"layout":"fixed","placeholder":{"fallback":"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAKCAYAAAC0VX7mAAAACXBIWXMAACE4AAAhOAFFljFgAAABVElEQVR42o1Sy07CUBDlqxVFrImPjQ984CMmuHBliG50wTOQgNCWgrS9hUbFSCQxYsI3HGemSUVSgovJnTtz7pk5cyfWWi8h0rTyjE3F570hi0UFzbUijNUCjJU89Hg+9M1EQXzO/58wWURnpwo7VYc6M+BfteEcNqDSOuyDOnqXLXR3a3NJY7MyuZPn6yeMzRG+rREmaoyPwgsm3hfe73181ocYZF3pPEr+L6EWGEvyLgwMH3y83jgY3LrS5dudCu5ZJXmD5IdzjSI0E0WRK3Oi6vpSDvpyTnyTisg9ng+NJTOWc5GETuoRne0q+tSNn7HgHjVEuko30d6qwD1uwjs34J3q6NMcbcK76cC3Nsp/CU3qjAfNn8FyevSwu1eTD1AnRLhZgU15m2J8cjHG2/s1KWhp5WjJ4brwaoQrQpKSJTlFJmNYquADzMI9nP2ohZgpwh8Xn2VNjiNOowAAAABJRU5ErkJggg=="},"backgroundColor":"transparent","images":{"fallback":{"src":"/static/207c8b7097ff2de1790c0289a5f6716c/a1758/index.png","srcSet":"/static/207c8b7097ff2de1790c0289a5f6716c/a1758/index.png 1200w","sizes":"1200px"},"sources":[{"srcSet":"/static/207c8b7097ff2de1790c0289a5f6716c/afc39/index.webp 1200w","type":"image/webp","sizes":"1200px"}]},"width":1200,"height":585},"fixed":{"src":"/static/207c8b7097ff2de1790c0289a5f6716c/f3583/index.png"}}}}},"previous":{"fields":{"slug":"/transport-layer-tcp-udp/"},"frontmatter":{"title":"[네트워크] 전송 계층 - TCP와 UDP"}},"next":{"fields":{"slug":"/http-advanced-features/"},"frontmatter":{"title":"[네트워크] HTTP의 응용 - 쿠키, 캐시, 보안"}}},"pageContext":{"id":"e653a78d-eff6-5ea5-ba4f-6d3c9121632f","previousPostId":"e2dcd532-3c81-5f24-8d01-6fa07b647c07","nextPostId":"38e86be3-f40f-5f57-b738-57e086c6ffbb"}},"staticQueryHashes":["736397157"],"slicesMap":{}}