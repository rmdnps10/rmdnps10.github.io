{"componentChunkName":"component---src-templates-blog-post-js","path":"/알고리즘설계와분석 - 최단경로/","result":{"data":{"site":{"siteMetadata":{"title":"메인","siteUrl":"https://rmdnps10.github.io","author":{"name":"Inyoung Chung"}}},"markdownRemark":{"id":"862d5cce-cb2f-5732-8349-674ab52ba6ce","excerpt":"학부 수업 \"알고리즘설계와분석\" 내용을 정리한다. 최단경로를 구하는 두 가지 핵심 알고리즘인 와 의 원리와 차이점에 대해 알아보자. 1️⃣ 최단경로의 기본 개념 1-1 최단경로의 정의 그래프의 각 간선에는 가중치(weight…","html":"<blockquote>\n<p>학부 수업 \"알고리즘설계와분석\" 내용을 정리한다.</p>\n</blockquote>\n<p>최단경로를 구하는 두 가지 핵심 알고리즘인 <code class=\"language-text\">Bellman-Ford</code>와 <code class=\"language-text\">Dijkstra</code>의 원리와 차이점에 대해 알아보자.</p>\n<h2 id=\"1️-최단경로의-기본-개념\">1️⃣ 최단경로의 기본 개념</h2>\n<h4 id=\"1-1-최단경로의-정의\">1-1 최단경로의 정의</h4>\n<p>그래프의 각 간선에는 가중치(weight)가 주어진다. 어떤 경로 <code class=\"language-text\">p</code>의 가중치는 경로에 포함된 모든 간선 가중치의 합이다.</p>\n<p>w(p) = ∑_{(u,v) ∈ p} w(u,v)</p>\n<p>시작점 <code class=\"language-text\">u</code>에서 목적지 <code class=\"language-text\">v</code>까지의 <strong>최단경로 가중치</strong> <code class=\"language-text\">δ(u,v)</code>는 다음과 같이 정의한다.</p>\n<p>δ(u,v) = min_{u → v 경로 p} w(p)</p>\n<p>경로가 존재하지 않으면 <code class=\"language-text\">δ(u,v) = +∞</code>이다.</p>\n<p><strong>🔥 핵심 사실</strong></p>\n<ul>\n<li><code class=\"language-text\">δ(s, v)</code>는 <code class=\"language-text\">s→v</code>까지의 shortest distance를 의미한다</li>\n<li>최단경로는 unique할 필요 없다 (여러 개 존재 가능)</li>\n<li>최단경로에는 cycle이 없다 (simple path)</li>\n</ul>\n<h4 id=\"1-2-최단경로의-부분경로-성질\">1-2 최단경로의 부분경로 성질</h4>\n<p>최단경로 <code class=\"language-text\">p = ⟨v₀, v₁, ..., vₖ⟩</code>가 있을 때, 이 경로의 임의의 부분경로 <code class=\"language-text\">pᵢⱼ = ⟨vᵢ, ..., vⱼ⟩</code>도 <strong>반드시 최단경로</strong>이다.</p>\n<blockquote>\n<p>💡 왜 그럴까?</p>\n<p>만약 부분경로보다 더 짧은 경로가 존재한다면, 그 경로를 원래 경로 중간에 끼워 넣어 전체 경로를 더 짧게 만들 수 있다. 이는 원래 경로가 최단경로라는 가정에 모순이다.</p>\n<p>이 성질은 <strong>최단경로 알고리즘의 correctness 증명에서 핵심 개념</strong>이다.</p>\n</blockquote>\n<h4 id=\"1-3-최단경로에-사이클이-없는-이유\">1-3 최단경로에 사이클이 없는 이유</h4>\n<p>최단경로에 사이클이 포함될 수 없는 이유는 다음과 같다.</p>\n<ul>\n<li><strong>음수 사이클</strong>: 최단경로가 정의되지 않음 (무한히 감소)</li>\n<li><strong>양수 사이클</strong>: 제거하면 경로가 더 짧아짐</li>\n<li><strong>0 사이클</strong>: 있어도 되고 없어도 되지만, 제거해도 길이가 같음</li>\n</ul>\n<p>따라서 최단경로는 <strong>simple path</strong>이며, 정점이 <code class=\"language-text\">n</code>개이면 최대 <code class=\"language-text\">n-1</code>개의 간선으로 구성된다.</p>\n<h4 id=\"1-4-음수-가중치-사이클\">1-4 음수 가중치 사이클</h4>\n<p>그래프에 <strong>negative-weight cycle</strong>이 있으면 사이클을 반복하여 가중치가 무한히 감소한다. 따라서 최단경로는 <strong>정의될 수 없다</strong>.</p>\n<p>모든 최단경로 알고리즘은 음수 사이클이 없는 경우에만 의미가 있다.</p>\n<hr>\n<h2 id=\"2️-relaxation의-개념\">2️⃣ Relaxation의 개념</h2>\n<h4 id=\"2-1-relaxation이란\">2-1 Relaxation이란?</h4>\n<p><strong>Relax(u, v)</strong> 는 다음을 의미한다.</p>\n<p>if v.d > u.d + w(u,v) then v.d = u.d + w(u,v)</p>\n<p>즉, \"<code class=\"language-text\">u</code>를 거쳐서 <code class=\"language-text\">v</code>로 가는 경로가 지금까지 알고 있던 것보다 더 짧다면 갱신하라\"는 의미다.</p>\n<p><strong>🔥 Update Rule</strong></p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">dist[v] = min(dist[v], dist[u] + w(u,v))</code></pre></div>\n<h4 id=\"2-2-relaxation의-성질\">2-2 Relaxation의 성질</h4>\n<p>Relax 후에는 항상 다음이 성립한다.</p>\n<p>v.d ≤ u.d + w(u,v)</p>\n<p>이는 Relax 과정이 <strong>절대 잘못된(과소) 값을 만들지 않는다</strong>는 뜻이다.</p>\n<h4 id=\"2-3-convergence-lemma-수렴-보장\">2-3 Convergence Lemma (수렴 보장)</h4>\n<p>최단경로가 <code class=\"language-text\">s → u → v</code>라고 하자. 만약 <code class=\"language-text\">u.d = δ(s,u)</code>가 이미 맞게 설정되어 있는 상태에서 간선 <code class=\"language-text\">(u,v)</code>를 relax하면, <code class=\"language-text\">v.d = δ(s,v)</code>가 된다.</p>\n<p>즉, <strong>최단경로의 앞부분이 완성되면 다음 정점도 즉시 최단값으로 수렴</strong>한다.</p>\n<h4 id=\"2-4-path-relaxation-property\">2-4 Path Relaxation Property</h4>\n<p>최단경로 <code class=\"language-text\">s = v₀ → v₁ → ⋯ → vₖ</code>의 간선들을 순서대로 relax하면 마지막 <code class=\"language-text\">vₖ</code>의 값은 반드시 <code class=\"language-text\">vₖ.d = δ(s,vₖ)</code>를 만족한다.</p>\n<p>이 성질 때문에 Bellman-Ford는 모든 간선을 여러 번 반복해서 relax할 필요 없이 <strong><code class=\"language-text\">|V|-1</code>번만 반복하면 충분</strong>하다.</p>\n<hr>\n<h2 id=\"3️-bellman-ford-알고리즘\">3️⃣ Bellman-Ford 알고리즘</h2>\n<h3 id=\"목적\">목적</h3>\n<ul>\n<li>음수 edge가 있어도 동작</li>\n<li>음수 cycle만 없으면 shortest path 존재</li>\n<li>모든 edge를 총 <code class=\"language-text\">|V|-1</code>번 relax하면 정답 도달</li>\n</ul>\n<h4 id=\"3-1-알고리즘-구조\">3-1 알고리즘 구조</h4>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">Initialize-Single-Source(G, s)\n\nfor i = 1 to |V|-1:\n    for 모든 간선 (u, v) ∈ E:\n        RELAX(u, v)\n\nfor 모든 간선 (u, v):\n    if v.d > u.d + w(u,v):\n        return FALSE   // 음수 사이클 존재\n\nreturn TRUE            // 최단경로 성공적 계산</code></pre></div>\n<p><strong>🔥 알고리즘 흐름</strong></p>\n<ol>\n<li>초기에 모든 정점까지의 거리를 <code class=\"language-text\">∞</code>로 설정하고, 출발점 <code class=\"language-text\">s</code>는 <code class=\"language-text\">0</code>으로 둔다</li>\n<li>모든 간선을 대상으로 <code class=\"language-text\">d[v] > d[u] + w(u, v)</code>를 만족하면 <code class=\"language-text\">d[v]</code>를 갱신한다</li>\n<li>이 과정을 총 <code class=\"language-text\">n-1</code>번 반복하면 모든 최단경로가 안정된다</li>\n<li>마지막으로 모든 간선을 다시 검사했을 때 유효한 Relaxation이 또 가능하다면 음수 사이클이 존재한다</li>\n</ol>\n<h4 id=\"3-2-정확성-correctness\">3-2 정확성 (Correctness)</h4>\n<p><strong>🔥 왜 정답이 되는가?</strong></p>\n<ol>\n<li>최단경로는 simple path이므로 최대 <code class=\"language-text\">|V|-1</code>개의 간선만 사용</li>\n<li>Relaxation은 절대 오류값을 만들지 않는다</li>\n<li>Convergence Lemma + Path Relaxation Property에 의해 최단경로가 반드시 <code class=\"language-text\">|V|-1</code>번 반복 중에 완성</li>\n<li>따라서 알고리즘이 끝나면 <code class=\"language-text\">v.d = δ(s,v)</code>이 보장된다</li>\n</ol>\n<h4 id=\"3-3-음수-사이클-검출\">3-3 음수 사이클 검출</h4>\n<p>마지막에 한 번 더 검사했을 때 아직도 <code class=\"language-text\">v.d > u.d + w(u,v)</code>인 경우가 있다면 <strong>음수 사이클이 존재</strong>한다.</p>\n<h4 id=\"3-4-시간복잡도\">3-4 시간복잡도</h4>\n<ul>\n<li>Relax 단계: 모든 간선을 <code class=\"language-text\">|V|-1</code>번 검사</li>\n<li>음수 사이클 검출: 모든 간선을 1번 검사</li>\n</ul>\n<p><strong>전체 복잡도: <code class=\"language-text\">O(VE)</code></strong></p>\n<p>Sparse graph에서는 <code class=\"language-text\">O(nm)</code>, dense graph에서는 <code class=\"language-text\">O(n³)</code>에 가깝다.</p>\n<h4 id=\"3-5-동작-예시\">3-5 동작 예시</h4>\n<p>그래프에 8개의 정점이 있다면 최단경로는 최대 7개의 간선을 포함하므로 Relaxation을 7번 반복한다.</p>\n<ul>\n<li>초기: 모든 <code class=\"language-text\">dist</code> 값이 <code class=\"language-text\">∞</code></li>\n<li>1회 반복 후: 출발점에서 한 간선으로 도달할 수 있는 정점들의 <code class=\"language-text\">dist</code> 갱신</li>\n<li>2회 반복 후: <code class=\"language-text\">dist</code>가 다시 갱신</li>\n<li>7회 반복 후: 모든 최단경로 결정</li>\n</ul>\n<p><strong>음수 간선이 있어도 잘 동작</strong>하지만, 음수 사이클이 존재하면 알고리즘은 <code class=\"language-text\">false</code>로 종료한다.</p>\n<hr>\n<h2 id=\"4️-dijkstra-알고리즘\">4️⃣ Dijkstra 알고리즘</h2>\n<h3 id=\"목적-1\">목적</h3>\n<ul>\n<li>음수 간선이 없을 때 Bellman-Ford보다 훨씬 빠른 알고리즘</li>\n<li>매 단계에서 <strong>현재까지 <code class=\"language-text\">dist</code> 값이 가장 작은 정점을 '확정'</strong></li>\n<li>BFS는 Dijkstra의 \"모든 간선 가중치가 1인 특수 케이스\"</li>\n</ul>\n<h4 id=\"4-1-알고리즘-구조\">4-1 알고리즘 구조</h4>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">Initialize-Single-Source(G, s)\n\n모든 정점을 min-heap에 넣는다\n\nwhile heap이 비어있지 않음:\n    u = EXTRACT-MIN(heap)\n\n    for u와 인접한 정점 v:\n        if v.d > u.d + w(u,v):\n            v.d = u.d + w(u,v)\n            DECREASE-KEY(heap, v)</code></pre></div>\n<p><strong>🔥 알고리즘 흐름</strong></p>\n<ol>\n<li>모든 <code class=\"language-text\">dist</code> 값을 <code class=\"language-text\">∞</code>로 두고, <code class=\"language-text\">s.dist = 0</code></li>\n<li>모든 정점을 min-heap에 넣는다</li>\n<li>heap에서 <code class=\"language-text\">dist</code>가 가장 작은 정점 <code class=\"language-text\">u</code>를 꺼내면 → <code class=\"language-text\">u</code>의 최단거리는 확정된다</li>\n<li><code class=\"language-text\">u</code>와 인접한 정점 <code class=\"language-text\">v</code>들에 대하여 <code class=\"language-text\">d[v] > d[u] + w(u,v)</code>이면 갱신하고, heap에서 decrease-key를 수행한다</li>\n<li>heap이 빌 때까지 반복한다</li>\n</ol>\n<h4 id=\"4-2-bellman-ford와의-차이\">4-2 Bellman-Ford와의 차이</h4>\n<ul>\n<li><strong>Bellman-Ford</strong>: 그래프 전체의 모든 간선을 매 반복마다 검사</li>\n<li><strong>Dijkstra</strong>: 추출된 정점 <code class=\"language-text\">u</code>의 인접 간선만 검사</li>\n</ul>\n<p>음수 간선이 없다면, <code class=\"language-text\">u</code>에서 다른 간선을 하나 더 지나면 거리가 늘어나므로 <code class=\"language-text\">u</code>는 확정할 수 있다.</p>\n<blockquote>\n<p>💡 핵심 아이디어</p>\n<p>Dijkstra는 <code class=\"language-text\">dist</code>가 작은 순서대로 정점을 확정하는데, 이 순서가 곧 **'출발점에서의 거리 증가 순서'**이다.</p>\n<p>따라서 Extract-Min되는 순간, 그 정점의 최단거리는 확정된다.</p>\n</blockquote>\n<h4 id=\"4-3-동작-예시\">4-3 동작 예시</h4>\n<p>예시 그래프에서 <code class=\"language-text\">A</code>를 source라고 하자.</p>\n<p><strong>초기 heap</strong></p>\n<ul>\n<li><code class=\"language-text\">A</code>는 <code class=\"language-text\">0</code></li>\n<li>다른 정점들은 <code class=\"language-text\">∞</code></li>\n</ul>\n<p><strong>Step 1</strong></p>\n<ul>\n<li>heap에서 <code class=\"language-text\">A</code>가 extract-min</li>\n<li><code class=\"language-text\">A</code>와 인접한 <code class=\"language-text\">B</code>와 <code class=\"language-text\">C</code>의 거리를 각각 <code class=\"language-text\">3</code>, <code class=\"language-text\">1</code>로 갱신</li>\n</ul>\n<p><strong>Step 2</strong></p>\n<ul>\n<li>heap에서 <code class=\"language-text\">C</code>가 다음으로 가장 작으므로 extract-min</li>\n<li><code class=\"language-text\">C</code>의 이웃들에 대해 Relaxation 수행</li>\n<li><code class=\"language-text\">B</code>의 거리가 기존 <code class=\"language-text\">3</code>에서 <code class=\"language-text\">C(1)+1=2</code>로 갱신</li>\n</ul>\n<p><strong>반복</strong></p>\n<ul>\n<li>각 단계에서 \"가장 가까운 정점\"을 확정해 나간다</li>\n</ul>\n<h4 id=\"4-4-시간복잡도\">4-4 시간복잡도</h4>\n<ul>\n<li>초기화: <code class=\"language-text\">O(n)</code></li>\n<li>Extract-Min: <code class=\"language-text\">n</code>번, 각 <code class=\"language-text\">O(log n)</code></li>\n<li>Decrease-Key: edge마다 최대 한 번, <code class=\"language-text\">O(E log n)</code></li>\n</ul>\n<p><strong>전체 복잡도: <code class=\"language-text\">O(E log n)</code></strong></p>\n<p>Bellman-Ford의 <code class=\"language-text\">O(VE)</code>와 비교하면 훨씬 빠르다.</p>\n<h4 id=\"4-5-음수-간선이-있을-때-실패하는-이유\">4-5 음수 간선이 있을 때 실패하는 이유</h4>\n<p><strong>🔥 문제 상황</strong></p>\n<ol>\n<li>어떤 정점 <code class=\"language-text\">D</code>가 초기에 <code class=\"language-text\">dist = 1</code>로 확정됨</li>\n<li>이후 <code class=\"language-text\">C</code>에서 <code class=\"language-text\">D</code>로 음수 간선을 따라가면 <code class=\"language-text\">D</code>의 거리가 더 줄어들어야 함</li>\n<li>하지만 <code class=\"language-text\">D</code>는 이미 한 번 확정되어 heap에서 제거된 상태 → 더 갱신할 수 없음</li>\n<li>따라서 <strong>잘못된 최단거리</strong>가 출력됨</li>\n</ol>\n<blockquote>\n<p>💡 핵심 문제</p>\n<p>\"Extract-Min 시점에 그 정점의 최단거리가 확정된다고 가정하는데, 음수 간선이 존재하면 이 가정이 깨진다.\"</p>\n<p>이미 확정한 정점도 나중에 더 짧아질 수 있어 알고리즘 논리가 무너진다.</p>\n</blockquote>\n<hr>\n<h2 id=\"5️-알고리즘-비교-및-공통점\">5️⃣ 알고리즘 비교 및 공통점</h2>\n<h4 id=\"5-1-bellman-ford-vs-dijkstra\">5-1 Bellman-Ford vs Dijkstra</h4>\n<table>\n<thead>\n<tr>\n<th>알고리즘</th>\n<th>음수 간선</th>\n<th>시간복잡도</th>\n<th>동작 방식</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>Bellman-Ford</td>\n<td>허용 (음수 사이클은 불가)</td>\n<td><code class=\"language-text\">O(VE)</code></td>\n<td>모든 간선을 반복적으로 완화</td>\n</tr>\n<tr>\n<td>Dijkstra</td>\n<td>불가</td>\n<td><code class=\"language-text\">O(E log n)</code></td>\n<td>최소 힙으로 가장 가까운 정점부터 확장</td>\n</tr>\n</tbody>\n</table>\n<h4 id=\"5-2-greedy-확장-패턴의-공통점\">5-2 Greedy 확장 패턴의 공통점</h4>\n<p>Dijkstra, BFS, Prim은 <strong>모두 \"지금까지 가장 가까운 정점부터 확장한다\"는 공통된 틀</strong>을 가진다.</p>\n<table>\n<thead>\n<tr>\n<th>알고리즘</th>\n<th>공통점</th>\n<th>차이</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>BFS</td>\n<td>큐 사용, 간선 가중치 없음</td>\n<td>모든 간선의 weight=1</td>\n</tr>\n<tr>\n<td>Dijkstra</td>\n<td>최소 힙 사용</td>\n<td>음수 간선 불가</td>\n</tr>\n<tr>\n<td>Prim</td>\n<td>최소 힙 사용</td>\n<td>MST 만드는 알고리즘 (경로 아님)</td>\n</tr>\n<tr>\n<td>Bellman-Ford</td>\n<td>모든 간선을 반복적으로 완화</td>\n<td>음수 허용, 느림</td>\n</tr>\n</tbody>\n</table>\n<p><strong>🔥 핵심</strong></p>\n<p>Dijkstra, BFS, Prim은 모두 <strong>Greedy한 확장</strong> 패턴을 공유하는 알고리즘이다.</p>","fields":{"slug":"/알고리즘설계와분석 - 최단경로/"},"frontmatter":{"title":"알고리즘설계와분석 - 최단경로 (Shortest Path)","date":"2025-12-13","description":"Bellman-Ford와 Dijkstra 알고리즘으로 그래프의 최단경로를 찾는 방법을 알아보자.","pointColor":"#ffffff","tags":["알고리즘"],"keywords":"알고리즘, 최단경로, Shortest Path, Dijkstra, 다익스트라, Bellman-Ford, 벨만-포드, 그래프, Graph, 동적 계획법","thumbnail":{"publicURL":"/static/e104bdbadb9b5966e8c5831cc52bcb23/index.png","childImageSharp":{"gatsbyImageData":{"layout":"fixed","placeholder":{"fallback":"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAKCAIAAAA7N+mxAAAACXBIWXMAAAsTAAALEwEAmpwYAAABWklEQVR42nWRbU/CMBCA9///B8bwwRijUfADESFBIYiJkbc5zGAdG6zrurZ737xuZowYL5fL9XbP7k0piiJMYtDiHwmjyOeMCV6rfJYRBT5P0GaMNHCyPM8yMHlNJklSkyXjg60jCqSepZ+LCAJIpcxnUUh0HQ2GQRxJsq4cCEFcl1LqEaKp6nq5YoxBPM1SIOMomuqLzvwFWebmWzOwXXUBKuG5pj489YajUf911L67aV9fGSaqe+aBsIizQN8rc/t1QK1JlwBY8hL+NPXWuHc5fe6rH535W2c5M6kL8ThJqtl2R0s/7C8mXcOxMfVOM8vK6+Xt473jYrmzcmHVEtI0DcNwhy2oZhztA8E2wep+i7AdlLtQymOE4AEGfv6L5pUPPXvMP3qYcuZQF2x/PRuo72mc0ApuSt4QeEaxPDIXgnEOFv4F6nN+avsv3/SFzJZD+oI1j8wE/wHoujXuT6y+VgAAAABJRU5ErkJggg=="},"backgroundColor":"transparent","images":{"fallback":{"src":"/static/e104bdbadb9b5966e8c5831cc52bcb23/e05b2/index.png","srcSet":"/static/e104bdbadb9b5966e8c5831cc52bcb23/e05b2/index.png 1000w","sizes":"1000px"},"sources":[{"srcSet":"/static/e104bdbadb9b5966e8c5831cc52bcb23/0b921/index.webp 1000w","type":"image/webp","sizes":"1000px"}]},"width":1200,"height":600},"fixed":{"src":"/static/e104bdbadb9b5966e8c5831cc52bcb23/31987/index.png"}}}}},"previous":{"fields":{"slug":"/알고리즘설계와분석 - MST (최소신장트리)/"},"frontmatter":{"title":"알고리즘설계와분석 - MST (최소신장트리)"}},"next":{"fields":{"slug":"/알고리즘설계와분석 - Maximum flow /"},"frontmatter":{"title":"알고리즘설계와분석 - 최대 유량 문제 (Maximum Flow)"}}},"pageContext":{"id":"862d5cce-cb2f-5732-8349-674ab52ba6ce","previousPostId":"379638ca-6010-5943-a05f-cd0b03b9e41e","nextPostId":"90093886-802c-5ef9-afe0-6f50da5ece82"}},"staticQueryHashes":["736397157"],"slicesMap":{}}