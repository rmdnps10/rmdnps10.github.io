{"componentChunkName":"component---src-templates-blog-post-js","path":"/os-process-thread/","result":{"data":{"site":{"siteMetadata":{"title":"홈","siteUrl":"https://inyoung.dev","author":{"name":"Inyoung Chung"}}},"allMarkdownRemark":{"nodes":[{"fields":{"slug":"/[트러블슈팅] Supabase를 활용한 인증, 인가/"},"frontmatter":{"title":"[트러블슈팅] Supabase Auth를 활용한 다양한 환경에서의 세션 유지","date":"2026-02-10","tags":["Web","회고"],"pointColor":"#3ECF8D"}},{"fields":{"slug":"/waterfall-agile/"},"frontmatter":{"title":"[소프트웨어공학] Waterfall과 Agile","date":"2026-02-03","tags":["소프트웨어공학"],"pointColor":"#ffffff"}},{"fields":{"slug":"/os-file-system/"},"frontmatter":{"title":"[운영체제] 파일 시스템","date":"2026-01-27","tags":["운영체제"],"pointColor":"#ffffff"}},{"fields":{"slug":"/os-virtual-memory/"},"frontmatter":{"title":"[운영체제] 5. 가상 메모리","date":"2026-01-26","tags":["운영체제"],"pointColor":"#ffffff"}},{"fields":{"slug":"/os-cpu-scheduling/"},"frontmatter":{"title":"[운영체제] 4. CPU 스케줄링","date":"2026-01-25","tags":["운영체제"],"pointColor":"#ffffff"}},{"fields":{"slug":"/os-synchronization-deadlock/"},"frontmatter":{"title":"[운영체제] 3. 동기화와 교착 상태","date":"2026-01-24","tags":["운영체제"],"pointColor":"#ffffff"}},{"fields":{"slug":"/os-process-thread/"},"frontmatter":{"title":"[운영체제] 2. 프로세스와 스레드","date":"2026-01-23","tags":["운영체제"],"pointColor":"#ffffff"}},{"fields":{"slug":"/os-big-picture/"},"frontmatter":{"title":"[운영체제] 1. 운영체제의 큰 그림","date":"2026-01-21","tags":["운영체제"],"pointColor":"#ffffff"}},{"fields":{"slug":"/computer-architecture-cpu/"},"frontmatter":{"title":"[컴퓨터구조] 3. CPU","date":"2026-01-18","tags":["컴퓨터구조"],"pointColor":"#ffffff"}},{"fields":{"slug":"/computer-architecture-computer-information/"},"frontmatter":{"title":"[컴퓨터구조] 2. 컴퓨터가 이해하는 정보","date":"2026-01-17","tags":["컴퓨터구조"],"pointColor":"#ffffff"}},{"fields":{"slug":"/computer-architecture-big-picture/"},"frontmatter":{"title":"[컴퓨터구조] 1. 컴퓨터구조의 큰 그림","date":"2026-01-15","tags":["컴퓨터구조"],"pointColor":"#ffffff"}},{"fields":{"slug":"/java-coding-test-grammer/"},"frontmatter":{"title":"Java 코딩테스트 문법 최종 정리","date":"2026-01-08","tags":["알고리즘"],"pointColor":"#ed8b00"}},{"fields":{"slug":"/lg-webos-tv-fullstack-appliaction/"},"frontmatter":{"title":"WebOS TV에 들어갈 풀스택 애플리케이션을 만들어보자 (LG전자 산학 프로젝트 후기)","date":"2025-12-22","tags":["회고"],"pointColor":"#ffffff"}},{"fields":{"slug":"/algorithm-maximum-flow/"},"frontmatter":{"title":"알고리즘설계와분석 - 최대 유량 문제 (Maximum Flow)","date":"2025-12-16","tags":["알고리즘"],"pointColor":"#ffffff"}},{"fields":{"slug":"/algorithm-shortest-path/"},"frontmatter":{"title":"알고리즘설계와분석 - 최단경로 (Shortest Path)","date":"2025-12-13","tags":["알고리즘"],"pointColor":"#ffffff"}},{"fields":{"slug":"/algorithm-minimum-spanning-tree/"},"frontmatter":{"title":"알고리즘설계와분석 - MST (최소신장트리)","date":"2025-12-12","tags":["알고리즘"],"pointColor":"#ffffff"}},{"fields":{"slug":"/algorithm-bfs-dfs/"},"frontmatter":{"title":"알고리즘설계와분석 - BFS/DFS와 Topological Sort","date":"2025-12-11","tags":["알고리즘"],"pointColor":"#ffffff"}},{"fields":{"slug":"/algorithm-greedy-algorithm/"},"frontmatter":{"title":"알고리즘설계와분석 - Greedy algorithm (그리디 알고리즘)","date":"2025-12-10","tags":["알고리즘"],"pointColor":"#ffffff"}},{"fields":{"slug":"/algorithm-dynamic-programming/"},"frontmatter":{"title":"알고리즘설계와분석 - Dynamic Programming (동적 계획법)","date":"2025-12-07","tags":["알고리즘"],"pointColor":"#ffffff"}},{"fields":{"slug":"/algorithm-binary-search-tree/"},"frontmatter":{"title":"알고리즘설계와분석 - Binary Search Tree (이진 탐색 트리)","date":"2025-12-05","tags":["알고리즘"],"pointColor":"#ffffff"}},{"fields":{"slug":"/database-system-erd/"},"frontmatter":{"title":"데이터베이스 시스템 개론 📚 - Chapter2. ERD로 데이터베이스 설계하기","date":"2025-10-05","tags":["DB"],"pointColor":"#ffffff"}},{"fields":{"slug":"/make-huggingface-pipeline/"},"frontmatter":{"title":"허깅페이스로 파이프라인을 만들어보자 - 트랜스포머 모델 활용 가이드","date":"2025-10-04","tags":["AI"],"pointColor":"#FF9A00"}},{"fields":{"slug":"/rag-core-concept/"},"frontmatter":{"title":"RAG의 핵심 개념과 실습","date":"2025-10-01","tags":["AI"],"pointColor":"#FF6B6B"}},{"fields":{"slug":"/prompt-engineering-basic/"},"frontmatter":{"title":"프롬프트 엔지니어링 기초 - AI와 효과적으로 소통하는 방법","date":"2025-09-28","tags":["AI"],"pointColor":"#ffffff"}},{"fields":{"slug":"/how-to-use-flutter-riverpod/"},"frontmatter":{"title":"초심자 입장에서 Flutter Riverpod을 '잘' 사용하는 방법 (장문)","date":"2025-09-20","tags":["Flutter"],"pointColor":"#0468d7"}},{"fields":{"slug":"/database-system-introduction/"},"frontmatter":{"title":"데이터베이스 시스템 개론 📚 – Chapter 1. Introduction of Database Systems","date":"2025-09-16","tags":["DB"],"pointColor":"#ffffff"}},{"fields":{"slug":"/kakaobank-devrel-internship-retrospect/"},"frontmatter":{"title":"서비스 개발부터 DevRel까지: 카카오뱅크 인턴쉽 회고","date":"2025-07-28","tags":["인턴","회고","카카오뱅크","네이버랩스"],"pointColor":"#ffe300"}},{"fields":{"slug":"/my-it-startup-internship-retrospect/"},"frontmatter":{"title":"나의 IT 스타트업 인턴쉽 회고","date":"2025-03-14","tags":["인턴","회고"],"pointColor":"#6FE7FF"}},{"fields":{"slug":"/sogang-likelion-management-retrospect/"},"frontmatter":{"title":"서강대학교 멋쟁이사자처럼 운영진 회고","date":"2025-02-27","tags":["멋쟁이사자처럼","회고"],"pointColor":"#FD7911"}}]},"markdownRemark":{"id":"b2e55fd0-c415-5a88-86fc-e60c3c4f5ce5","excerpt":"프로세스는 실행 중인 프로그램을 의미하며, 스레드는 프로세스 내에서 실행되는 작업 단위다. 이 글에서는 프로세스와 스레드의 개념, 메모리 구조, 그리고 프로세스 간 통신 방법을 다룬다.…","html":"<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 1000px; background: transparent;\"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/static/3a18a98e16471cfd320f4cce5ad16a0c/7c474/index.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 48.800000000000004%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAKCAYAAAC0VX7mAAAACXBIWXMAACE4AAAhOAFFljFgAAABZUlEQVR42o1SS0sCYRSdGf9BEC0M3ASJECZYCUUto9rWL2hd+dZs00MTTcYZHR9ImhEtItq1KNr02NaiNgX+mNP9rpqTjOjicL77cefcc898krQfRT9kgpKIQSYIVg7ivXPn3uo7huVlNAQpuAcp5O9xF6KOBEcTFM6kWAiT6RTWLurwlQ2sN+tYqVX5vFyrYLVxDqea46GWTs2FTTSQg83rKzy1Wkg8PuD+5xvq2yuaH+/Ivjzj5usT23e33GcbJqgIpnU8BQ1bJOrWVBZfIHfCmcDGZQNeQ+c+ZaSVO6Kcl+DATjs3P3Fgl1kOByDHI4MdtrMLYyJ1jLGTQ0yrZ5zbYqWEpWoZrnwO86UC3HoedsrXaxQ4Y0fmtGfCStCeTmI8eYSpXBa+igFPUaP1dRacpRicNMiRSWNGVzFXKsJFP0fpd/mvoDX+mAYwxNrdWjynznA+d/uHvUPZlKf5acgDesz4BSBgnUZF2F39AAAAAElFTkSuQmCC'); background-size: cover; display: block;\"\n  ></span>\n  <picture>\n          <source\n              srcset=\"/static/3a18a98e16471cfd320f4cce5ad16a0c/bc904/index.webp 250w,\n/static/3a18a98e16471cfd320f4cce5ad16a0c/4be29/index.webp 500w,\n/static/3a18a98e16471cfd320f4cce5ad16a0c/03f31/index.webp 1000w,\n/static/3a18a98e16471cfd320f4cce5ad16a0c/84f56/index.webp 1329w\"\n              sizes=\"(max-width: 1000px) 100vw, 1000px\"\n              type=\"image/webp\"\n            />\n          <source\n            srcset=\"/static/3a18a98e16471cfd320f4cce5ad16a0c/43fa5/index.png 250w,\n/static/3a18a98e16471cfd320f4cce5ad16a0c/c6e3d/index.png 500w,\n/static/3a18a98e16471cfd320f4cce5ad16a0c/da8b6/index.png 1000w,\n/static/3a18a98e16471cfd320f4cce5ad16a0c/7c474/index.png 1329w\"\n            sizes=\"(max-width: 1000px) 100vw, 1000px\"\n            type=\"image/png\"\n          />\n          <img\n            class=\"gatsby-resp-image-image\"\n            src=\"/static/3a18a98e16471cfd320f4cce5ad16a0c/da8b6/index.png\"\n            alt=\"index\"\n            title=\"\"\n            loading=\"lazy\"\n            decoding=\"async\"\n            style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n          />\n        </picture>\n  </a>\n    </span></p>\n<blockquote>\n<p>프로세스는 실행 중인 프로그램을 의미하며, 스레드는 프로세스 내에서 실행되는 작업 단위다. 이 글에서는 프로세스와 스레드의 개념, 메모리 구조, 그리고 프로세스 간 통신 방법을 다룬다.</p>\n</blockquote>\n<h2 id=\"1️-프로세스의-종류\">1️⃣ 프로세스의 종류</h2>\n<p>메모리에는 컴퓨터가 실행되는 순간부터 다양한 프로세스가 적재된다. 프로세스는 실행 방식에 따라 다음과 같이 분류된다.</p>\n<ol>\n<li>\n<p><strong>포그라운드 프로세스</strong>: 사용자가 보는 공간에서 사용자와 상호작용하며 실행되는 프로세스다.</p>\n</li>\n<li>\n<p><strong>백그라운드 프로세스</strong>: 사용자가 보지 못하는 곳에서 실행되는 프로세스다.</p>\n</li>\n<li>\n<p><strong>데몬(Daemon) / 서비스(Service)</strong> : 사용자와 별다른 상호작용 없이 주어진 작업만 수행하는 특별한 백그라운드 프로세스다. Windows에서는 <code class=\"language-text\">서비스</code>라고 부른다.</p>\n</li>\n</ol>\n<p>프로세스의 유형과 관계없이 하나의 프로세스를 구성하는 메모리 내의 정보는 크게 다르지 않다:</p>\n<ul>\n<li><strong>커널 영역</strong>: <code class=\"language-text\">PCB(Process Control Block)</code> 저장</li>\n<li><strong>사용자 영역</strong>: 코드 영역, 데이터 영역, 힙 영역, 스택 영역으로 구성</li>\n</ul>\n<h2 id=\"2️-프로세스의-메모리-구조\">2️⃣ 프로세스의 메모리 구조</h2>\n<h3 id=\"코드-영역-code-segment\">코드 영역 (Code Segment)</h3>\n<p><code class=\"language-text\">코드 영역</code>은 실행 가능한 명령어가 저장되는 공간으로, <code class=\"language-text\">텍스트 영역(Text Segment)</code>이라고도 한다.</p>\n<ul>\n<li>CPU가 읽고 실행할 명령어를 포함</li>\n<li><strong>읽기 전용(Read-only)</strong> 공간으로 쓰기가 금지됨</li>\n</ul>\n<h3 id=\"데이터-영역-data-segment\">데이터 영역 (Data Segment)</h3>\n<p><code class=\"language-text\">데이터 영역</code>은 프로그램이 실행되는 동안 유지할 데이터가 저장되는 공간이다.</p>\n<ul>\n<li>정적 변수(Static Variable)</li>\n<li>전역 변수(Global Variable)</li>\n</ul>\n<blockquote>\n<p>💡 <strong>BSS 영역</strong></p>\n<p>데이터 영역은 초기화 여부에 따라 세부적으로 나뉜다:</p>\n<ul>\n<li><strong>데이터 영역</strong>: 초깃값이 있는 정적/전역 변수 저장</li>\n<li><strong>BSS 영역</strong>: 초깃값이 없는 정적/전역 변수 저장</li>\n</ul>\n</blockquote>\n<p>코드 영역과 데이터 영역은 프로그램 실행 도중 <strong>크기가 변하지 않기 때문에</strong> <code class=\"language-text\">정적 할당 영역</code>이라고 한다.</p>\n<h3 id=\"힙-영역-heap-segment\">힙 영역 (Heap Segment)</h3>\n<p><code class=\"language-text\">힙 영역</code>은 프로그래머가 직접 할당 가능한 저장 공간이다.</p>\n<p><strong>🎯 특징</strong></p>\n<ul>\n<li>프로그램 실행 도중 비교적 자유롭게 할당하여 사용 가능</li>\n<li>할당한 메모리 공간은 반드시 해제해야 함</li>\n<li>메모리를 해제하지 않으면 <code class=\"language-text\">메모리 누수(Memory Leak)</code> 발생</li>\n</ul>\n<p><strong>🗑️ 가비지 컬렉션(Garbage Collection)</strong></p>\n<p>일부 프로그래밍 언어는 사용되지 않는 힙 메모리를 자동으로 해제하는 가비지 컬렉션 기능을 제공한다.</p>\n<h3 id=\"스택-영역-stack-segment\">스택 영역 (Stack Segment)</h3>\n<p><code class=\"language-text\">스택 영역</code>은 일시적으로 사용할 값들이 저장되는 공간이다.</p>\n<ul>\n<li>매개변수(Parameter)</li>\n<li>지역 변수(Local Variable)</li>\n<li>함수 복귀 주소(Return Address)</li>\n</ul>\n<h4 id=\"스택-트레이스-stack-trace\">스택 트레이스 (Stack Trace)</h4>\n<p><code class=\"language-text\">스택 트레이스</code>는 특정 시점에 스택 영역에 저장된 함수 호출 정보를 말한다. 문제의 발생 지점을 추적할 수 있어 디버깅에 매우 유용하다.</p>\n<p><strong>자바 스택 트레이스 예시</strong></p>\n<div class=\"gatsby-highlight\" data-language=\"java\"><pre class=\"language-java\"><code class=\"language-java\"><span class=\"token class-name\">Exception</span> in thread <span class=\"token string\">\"main\"</span> <span class=\"token class-name\"><span class=\"token namespace\">java<span class=\"token punctuation\">.</span>lang<span class=\"token punctuation\">.</span></span>NullPointerException</span>\n    at <span class=\"token class-name\"><span class=\"token namespace\">com<span class=\"token punctuation\">.</span>example<span class=\"token punctuation\">.</span>myproject<span class=\"token punctuation\">.</span></span>Test</span><span class=\"token punctuation\">.</span><span class=\"token function\">getThis</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">Test</span><span class=\"token punctuation\">.</span>java<span class=\"token operator\">:</span><span class=\"token number\">16</span><span class=\"token punctuation\">)</span>\n    at <span class=\"token class-name\"><span class=\"token namespace\">com<span class=\"token punctuation\">.</span>example<span class=\"token punctuation\">.</span>myproject<span class=\"token punctuation\">.</span></span>Test2</span><span class=\"token punctuation\">.</span><span class=\"token function\">getThat</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">Test2</span><span class=\"token punctuation\">.</span>java<span class=\"token operator\">:</span><span class=\"token number\">25</span><span class=\"token punctuation\">)</span>\n    at <span class=\"token class-name\"><span class=\"token namespace\">com<span class=\"token punctuation\">.</span>example<span class=\"token punctuation\">.</span>myproject<span class=\"token punctuation\">.</span></span>Bootstrap</span><span class=\"token punctuation\">.</span><span class=\"token function\">main</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">Bootstrap</span><span class=\"token punctuation\">.</span>java<span class=\"token operator\">:</span><span class=\"token number\">14</span><span class=\"token punctuation\">)</span></code></pre></div>\n<p>힙 영역과 스택 영역은 <strong>크기가 변할 수 있기 때문에</strong> <code class=\"language-text\">동적 할당 영역</code>이라고 한다.</p>\n<h2 id=\"3️-pcb와-문맥-교환\">3️⃣ PCB와 문맥 교환</h2>\n<h3 id=\"pcb-process-control-block\">PCB (Process Control Block)</h3>\n<p>운영체제가 메모리에 적재된 다수의 프로세스를 관리하려면 프로세스를 식별할 수 있는 정보가 필요하다. 이 정보가 바로 <code class=\"language-text\">PCB</code>다.</p>\n<p><strong>🔑 PCB의 특징</strong></p>\n<ul>\n<li>프로세스와 관련한 다양한 정보를 담는 구조체</li>\n<li>새로운 프로세스가 생성될 때 커널 영역에 만들어짐</li>\n<li>프로세스 실행이 끝나면 폐기됨</li>\n</ul>\n<h4 id=\"3-1-pcb에-담기는-정보\">3-1 PCB에 담기는 정보</h4>\n<table>\n<thead>\n<tr>\n<th>정보 종류</th>\n<th>설명</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>PID (Process ID)</td>\n<td>프로세스 식별 번호</td>\n</tr>\n<tr>\n<td>레지스터 값</td>\n<td>프로세스가 실행 과정에서 사용한 레지스터 값</td>\n</tr>\n<tr>\n<td>프로세스 상태</td>\n<td>현재 프로세스의 상태 (생성, 준비, 실행, 대기, 종료)</td>\n</tr>\n<tr>\n<td>CPU 스케줄링 정보</td>\n<td>프로세스의 우선순위, 스케줄링 큐 포인터 등</td>\n</tr>\n<tr>\n<td>메모리 관련 정보</td>\n<td>프로세스의 메모리상 적재 위치</td>\n</tr>\n<tr>\n<td>파일 및 I/O 정보</td>\n<td>프로세스가 사용한 파일 및 입출력장치 관련 정보</td>\n</tr>\n</tbody>\n</table>\n<h4 id=\"3-2-리눅스의-pcb-구조\">3-2 리눅스의 PCB 구조</h4>\n<p>리눅스 운영체제의 PCB는 <code class=\"language-text\">task_struct</code>라는 구조체로 구현된다:</p>\n<div class=\"gatsby-highlight\" data-language=\"c\"><pre class=\"language-c\"><code class=\"language-c\"><span class=\"token comment\">// filepath: task_struct 구조체 예시</span>\n<span class=\"token keyword\">struct</span> <span class=\"token class-name\">task_struct</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token class-name\">pid_t</span> pid<span class=\"token punctuation\">;</span>                    <span class=\"token comment\">// PID</span>\n    <span class=\"token keyword\">int</span> prio<span class=\"token punctuation\">;</span>                     <span class=\"token comment\">// 스케줄링(우선순위) 관련 정보</span>\n    <span class=\"token keyword\">unsigned</span> <span class=\"token keyword\">int</span> state<span class=\"token punctuation\">;</span>           <span class=\"token comment\">// 프로세스 상태 관련 정보</span>\n    <span class=\"token keyword\">struct</span> <span class=\"token class-name\">mm_struct</span> <span class=\"token operator\">*</span>mm<span class=\"token punctuation\">;</span>         <span class=\"token comment\">// 메모리 관련 정보</span>\n    <span class=\"token keyword\">void</span> <span class=\"token operator\">*</span>stack<span class=\"token punctuation\">;</span>                  <span class=\"token comment\">// 스택 관련 정보</span>\n    <span class=\"token keyword\">struct</span> <span class=\"token class-name\">files_struct</span> <span class=\"token operator\">*</span>files<span class=\"token punctuation\">;</span>   <span class=\"token comment\">// 파일 관련 정보</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<blockquote>\n<p>💡 <strong>프로세스 테이블 (Process Table)</strong></p>\n<p>여러 PCB는 커널 내에서 <code class=\"language-text\">프로세스 테이블</code> 형태로 관리된다:</p>\n<ul>\n<li>새로운 프로세스 생성 시: PCB를 프로세스 테이블에 추가</li>\n<li>프로세스 종료 시: 자원 해제 후 PCB를 프로세스 테이블에서 삭제</li>\n</ul>\n<p><strong>좀비 프로세스(Zombie Process)</strong>: 프로세스가 비정상 종료되어 자원이 회수되었음에도 PCB가 프로세스 테이블에 남아 있는 상태</p>\n</blockquote>\n<blockquote>\n<p>💡 <strong>오픈 소스 운영체제, 리눅스</strong></p>\n<p><code class=\"language-text\">리눅스(Linux)</code>는 소스 코드가 공개된 오픈 소스 운영체제다:</p>\n<ul>\n<li>안드로이드 등 다양한 운영체제에 영향</li>\n<li>많은 서버 컴퓨터 환경에서 활용</li>\n<li>소스 코드 확인: <a href=\"https://kernel.org/\">https://kernel.org/</a></li>\n</ul>\n</blockquote>\n<h3 id=\"문맥-교환-context-switching\">문맥 교환 (Context Switching)</h3>\n<p>메모리에 적재된 프로세스는 한정된 시간 동안 번갈아 가며 실행된다. 이는 <strong>운영체제가 CPU 자원을 번갈아 가며 할당</strong>하기 때문이다.</p>\n<h4 id=\"3-3-타이머-인터럽트-timer-interrupt\">3-3 타이머 인터럽트 (Timer Interrupt)</h4>\n<p><code class=\"language-text\">타이머 인터럽트</code>는 프로세스의 CPU 사용 시간을 제한하는 인터럽트로, <code class=\"language-text\">타임아웃 인터럽트(Timeout Interrupt)</code>라고도 한다.</p>\n<ul>\n<li>프로세스는 정해진 시간만큼 CPU를 사용</li>\n<li>타이머 인터럽트 발생 시 다음 프로세스에게 CPU를 양보</li>\n</ul>\n<h4 id=\"3-4-문맥-context\">3-4 문맥 (Context)</h4>\n<p><code class=\"language-text\">문맥</code>은 프로세스의 수행을 재개하기 위해 기억해야 할 정보를 의미한다:</p>\n<ul>\n<li>프로그램 카운터를 비롯한 각종 레지스터 값</li>\n<li>메모리 정보</li>\n<li>실행을 위해 열었던 파일</li>\n<li>사용한 입출력장치 등</li>\n</ul>\n<p>프로세스의 문맥은 해당 프로세스의 <strong>PCB에 명시</strong>된다.</p>\n<h4 id=\"3-5-문맥-교환의-동작-과정\">3-5 문맥 교환의 동작 과정</h4>\n<p><code class=\"language-text\">문맥 교환</code>은 기존 프로세스의 문맥을 PCB에 백업하고, 새로운 프로세스의 문맥을 PCB에서 복구하여 실행하는 과정이다:</p>\n<ol>\n<li>프로세스 A 실행 중 타이머 인터럽트 발생</li>\n<li>프로세스 A의 문맥을 PCB에 백업</li>\n<li>프로세스 B의 문맥을 PCB에서 복구</li>\n<li>프로세스 B 실행</li>\n<li>타이머 인터럽트 발생 시 과정 반복</li>\n</ol>\n<p><strong>⚠️ 문맥 교환의 오버헤드</strong></p>\n<p>프로세스 간 너무 잦은 문맥 교환은 다음과 같은 문제를 발생시킨다:</p>\n<ul>\n<li>캐시 미스(Cache Miss) 발생 가능성 증가</li>\n<li>메모리로부터 프로세스 내용을 가져오는 작업 빈번</li>\n<li>큰 오버헤드로 이어질 수 있음</li>\n</ul>\n<h2 id=\"4️-프로세스의-상태\">4️⃣ 프로세스의 상태</h2>\n<p>하나의 프로세스는 여러 상태를 거치며 실행된다. 운영체제는 PCB를 통해 프로세스의 상태를 인식하고 관리한다.</p>\n<h3 id=\"프로세스-상태-다이어그램\">프로세스 상태 다이어그램</h3>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">[생성(new)] → [준비(ready)] → [실행(running)] → [종료(terminated)]\n                    ↑              ↓\n                    └──[대기(blocked)]</code></pre></div>\n<h4 id=\"4-1-생성-상태-new\">4-1 생성 상태 (New)</h4>\n<ul>\n<li>프로세스를 생성 중인 상태</li>\n<li>메모리에 적재되어 PCB를 할당받은 상태</li>\n<li>실행 준비가 완료되면 준비 상태로 전환</li>\n</ul>\n<h4 id=\"4-2-준비-상태-ready\">4-2 준비 상태 (Ready)</h4>\n<ul>\n<li>CPU를 할당받아 실행할 수 있지만 차례를 기다리는 상태</li>\n<li>CPU를 할당받으면 실행 상태로 전환</li>\n<li>준비 상태에서 실행 상태로 전환되는 것을 <code class=\"language-text\">디스패치(Dispatch)</code>라고 함</li>\n</ul>\n<h4 id=\"4-3-실행-상태-running\">4-3 실행 상태 (Running)</h4>\n<ul>\n<li>CPU를 할당받아 실행 중인 상태</li>\n<li>일정 시간 동안만 CPU를 사용할 수 있음</li>\n<li>타이머 인터럽트 발생 시 준비 상태로 전환</li>\n<li>입출력 작업 요청 시 대기 상태로 전환</li>\n</ul>\n<h4 id=\"4-4-대기-상태-blocked\">4-4 대기 상태 (Blocked)</h4>\n<ul>\n<li>입출력 작업을 요청하거나 바로 확보할 수 없는 자원을 요청하여 실행이 불가능한 상태</li>\n<li>입출력 작업이 완료되면 준비 상태로 전환</li>\n</ul>\n<h4 id=\"4-5-종료-상태-terminated\">4-5 종료 상태 (Terminated)</h4>\n<ul>\n<li>프로세스가 종료된 상태</li>\n<li>운영체제는 PCB와 프로세스가 사용한 메모리를 정리</li>\n</ul>\n<blockquote>\n<p>💡 <strong>블로킹 입출력 vs 논블로킹 입출력</strong></p>\n<p><strong>블로킹 입출력(Blocking I/O)</strong></p>\n<ul>\n<li>입출력 작업 완료까지 대기 상태로 접어드는 방식</li>\n<li>입출력 작업이 완료되면 준비 상태로 전환하여 실행 재개</li>\n</ul>\n<p><strong>논블로킹 입출력(Non-blocking I/O)</strong></p>\n<ul>\n<li>입출력 작업을 입출력장치에 맡긴 뒤 곧바로 다음 명령어 실행</li>\n<li>실행 결과를 기다리지 않음</li>\n</ul>\n<p>예를 들어, 네트워크를 통해 메시지를 보내는 시스템 콜 호출 시:</p>\n<ul>\n<li><strong>블로킹 I/O</strong>: 송신 작업 완료를 확인할 때까지 대기</li>\n<li><strong>논블로킹 I/O</strong>: 송신 작업을 맡기고 곧바로 다음 명령 수행</li>\n</ul>\n</blockquote>\n<h2 id=\"5️-멀티프로세스와-멀티스레드\">5️⃣ 멀티프로세스와 멀티스레드</h2>\n<h3 id=\"멀티프로세스-multiprocess\">멀티프로세스 (Multiprocess)</h3>\n<p><code class=\"language-text\">멀티프로세스</code>는 동시에 여러 프로세스가 실행되는 것을 말한다. 같은 프로그램을 각기 다른 여러 프로세스로 생성하여 실행한다.</p>\n<p><strong>🌐 웹 브라우저의 탭</strong></p>\n<p>웹 브라우저는 일반적으로 하나의 탭마다 하나의 프로세스로 동작한다. Windows의 작업 관리자에서 크롬 브라우저를 열면 탭마다 별도의 프로세스가 실행되는 것을 확인할 수 있다.</p>\n<p><strong>🔒 멀티프로세스의 특징</strong></p>\n<ul>\n<li>각 프로세스는 <strong>자원을 공유하지 않고 독립적으로 실행</strong></li>\n<li>각각 다른 PID를 가짐</li>\n<li>프로세스별로 파일과 입출력장치 등의 자원이 독립적으로 할당</li>\n<li>한 프로세스에 문제가 발생해도 다른 프로세스에 직접적인 영향이 적음</li>\n</ul>\n<h3 id=\"멀티스레드-multithread\">멀티스레드 (Multithread)</h3>\n<p><code class=\"language-text\">멀티스레드</code>는 하나의 프로세스 내에서 여러 스레드가 동시에 실행되는 것을 말한다.</p>\n<h4 id=\"5-1-스레드의-구성-요소\">5-1 스레드의 구성 요소</h4>\n<p>하나의 스레드는 다음으로 구성된다:</p>\n<ul>\n<li>스레드 ID (Thread ID)</li>\n<li>프로그램 카운터 (Program Counter)</li>\n<li>레지스터 값 (Register)</li>\n<li>스택 (Stack)</li>\n</ul>\n<p>스레드마다 각각의 프로그램 카운터와 스택을 가지므로:</p>\n<ul>\n<li>스레드마다 다음에 실행할 주소를 가질 수 있음</li>\n<li>연산 과정의 임시 저장 값을 가질 수 있음</li>\n</ul>\n<h4 id=\"5-2-멀티프로세스-vs-멀티스레드\">5-2 멀티프로세스 vs 멀티스레드</h4>\n<p><strong>자원 공유의 차이</strong></p>\n<table>\n<thead>\n<tr>\n<th>구분</th>\n<th>멀티프로세스</th>\n<th>멀티스레드</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>자원 공유</td>\n<td>자원을 공유하지 않음</td>\n<td>프로세스의 자원을 공유</td>\n</tr>\n<tr>\n<td>독립성</td>\n<td>독립적으로 실행</td>\n<td>코드, 데이터, 힙 영역 공유</td>\n</tr>\n<tr>\n<td>통신/협력</td>\n<td>어려움</td>\n<td>쉬움</td>\n</tr>\n<tr>\n<td>장애 격리</td>\n<td>한 프로세스 문제가 다른 프로세스에 영향 적음</td>\n<td>한 스레드 문제가 프로세스 전체에 영향</td>\n</tr>\n</tbody>\n</table>\n<p><strong>🤝 멀티스레드의 장점</strong></p>\n<ul>\n<li>같은 프로세스 내 스레드들은 코드, 데이터, 힙 영역을 공유</li>\n<li>열린 파일과 같은 프로세스 자원을 공유</li>\n<li>쉽게 협력하고 통신할 수 있음</li>\n</ul>\n<p><strong>⚠️ 멀티스레드의 단점</strong></p>\n<ul>\n<li>한 스레드에 생긴 문제가 프로세스 전체의 문제가 될 수 있음</li>\n</ul>\n<h3 id=\"멀티스레드-예제\">멀티스레드 예제</h3>\n<p>다음은 Python으로 작성한 멀티스레드 예제다:</p>\n<div class=\"gatsby-highlight\" data-language=\"python\"><pre class=\"language-python\"><code class=\"language-python\"><span class=\"token comment\"># filepath: os/multiprocessing.py</span>\n<span class=\"token keyword\">import</span> threading\n<span class=\"token keyword\">import</span> os\n\n<span class=\"token keyword\">def</span> <span class=\"token function\">foo</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span>\n    pid <span class=\"token operator\">=</span> os<span class=\"token punctuation\">.</span>getpid<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>              <span class=\"token comment\"># 현재 프로세스의 PID 반환</span>\n    tid <span class=\"token operator\">=</span> threading<span class=\"token punctuation\">.</span>get_native_id<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token comment\"># 현재 스레드의 ID 반환</span>\n    <span class=\"token keyword\">print</span><span class=\"token punctuation\">(</span><span class=\"token string-interpolation\"><span class=\"token string\">f\"foo: PID=</span><span class=\"token interpolation\"><span class=\"token punctuation\">{</span>pid<span class=\"token punctuation\">}</span></span><span class=\"token string\">, Thread ID=</span><span class=\"token interpolation\"><span class=\"token punctuation\">{</span>tid<span class=\"token punctuation\">}</span></span><span class=\"token string\">\"</span></span><span class=\"token punctuation\">)</span>\n\n<span class=\"token keyword\">def</span> <span class=\"token function\">bar</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span>\n    pid <span class=\"token operator\">=</span> os<span class=\"token punctuation\">.</span>getpid<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n    tid <span class=\"token operator\">=</span> threading<span class=\"token punctuation\">.</span>get_native_id<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n    <span class=\"token keyword\">print</span><span class=\"token punctuation\">(</span><span class=\"token string-interpolation\"><span class=\"token string\">f\"bar: PID=</span><span class=\"token interpolation\"><span class=\"token punctuation\">{</span>pid<span class=\"token punctuation\">}</span></span><span class=\"token string\">, Thread ID=</span><span class=\"token interpolation\"><span class=\"token punctuation\">{</span>tid<span class=\"token punctuation\">}</span></span><span class=\"token string\">\"</span></span><span class=\"token punctuation\">)</span>\n\n<span class=\"token keyword\">def</span> <span class=\"token function\">baz</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span>\n    pid <span class=\"token operator\">=</span> os<span class=\"token punctuation\">.</span>getpid<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n    tid <span class=\"token operator\">=</span> threading<span class=\"token punctuation\">.</span>get_native_id<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n    <span class=\"token keyword\">print</span><span class=\"token punctuation\">(</span><span class=\"token string-interpolation\"><span class=\"token string\">f\"baz: PID=</span><span class=\"token interpolation\"><span class=\"token punctuation\">{</span>pid<span class=\"token punctuation\">}</span></span><span class=\"token string\">, Thread ID=</span><span class=\"token interpolation\"><span class=\"token punctuation\">{</span>tid<span class=\"token punctuation\">}</span></span><span class=\"token string\">\"</span></span><span class=\"token punctuation\">)</span>\n\n<span class=\"token keyword\">if</span> __name__ <span class=\"token operator\">==</span> <span class=\"token string\">'__main__'</span><span class=\"token punctuation\">:</span>\n    thread1 <span class=\"token operator\">=</span> threading<span class=\"token punctuation\">.</span>Thread<span class=\"token punctuation\">(</span>target<span class=\"token operator\">=</span>foo<span class=\"token punctuation\">)</span>  <span class=\"token comment\"># 첫 번째 스레드 생성</span>\n    thread2 <span class=\"token operator\">=</span> threading<span class=\"token punctuation\">.</span>Thread<span class=\"token punctuation\">(</span>target<span class=\"token operator\">=</span>bar<span class=\"token punctuation\">)</span>  <span class=\"token comment\"># 두 번째 스레드 생성</span>\n    thread3 <span class=\"token operator\">=</span> threading<span class=\"token punctuation\">.</span>Thread<span class=\"token punctuation\">(</span>target<span class=\"token operator\">=</span>baz<span class=\"token punctuation\">)</span>  <span class=\"token comment\"># 세 번째 스레드 생성</span>\n\n    thread1<span class=\"token punctuation\">.</span>start<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>  <span class=\"token comment\"># 첫 번째 스레드 실행</span>\n    thread2<span class=\"token punctuation\">.</span>start<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>  <span class=\"token comment\"># 두 번째 스레드 실행</span>\n    thread3<span class=\"token punctuation\">.</span>start<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>  <span class=\"token comment\"># 세 번째 스레드 실행</span></code></pre></div>\n<p><strong>실행 결과</strong></p>\n<div class=\"gatsby-highlight\" data-language=\"bash\"><pre class=\"language-bash\"><code class=\"language-bash\">foo: <span class=\"token assign-left variable\">PID</span><span class=\"token operator\">=</span><span class=\"token number\">5113</span>, <span class=\"token assign-left variable\">TID</span><span class=\"token operator\">=</span><span class=\"token number\">2149548</span>\nbar: <span class=\"token assign-left variable\">PID</span><span class=\"token operator\">=</span><span class=\"token number\">5113</span>, <span class=\"token assign-left variable\">TID</span><span class=\"token operator\">=</span><span class=\"token number\">2149549</span>\nbaz: <span class=\"token assign-left variable\">PID</span><span class=\"token operator\">=</span><span class=\"token number\">5113</span>, <span class=\"token assign-left variable\">TID</span><span class=\"token operator\">=</span><span class=\"token number\">2149550</span></code></pre></div>\n<p>3개의 스레드가 실행하는 각기 다른 함수를 통해 출력되는 <strong>PID 값은 같지만</strong>, <strong>스레드 ID는 다르다</strong>. 스레드들이 같은 프로세스를 공유하기 때문이다.</p>\n<blockquote>\n<p>💡 <strong>스레드 조인 (Thread Join)</strong></p>\n<p><code class=\"language-text\">join()</code>은 스레드를 생성한 주체가 생성/실행된 스레드가 종료될 때까지 대기해야 함을 의미한다.</p>\n<p><strong>C++ 공식 문서</strong></p>\n<div class=\"gatsby-highlight\" data-language=\"cpp\"><pre class=\"language-cpp\"><code class=\"language-cpp\"><span class=\"token keyword\">void</span> <span class=\"token function\">join</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token comment\">// Join thread</span>\n<span class=\"token comment\">// The function returns when the thread execution has completed.</span></code></pre></div>\n<p><strong>Python 공식 문서</strong></p>\n<div class=\"gatsby-highlight\" data-language=\"python\"><pre class=\"language-python\"><code class=\"language-python\">join<span class=\"token punctuation\">(</span>timeout<span class=\"token operator\">=</span><span class=\"token boolean\">None</span><span class=\"token punctuation\">)</span>\n<span class=\"token comment\"># 스레드가 종료할 때까지 기다립니다.</span></code></pre></div>\n<p><strong>예제 코드에 join 추가</strong></p>\n<div class=\"gatsby-highlight\" data-language=\"python\"><pre class=\"language-python\"><code class=\"language-python\">thread1<span class=\"token punctuation\">.</span>join<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>  <span class=\"token comment\"># thread1 종료까지 대기</span>\nthread2<span class=\"token punctuation\">.</span>join<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>  <span class=\"token comment\"># thread2 종료까지 대기</span>\nthread3<span class=\"token punctuation\">.</span>join<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>  <span class=\"token comment\"># thread3 종료까지 대기</span></code></pre></div>\n</blockquote>\n<h2 id=\"6️-프로세스-간-통신-ipc\">6️⃣ 프로세스 간 통신 (IPC)</h2>\n<p>프로세스는 기본적으로 자원을 공유하지 않지만, <code class=\"language-text\">IPC(Inter-Process Communication)</code>를 통해 자원을 공유하고 데이터를 주고받을 수 있다.</p>\n<p>IPC 방식은 크게 두 가지로 나뉜다:</p>\n<ul>\n<li><strong>공유 메모리 (Shared Memory)</strong></li>\n<li><strong>메시지 전달 (Message Passing)</strong></li>\n</ul>\n<h3 id=\"공유-메모리-shared-memory\">공유 메모리 (Shared Memory)</h3>\n<p><code class=\"language-text\">공유 메모리</code>는 프로세스 간에 공유하는 메모리 영역을 통해 데이터를 주고받는 통신 방식이다.</p>\n<h4 id=\"6-1-동작-원리\">6-1 동작 원리</h4>\n<ul>\n<li>특정 메모리 공간을 두 개 이상의 프로세스가 공유</li>\n<li>프로세스 A는 공유 메모리 공간에 데이터를 쓰기</li>\n<li>프로세스 B는 해당 메모리 공간을 읽기</li>\n<li>결과적으로 프로세스 간 데이터 공유</li>\n</ul>\n<p><strong>📁 파일 기반 공유 메모리 예시</strong></p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">프로세스 A: hi.txt 파일을 수정하는 프로세스\n프로세스 B: hi.txt 파일을 읽는 프로세스\n→ 두 프로세스는 hi.txt를 매개로 통신</code></pre></div>\n<h4 id=\"6-2-공유-메모리의-특징\">6-2 공유 메모리의 특징</h4>\n<p><strong>✅ 장점</strong></p>\n<ul>\n<li>각 프로세스가 자신의 메모리 영역을 읽고 쓰는 것처럼 통신</li>\n<li>커널의 개입이 거의 없음 (데이터가 커널 영역을 거치지 않음)</li>\n<li><strong>통신 속도가 빠름</strong></li>\n</ul>\n<p><strong>⚠️ 단점</strong></p>\n<ul>\n<li>여러 프로세스가 동시에 공유 메모리 영역을 읽고 쓸 경우 데이터 일관성 훼손 가능</li>\n<li><code class=\"language-text\">레이스 컨디션(Race Condition)</code> 문제 발생 가능</li>\n</ul>\n<h3 id=\"메시지-전달-message-passing\">메시지 전달 (Message Passing)</h3>\n<p><code class=\"language-text\">메시지 전달</code>은 프로세스 간에 주고받을 데이터가 커널을 거쳐 송수신되는 통신 방식이다.</p>\n<h4 id=\"6-3-동작-원리\">6-3 동작 원리</h4>\n<ul>\n<li>메시지를 보내는 수단과 받는 수단이 명확하게 구분</li>\n<li><code class=\"language-text\">send()</code> 시스템 콜: 메시지 전송</li>\n<li><code class=\"language-text\">recv()</code> 시스템 콜: 메시지 수신</li>\n</ul>\n<h4 id=\"6-4-메시지-전달의-특징\">6-4 메시지 전달의 특징</h4>\n<p><strong>✅ 장점</strong></p>\n<ul>\n<li>커널의 도움을 적극적으로 받을 수 있음</li>\n<li>레이스 컨디션, 동기화 문제를 고려하는 일이 상대적으로 적음</li>\n<li>안전한 통신 가능</li>\n</ul>\n<p><strong>⚠️ 단점</strong></p>\n<ul>\n<li>주고받는 데이터가 커널을 통해 송수신</li>\n<li><strong>공유 메모리 기반 IPC보다 통신 속도가 느림</strong></li>\n</ul>\n<h3 id=\"메시지-전달-방식의-종류\">메시지 전달 방식의 종류</h3>\n<h4 id=\"6-5-파이프-pipe\">6-5 파이프 (Pipe)</h4>\n<p><code class=\"language-text\">파이프</code>는 단방향 프로세스 간 통신 도구다.</p>\n<ul>\n<li>프로세스 A가 파이프 한쪽에서 데이터를 쓰기</li>\n<li>프로세스 B가 파이프 반대쪽에서 데이터를 읽기</li>\n<li>먼저 삽입된 데이터가 먼저 읽힘 (FIFO)</li>\n</ul>\n<p><strong>📊 파이프의 종류</strong></p>\n<table>\n<thead>\n<tr>\n<th>종류</th>\n<th>설명</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>익명 파이프 (Unnamed Pipe)</td>\n<td>단방향 통신만 지원, 부모-자식 프로세스 간 통신만 가능</td>\n</tr>\n<tr>\n<td>지명 파이프 (Named Pipe)</td>\n<td>양방향 통신 지원, 임의의 프로세스 간 통신 가능 (FIFO)</td>\n</tr>\n</tbody>\n</table>\n<h4 id=\"6-6-시그널-signal\">6-6 시그널 (Signal)</h4>\n<p><code class=\"language-text\">시그널</code>은 프로세스에게 특정 이벤트가 발생했음을 알리는 비동기적인 신호다.</p>\n<p><strong>⚡ 리눅스의 대표적인 시그널</strong></p>\n<table>\n<thead>\n<tr>\n<th>시그널</th>\n<th>설명</th>\n<th>기본 동작</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>SIGCHLD</td>\n<td>자식 프로세스 종료</td>\n<td>무시</td>\n</tr>\n<tr>\n<td>SIGILL</td>\n<td>허용하지 않은 명령어 실행</td>\n<td>코어 덤프 생성 후 종료</td>\n</tr>\n<tr>\n<td>SIGINT</td>\n<td>키보드 인터럽트 (Ctrl + C)</td>\n<td>종료</td>\n</tr>\n<tr>\n<td>SIGKILL</td>\n<td>프로세스 종료 (핸들러 재정의 불가)</td>\n<td>종료</td>\n</tr>\n<tr>\n<td>SIGSEGV</td>\n<td>잘못된 메모리 접근</td>\n<td>코어 덤프 생성 후 종료</td>\n</tr>\n<tr>\n<td>SIGTERM</td>\n<td>프로세스 종료 (핸들러 재정의 가능)</td>\n<td>종료</td>\n</tr>\n<tr>\n<td>SIGUSR1, SIGUSR2</td>\n<td>사용자 정의 시그널</td>\n<td>종료</td>\n</tr>\n</tbody>\n</table>\n<p><strong>🔔 시그널 처리 과정</strong></p>\n<ol>\n<li>프로세스는 시그널 발생 시 하던 일을 잠시 중단</li>\n<li><code class=\"language-text\">시그널 핸들러(Signal Handler)</code> 실행</li>\n<li>실행 재개</li>\n</ol>\n<p>프로세스는 직접 특정 시그널을 발생시킬 수 있고, 일부 시그널 핸들러를 재정의할 수 있다.</p>\n<p><strong>Python 시그널 처리 예시</strong></p>\n<div class=\"gatsby-highlight\" data-language=\"python\"><pre class=\"language-python\"><code class=\"language-python\"><span class=\"token comment\"># filepath: signal 모듈 사용 예시</span>\n<span class=\"token keyword\">import</span> signal\n\n<span class=\"token keyword\">def</span> <span class=\"token function\">signal_handler</span><span class=\"token punctuation\">(</span>signum<span class=\"token punctuation\">,</span> frame<span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span>\n    <span class=\"token keyword\">print</span><span class=\"token punctuation\">(</span><span class=\"token string-interpolation\"><span class=\"token string\">f\"Signal </span><span class=\"token interpolation\"><span class=\"token punctuation\">{</span>signum<span class=\"token punctuation\">}</span></span><span class=\"token string\"> received\"</span></span><span class=\"token punctuation\">)</span>\n\n<span class=\"token comment\"># SIGINT 시그널에 대한 핸들러 등록</span>\nsignal<span class=\"token punctuation\">.</span>signal<span class=\"token punctuation\">(</span>signal<span class=\"token punctuation\">.</span>SIGINT<span class=\"token punctuation\">,</span> signal_handler<span class=\"token punctuation\">)</span></code></pre></div>\n<blockquote>\n<p>💡 <strong>코어 덤프 (Core Dump)</strong></p>\n<p><code class=\"language-text\">코어 덤프</code>는 주로 비정상적으로 종료하는 경우에 생성되는 파일로, 프로그램이 특정 시점에 작업하던 메모리 상태가 기록되어 있다. 디버깅 용도로 매우 유용하다.</p>\n<p><strong>코어 덤프 생성 예제</strong></p>\n<div class=\"gatsby-highlight\" data-language=\"python\"><pre class=\"language-python\"><code class=\"language-python\"><span class=\"token comment\"># filepath: os/coredumped.py</span>\n<span class=\"token keyword\">import</span> ctypes\n\n<span class=\"token keyword\">def</span> <span class=\"token function\">bug</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span>\n    ctypes<span class=\"token punctuation\">.</span>string_at<span class=\"token punctuation\">(</span><span class=\"token number\">0</span><span class=\"token punctuation\">)</span>  <span class=\"token comment\"># 잘못된 메모리 접근</span>\n\nbug<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span></code></pre></div>\n<p><strong>실행 결과</strong></p>\n<div class=\"gatsby-highlight\" data-language=\"bash\"><pre class=\"language-bash\"><code class=\"language-bash\">$ python3 coredumped.py\nSegmentation fault <span class=\"token punctuation\">(</span>core dumped<span class=\"token punctuation\">)</span></code></pre></div>\n<p><strong>코어 덤프 파일 확인</strong></p>\n<div class=\"gatsby-highlight\" data-language=\"bash\"><pre class=\"language-bash\"><code class=\"language-bash\">$ coredumpctl info\nPID: <span class=\"token number\">7990</span> <span class=\"token punctuation\">(</span>python3<span class=\"token punctuation\">)</span>\nSignal: <span class=\"token number\">11</span> <span class=\"token punctuation\">(</span>SEGV<span class=\"token punctuation\">)</span>\nTimestamp: Mon <span class=\"token number\">2024</span>-02-26 <span class=\"token number\">15</span>:40:36 KST\nCommand Line: python3 coredumped.py\nExecutable: /usr/bin/python3.8\nStorage: /var/lib/systemd/coredump/core.python3.1000<span class=\"token punctuation\">..</span>.</code></pre></div>\n</blockquote>\n<h4 id=\"6-7-소켓-socket\">6-7 소켓 (Socket)</h4>\n<p>네트워크 소켓을 통해 IPC를 수행할 수 있다.</p>\n<h4 id=\"6-8-원격-프로시저-호출-rpc\">6-8 원격 프로시저 호출 (RPC)</h4>\n<p><code class=\"language-text\">RPC(Remote Procedure Call)</code>는 원격 코드를 실행하는 IPC 기술이다.</p>\n<p><strong>🌐 RPC의 특징</strong></p>\n<ul>\n<li>한 프로세스 내의 코드 실행: 로컬 프로시저 호출</li>\n<li>다른 프로세스의 원격 코드 실행: 원격 프로시저 호출</li>\n<li>프로그래밍 언어나 플랫폼과 무관하게 메시지 송수신 가능</li>\n<li>성능 저하 최소화</li>\n<li>대규모 트래픽 처리 환경, 서버 간 통신 환경에서 주로 사용</li>\n</ul>\n<p><strong>⚙️ RPC 프레임워크</strong></p>\n<p>대표적인 RPC 프레임워크는 구글의 <code class=\"language-text\">gRPC</code>다.</p>\n<h2 id=\"7️-정리\">7️⃣ 정리</h2>\n<p>프로세스와 스레드의 핵심 개념을 정리하면 다음과 같다:</p>\n<p><strong>프로세스</strong></p>\n<ul>\n<li>실행 중인 프로그램</li>\n<li>코드, 데이터, 힙, 스택 영역으로 구성</li>\n<li>PCB를 통해 운영체제가 관리</li>\n<li>문맥 교환을 통해 여러 프로세스가 번갈아 가며 실행</li>\n</ul>\n<p><strong>스레드</strong></p>\n<ul>\n<li>프로세스 내 실행 단위</li>\n<li>프로세스의 자원을 공유</li>\n<li>각자의 스택과 프로그램 카운터를 가짐</li>\n</ul>\n<p><strong>IPC</strong></p>\n<ul>\n<li>공유 메모리: 빠르지만 동기화 문제 발생 가능</li>\n<li>메시지 전달: 안전하지만 상대적으로 느림</li>\n<li>파이프, 시그널, 소켓, RPC 등 다양한 방식 존재</li>\n</ul>","fields":{"slug":"/os-process-thread/"},"frontmatter":{"title":"[운영체제] 2. 프로세스와 스레드","date":"2026-01-23","description":"이것이 취업을 위한 컴퓨터 과학이다 + 혼자 공부하는 컴퓨터 구조/운영체제를 읽으면서 배운 내용을 정리합니다.","pointColor":"#ffffff","tags":["운영체제"],"keywords":"운영체제, OS, 프로세스, 스레드, PCB, 문맥교환, 멀티프로세스, 멀티스레드, IPC, 공유메모리, 메시지전달","thumbnail":{"publicURL":"/static/3a18a98e16471cfd320f4cce5ad16a0c/index.png","childImageSharp":{"gatsbyImageData":{"layout":"fixed","placeholder":{"fallback":"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAKCAYAAAC0VX7mAAAACXBIWXMAACE4AAAhOAFFljFgAAABZklEQVR42o1STUsCURSdGf9BEC0M3ASJECZYCUUto9rWL2hdOX5nmz60QZPR0RlHJM2IFhHtWhRt+tjWojYF/pjTfc+ZRlLRxeG8N9w599zzriDsJ9APIkFKJyESGEsHKedsfe/77yBBIRGFENmDEA07bIPd45HRBJkzIRnFpJLF2kUDoaqO9VYDK/UaPy/XTaw2z+FVC7xpj9P/gi5WQA42r6/w1G4j/fiA+59vqG+vaH28I//yjJuvT2zf3fI61zBBiTGNEyiXsEWi/pLKxRfIHXPGsHHZRFDXeJ000siWKM+LsbzTyS1MLO9yFmMyxFR8sMNOdjFMZI8xdnKIafWM57ZoGliqVeErFjBvlOHXinBTvkG9zDP25E4dE/0E3UoG45kjTBXyCJk6ApUSja9xwVmKwUuNPDkFM5qKOaMCHz2O1O2y59lpjD+mBhxsbPvO1slqzs92/bA9FLvy7F4NcUCNjV+zOZ1GLVTb5wAAAABJRU5ErkJggg=="},"backgroundColor":"transparent","images":{"fallback":{"src":"/static/3a18a98e16471cfd320f4cce5ad16a0c/a1758/index.png","srcSet":"/static/3a18a98e16471cfd320f4cce5ad16a0c/a1758/index.png 1200w","sizes":"1200px"},"sources":[{"srcSet":"/static/3a18a98e16471cfd320f4cce5ad16a0c/afc39/index.webp 1200w","type":"image/webp","sizes":"1200px"}]},"width":1200,"height":585},"fixed":{"src":"/static/3a18a98e16471cfd320f4cce5ad16a0c/f3583/index.png"}}}}},"previous":{"fields":{"slug":"/os-big-picture/"},"frontmatter":{"title":"[운영체제] 1. 운영체제의 큰 그림"}},"next":{"fields":{"slug":"/os-synchronization-deadlock/"},"frontmatter":{"title":"[운영체제] 3. 동기화와 교착 상태"}}},"pageContext":{"id":"b2e55fd0-c415-5a88-86fc-e60c3c4f5ce5","previousPostId":"3c4ccd11-e8ff-5ecf-bc7d-6c65b5dbf718","nextPostId":"0077ac62-c74c-5450-9e62-16dc465e0ea3"}},"staticQueryHashes":["736397157"],"slicesMap":{}}